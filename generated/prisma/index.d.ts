
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Hospital
 * 
 */
export type Hospital = $Result.DefaultSelection<Prisma.$HospitalPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model AdminStrator
 * 
 */
export type AdminStrator = $Result.DefaultSelection<Prisma.$AdminStratorPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Consultation
 * 
 */
export type Consultation = $Result.DefaultSelection<Prisma.$ConsultationPayload>
/**
 * Model Treatment
 * 
 */
export type Treatment = $Result.DefaultSelection<Prisma.$TreatmentPayload>
/**
 * Model Medician
 * 
 */
export type Medician = $Result.DefaultSelection<Prisma.$MedicianPayload>
/**
 * Model Injection
 * 
 */
export type Injection = $Result.DefaultSelection<Prisma.$InjectionPayload>
/**
 * Model TestingAndScanningH
 * 
 */
export type TestingAndScanningH = $Result.DefaultSelection<Prisma.$TestingAndScanningHPayload>
/**
 * Model MedicineAndInjection
 * 
 */
export type MedicineAndInjection = $Result.DefaultSelection<Prisma.$MedicineAndInjectionPayload>
/**
 * Model TestingAndScanningP
 * 
 */
export type TestingAndScanningP = $Result.DefaultSelection<Prisma.$TestingAndScanningPPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model RoomsAvailable
 * 
 */
export type RoomsAvailable = $Result.DefaultSelection<Prisma.$RoomsAvailablePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const HospitalStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type HospitalStatus = (typeof HospitalStatus)[keyof typeof HospitalStatus]


export const PaymentStatus: {
  success: 'success',
  failed: 'failed'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type HospitalStatus = $Enums.HospitalStatus

export const HospitalStatus: typeof $Enums.HospitalStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Hospitals
 * const hospitals = await prisma.hospital.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Hospitals
   * const hospitals = await prisma.hospital.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitals
    * const hospitals = await prisma.hospital.findMany()
    * ```
    */
  get hospital(): Prisma.HospitalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminStrator`: Exposes CRUD operations for the **AdminStrator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminStrators
    * const adminStrators = await prisma.adminStrator.findMany()
    * ```
    */
  get adminStrator(): Prisma.AdminStratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultation`: Exposes CRUD operations for the **Consultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultation.findMany()
    * ```
    */
  get consultation(): Prisma.ConsultationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treatment`: Exposes CRUD operations for the **Treatment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treatments
    * const treatments = await prisma.treatment.findMany()
    * ```
    */
  get treatment(): Prisma.TreatmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medician`: Exposes CRUD operations for the **Medician** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicians
    * const medicians = await prisma.medician.findMany()
    * ```
    */
  get medician(): Prisma.MedicianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.injection`: Exposes CRUD operations for the **Injection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Injections
    * const injections = await prisma.injection.findMany()
    * ```
    */
  get injection(): Prisma.InjectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testingAndScanningH`: Exposes CRUD operations for the **TestingAndScanningH** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestingAndScanningHS
    * const testingAndScanningHS = await prisma.testingAndScanningH.findMany()
    * ```
    */
  get testingAndScanningH(): Prisma.TestingAndScanningHDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineAndInjection`: Exposes CRUD operations for the **MedicineAndInjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineAndInjections
    * const medicineAndInjections = await prisma.medicineAndInjection.findMany()
    * ```
    */
  get medicineAndInjection(): Prisma.MedicineAndInjectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testingAndScanningP`: Exposes CRUD operations for the **TestingAndScanningP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestingAndScanningPS
    * const testingAndScanningPS = await prisma.testingAndScanningP.findMany()
    * ```
    */
  get testingAndScanningP(): Prisma.TestingAndScanningPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomsAvailable`: Exposes CRUD operations for the **RoomsAvailable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomsAvailables
    * const roomsAvailables = await prisma.roomsAvailable.findMany()
    * ```
    */
  get roomsAvailable(): Prisma.RoomsAvailableDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Hospital: 'Hospital',
    User: 'User',
    Admin: 'Admin',
    AdminStrator: 'AdminStrator',
    Patient: 'Patient',
    Consultation: 'Consultation',
    Treatment: 'Treatment',
    Medician: 'Medician',
    Injection: 'Injection',
    TestingAndScanningH: 'TestingAndScanningH',
    MedicineAndInjection: 'MedicineAndInjection',
    TestingAndScanningP: 'TestingAndScanningP',
    Payment: 'Payment',
    RoomsAvailable: 'RoomsAvailable'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "hospital" | "user" | "admin" | "adminStrator" | "patient" | "consultation" | "treatment" | "medician" | "injection" | "testingAndScanningH" | "medicineAndInjection" | "testingAndScanningP" | "payment" | "roomsAvailable"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Hospital: {
        payload: Prisma.$HospitalPayload<ExtArgs>
        fields: Prisma.HospitalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findFirst: {
            args: Prisma.HospitalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findMany: {
            args: Prisma.HospitalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          create: {
            args: Prisma.HospitalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          createMany: {
            args: Prisma.HospitalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HospitalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          update: {
            args: Prisma.HospitalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          deleteMany: {
            args: Prisma.HospitalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HospitalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          aggregate: {
            args: Prisma.HospitalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospital>
          }
          groupBy: {
            args: Prisma.HospitalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      AdminStrator: {
        payload: Prisma.$AdminStratorPayload<ExtArgs>
        fields: Prisma.AdminStratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminStratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminStratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>
          }
          findFirst: {
            args: Prisma.AdminStratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminStratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>
          }
          findMany: {
            args: Prisma.AdminStratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>[]
          }
          create: {
            args: Prisma.AdminStratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>
          }
          createMany: {
            args: Prisma.AdminStratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminStratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>
          }
          update: {
            args: Prisma.AdminStratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>
          }
          deleteMany: {
            args: Prisma.AdminStratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminStratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminStratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminStratorPayload>
          }
          aggregate: {
            args: Prisma.AdminStratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminStrator>
          }
          groupBy: {
            args: Prisma.AdminStratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminStratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminStratorCountArgs<ExtArgs>
            result: $Utils.Optional<AdminStratorCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Consultation: {
        payload: Prisma.$ConsultationPayload<ExtArgs>
        fields: Prisma.ConsultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findFirst: {
            args: Prisma.ConsultationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findMany: {
            args: Prisma.ConsultationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          create: {
            args: Prisma.ConsultationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          createMany: {
            args: Prisma.ConsultationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConsultationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          update: {
            args: Prisma.ConsultationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          aggregate: {
            args: Prisma.ConsultationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultation>
          }
          groupBy: {
            args: Prisma.ConsultationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationCountAggregateOutputType> | number
          }
        }
      }
      Treatment: {
        payload: Prisma.$TreatmentPayload<ExtArgs>
        fields: Prisma.TreatmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          findFirst: {
            args: Prisma.TreatmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          findMany: {
            args: Prisma.TreatmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>[]
          }
          create: {
            args: Prisma.TreatmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          createMany: {
            args: Prisma.TreatmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TreatmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          update: {
            args: Prisma.TreatmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreatmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentPayload>
          }
          aggregate: {
            args: Prisma.TreatmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatment>
          }
          groupBy: {
            args: Prisma.TreatmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentCountAggregateOutputType> | number
          }
        }
      }
      Medician: {
        payload: Prisma.$MedicianPayload<ExtArgs>
        fields: Prisma.MedicianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>
          }
          findFirst: {
            args: Prisma.MedicianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>
          }
          findMany: {
            args: Prisma.MedicianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>[]
          }
          create: {
            args: Prisma.MedicianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>
          }
          createMany: {
            args: Prisma.MedicianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>
          }
          update: {
            args: Prisma.MedicianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>
          }
          deleteMany: {
            args: Prisma.MedicianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicianPayload>
          }
          aggregate: {
            args: Prisma.MedicianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedician>
          }
          groupBy: {
            args: Prisma.MedicianGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicianGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicianCountArgs<ExtArgs>
            result: $Utils.Optional<MedicianCountAggregateOutputType> | number
          }
        }
      }
      Injection: {
        payload: Prisma.$InjectionPayload<ExtArgs>
        fields: Prisma.InjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>
          }
          findFirst: {
            args: Prisma.InjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>
          }
          findMany: {
            args: Prisma.InjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>[]
          }
          create: {
            args: Prisma.InjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>
          }
          createMany: {
            args: Prisma.InjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>
          }
          update: {
            args: Prisma.InjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>
          }
          deleteMany: {
            args: Prisma.InjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InjectionPayload>
          }
          aggregate: {
            args: Prisma.InjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInjection>
          }
          groupBy: {
            args: Prisma.InjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InjectionCountArgs<ExtArgs>
            result: $Utils.Optional<InjectionCountAggregateOutputType> | number
          }
        }
      }
      TestingAndScanningH: {
        payload: Prisma.$TestingAndScanningHPayload<ExtArgs>
        fields: Prisma.TestingAndScanningHFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestingAndScanningHFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestingAndScanningHFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>
          }
          findFirst: {
            args: Prisma.TestingAndScanningHFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestingAndScanningHFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>
          }
          findMany: {
            args: Prisma.TestingAndScanningHFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>[]
          }
          create: {
            args: Prisma.TestingAndScanningHCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>
          }
          createMany: {
            args: Prisma.TestingAndScanningHCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestingAndScanningHDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>
          }
          update: {
            args: Prisma.TestingAndScanningHUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>
          }
          deleteMany: {
            args: Prisma.TestingAndScanningHDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestingAndScanningHUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestingAndScanningHUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningHPayload>
          }
          aggregate: {
            args: Prisma.TestingAndScanningHAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestingAndScanningH>
          }
          groupBy: {
            args: Prisma.TestingAndScanningHGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestingAndScanningHGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestingAndScanningHCountArgs<ExtArgs>
            result: $Utils.Optional<TestingAndScanningHCountAggregateOutputType> | number
          }
        }
      }
      MedicineAndInjection: {
        payload: Prisma.$MedicineAndInjectionPayload<ExtArgs>
        fields: Prisma.MedicineAndInjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineAndInjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineAndInjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>
          }
          findFirst: {
            args: Prisma.MedicineAndInjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineAndInjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>
          }
          findMany: {
            args: Prisma.MedicineAndInjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>[]
          }
          create: {
            args: Prisma.MedicineAndInjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>
          }
          createMany: {
            args: Prisma.MedicineAndInjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicineAndInjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>
          }
          update: {
            args: Prisma.MedicineAndInjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>
          }
          deleteMany: {
            args: Prisma.MedicineAndInjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineAndInjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicineAndInjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineAndInjectionPayload>
          }
          aggregate: {
            args: Prisma.MedicineAndInjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineAndInjection>
          }
          groupBy: {
            args: Prisma.MedicineAndInjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineAndInjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineAndInjectionCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineAndInjectionCountAggregateOutputType> | number
          }
        }
      }
      TestingAndScanningP: {
        payload: Prisma.$TestingAndScanningPPayload<ExtArgs>
        fields: Prisma.TestingAndScanningPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestingAndScanningPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestingAndScanningPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>
          }
          findFirst: {
            args: Prisma.TestingAndScanningPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestingAndScanningPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>
          }
          findMany: {
            args: Prisma.TestingAndScanningPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>[]
          }
          create: {
            args: Prisma.TestingAndScanningPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>
          }
          createMany: {
            args: Prisma.TestingAndScanningPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestingAndScanningPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>
          }
          update: {
            args: Prisma.TestingAndScanningPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>
          }
          deleteMany: {
            args: Prisma.TestingAndScanningPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestingAndScanningPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestingAndScanningPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestingAndScanningPPayload>
          }
          aggregate: {
            args: Prisma.TestingAndScanningPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestingAndScanningP>
          }
          groupBy: {
            args: Prisma.TestingAndScanningPGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestingAndScanningPGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestingAndScanningPCountArgs<ExtArgs>
            result: $Utils.Optional<TestingAndScanningPCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      RoomsAvailable: {
        payload: Prisma.$RoomsAvailablePayload<ExtArgs>
        fields: Prisma.RoomsAvailableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomsAvailableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomsAvailableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>
          }
          findFirst: {
            args: Prisma.RoomsAvailableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomsAvailableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>
          }
          findMany: {
            args: Prisma.RoomsAvailableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>[]
          }
          create: {
            args: Prisma.RoomsAvailableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>
          }
          createMany: {
            args: Prisma.RoomsAvailableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomsAvailableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>
          }
          update: {
            args: Prisma.RoomsAvailableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>
          }
          deleteMany: {
            args: Prisma.RoomsAvailableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomsAvailableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomsAvailableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsAvailablePayload>
          }
          aggregate: {
            args: Prisma.RoomsAvailableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomsAvailable>
          }
          groupBy: {
            args: Prisma.RoomsAvailableGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomsAvailableGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomsAvailableCountArgs<ExtArgs>
            result: $Utils.Optional<RoomsAvailableCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    hospital?: HospitalOmit
    user?: UserOmit
    admin?: AdminOmit
    adminStrator?: AdminStratorOmit
    patient?: PatientOmit
    consultation?: ConsultationOmit
    treatment?: TreatmentOmit
    medician?: MedicianOmit
    injection?: InjectionOmit
    testingAndScanningH?: TestingAndScanningHOmit
    medicineAndInjection?: MedicineAndInjectionOmit
    testingAndScanningP?: TestingAndScanningPOmit
    payment?: PaymentOmit
    roomsAvailable?: RoomsAvailableOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HospitalCountOutputType
   */

  export type HospitalCountOutputType = {
    Users: number
    Admins: number
    Patients: number
    Consultation: number
    Treatments: number
    Medicians: number
    Injections: number
    TestingAndScannings: number
    TestingAndScanningHs: number
    RoomsAvailables: number
    Payments: number
    MedicineAndInjections: number
  }

  export type HospitalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | HospitalCountOutputTypeCountUsersArgs
    Admins?: boolean | HospitalCountOutputTypeCountAdminsArgs
    Patients?: boolean | HospitalCountOutputTypeCountPatientsArgs
    Consultation?: boolean | HospitalCountOutputTypeCountConsultationArgs
    Treatments?: boolean | HospitalCountOutputTypeCountTreatmentsArgs
    Medicians?: boolean | HospitalCountOutputTypeCountMediciansArgs
    Injections?: boolean | HospitalCountOutputTypeCountInjectionsArgs
    TestingAndScannings?: boolean | HospitalCountOutputTypeCountTestingAndScanningsArgs
    TestingAndScanningHs?: boolean | HospitalCountOutputTypeCountTestingAndScanningHsArgs
    RoomsAvailables?: boolean | HospitalCountOutputTypeCountRoomsAvailablesArgs
    Payments?: boolean | HospitalCountOutputTypeCountPaymentsArgs
    MedicineAndInjections?: boolean | HospitalCountOutputTypeCountMedicineAndInjectionsArgs
  }

  // Custom InputTypes
  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalCountOutputType
     */
    select?: HospitalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountMediciansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicianWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountInjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InjectionWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountTestingAndScanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestingAndScanningPWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountTestingAndScanningHsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestingAndScanningHWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountRoomsAvailablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomsAvailableWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountMedicineAndInjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineAndInjectionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    AdminStrator: number
    Admin: number
    Patient: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminStrator?: boolean | UserCountOutputTypeCountAdminStratorArgs
    Admin?: boolean | UserCountOutputTypeCountAdminArgs
    Patient?: boolean | UserCountOutputTypeCountPatientArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminStratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminStratorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    Consultation: number
    Doctor: number
    Staff: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Consultation?: boolean | AdminCountOutputTypeCountConsultationArgs
    Doctor?: boolean | AdminCountOutputTypeCountDoctorArgs
    Staff?: boolean | AdminCountOutputTypeCountStaffArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    Consultation: number
    Treatment: number
    MedicineAndInjection: number
    TestingAndScanning: number
    Payments: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Consultation?: boolean | PatientCountOutputTypeCountConsultationArgs
    Treatment?: boolean | PatientCountOutputTypeCountTreatmentArgs
    MedicineAndInjection?: boolean | PatientCountOutputTypeCountMedicineAndInjectionArgs
    TestingAndScanning?: boolean | PatientCountOutputTypeCountTestingAndScanningArgs
    Payments?: boolean | PatientCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTreatmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicineAndInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineAndInjectionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTestingAndScanningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestingAndScanningPWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type TreatmentCountOutputType
   */

  export type TreatmentCountOutputType = {
    Doctor: number
    Staff: number
  }

  export type TreatmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Doctor?: boolean | TreatmentCountOutputTypeCountDoctorArgs
    Staff?: boolean | TreatmentCountOutputTypeCountStaffArgs
  }

  // Custom InputTypes
  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreatmentCountOutputType
     */
    select?: TreatmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeCountDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * TreatmentCountOutputType without action
   */
  export type TreatmentCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }


  /**
   * Count Type MedicianCountOutputType
   */

  export type MedicianCountOutputType = {
    MedicineAndInjection: number
  }

  export type MedicianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MedicineAndInjection?: boolean | MedicianCountOutputTypeCountMedicineAndInjectionArgs
  }

  // Custom InputTypes
  /**
   * MedicianCountOutputType without action
   */
  export type MedicianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicianCountOutputType
     */
    select?: MedicianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicianCountOutputType without action
   */
  export type MedicianCountOutputTypeCountMedicineAndInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineAndInjectionWhereInput
  }


  /**
   * Count Type InjectionCountOutputType
   */

  export type InjectionCountOutputType = {
    MedicineAndInjection: number
  }

  export type InjectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MedicineAndInjection?: boolean | InjectionCountOutputTypeCountMedicineAndInjectionArgs
  }

  // Custom InputTypes
  /**
   * InjectionCountOutputType without action
   */
  export type InjectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InjectionCountOutputType
     */
    select?: InjectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InjectionCountOutputType without action
   */
  export type InjectionCountOutputTypeCountMedicineAndInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineAndInjectionWhereInput
  }


  /**
   * Count Type MedicineAndInjectionCountOutputType
   */

  export type MedicineAndInjectionCountOutputType = {
    Medician: number
    Injection: number
  }

  export type MedicineAndInjectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Medician?: boolean | MedicineAndInjectionCountOutputTypeCountMedicianArgs
    Injection?: boolean | MedicineAndInjectionCountOutputTypeCountInjectionArgs
  }

  // Custom InputTypes
  /**
   * MedicineAndInjectionCountOutputType without action
   */
  export type MedicineAndInjectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjectionCountOutputType
     */
    select?: MedicineAndInjectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineAndInjectionCountOutputType without action
   */
  export type MedicineAndInjectionCountOutputTypeCountMedicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicianWhereInput
  }

  /**
   * MedicineAndInjectionCountOutputType without action
   */
  export type MedicineAndInjectionCountOutputTypeCountInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InjectionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Hospital
   */

  export type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  export type HospitalAvgAggregateOutputType = {
    id: number | null
  }

  export type HospitalSumAggregateOutputType = {
    id: number | null
  }

  export type HospitalMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    photo: string | null
    HospitalStatus: $Enums.HospitalStatus | null
    phone: string | null
    mail: string | null
  }

  export type HospitalMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    photo: string | null
    HospitalStatus: $Enums.HospitalStatus | null
    phone: string | null
    mail: string | null
  }

  export type HospitalCountAggregateOutputType = {
    id: number
    name: number
    address: number
    photo: number
    HospitalStatus: number
    phone: number
    mail: number
    _all: number
  }


  export type HospitalAvgAggregateInputType = {
    id?: true
  }

  export type HospitalSumAggregateInputType = {
    id?: true
  }

  export type HospitalMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    photo?: true
    HospitalStatus?: true
    phone?: true
    mail?: true
  }

  export type HospitalMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    photo?: true
    HospitalStatus?: true
    phone?: true
    mail?: true
  }

  export type HospitalCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    photo?: true
    HospitalStatus?: true
    phone?: true
    mail?: true
    _all?: true
  }

  export type HospitalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospitalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospitalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType
  }

  export type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
        [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospital[P]>
      : GetScalarType<T[P], AggregateHospital[P]>
  }




  export type HospitalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalWhereInput
    orderBy?: HospitalOrderByWithAggregationInput | HospitalOrderByWithAggregationInput[]
    by: HospitalScalarFieldEnum[] | HospitalScalarFieldEnum
    having?: HospitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalCountAggregateInputType | true
    _avg?: HospitalAvgAggregateInputType
    _sum?: HospitalSumAggregateInputType
    _min?: HospitalMinAggregateInputType
    _max?: HospitalMaxAggregateInputType
  }

  export type HospitalGroupByOutputType = {
    id: number
    name: string
    address: string
    photo: string
    HospitalStatus: $Enums.HospitalStatus
    phone: string
    mail: string
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalGroupByOutputType[P]>
        }
      >
    >


  export type HospitalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    photo?: boolean
    HospitalStatus?: boolean
    phone?: boolean
    mail?: boolean
    Users?: boolean | Hospital$UsersArgs<ExtArgs>
    Admins?: boolean | Hospital$AdminsArgs<ExtArgs>
    Patients?: boolean | Hospital$PatientsArgs<ExtArgs>
    Consultation?: boolean | Hospital$ConsultationArgs<ExtArgs>
    Treatments?: boolean | Hospital$TreatmentsArgs<ExtArgs>
    Medicians?: boolean | Hospital$MediciansArgs<ExtArgs>
    Injections?: boolean | Hospital$InjectionsArgs<ExtArgs>
    TestingAndScannings?: boolean | Hospital$TestingAndScanningsArgs<ExtArgs>
    TestingAndScanningHs?: boolean | Hospital$TestingAndScanningHsArgs<ExtArgs>
    RoomsAvailables?: boolean | Hospital$RoomsAvailablesArgs<ExtArgs>
    Payments?: boolean | Hospital$PaymentsArgs<ExtArgs>
    MedicineAndInjections?: boolean | Hospital$MedicineAndInjectionsArgs<ExtArgs>
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospital"]>



  export type HospitalSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    photo?: boolean
    HospitalStatus?: boolean
    phone?: boolean
    mail?: boolean
  }

  export type HospitalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "photo" | "HospitalStatus" | "phone" | "mail", ExtArgs["result"]["hospital"]>
  export type HospitalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Hospital$UsersArgs<ExtArgs>
    Admins?: boolean | Hospital$AdminsArgs<ExtArgs>
    Patients?: boolean | Hospital$PatientsArgs<ExtArgs>
    Consultation?: boolean | Hospital$ConsultationArgs<ExtArgs>
    Treatments?: boolean | Hospital$TreatmentsArgs<ExtArgs>
    Medicians?: boolean | Hospital$MediciansArgs<ExtArgs>
    Injections?: boolean | Hospital$InjectionsArgs<ExtArgs>
    TestingAndScannings?: boolean | Hospital$TestingAndScanningsArgs<ExtArgs>
    TestingAndScanningHs?: boolean | Hospital$TestingAndScanningHsArgs<ExtArgs>
    RoomsAvailables?: boolean | Hospital$RoomsAvailablesArgs<ExtArgs>
    Payments?: boolean | Hospital$PaymentsArgs<ExtArgs>
    MedicineAndInjections?: boolean | Hospital$MedicineAndInjectionsArgs<ExtArgs>
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $HospitalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospital"
    objects: {
      Users: Prisma.$UserPayload<ExtArgs>[]
      Admins: Prisma.$AdminPayload<ExtArgs>[]
      Patients: Prisma.$PatientPayload<ExtArgs>[]
      Consultation: Prisma.$ConsultationPayload<ExtArgs>[]
      Treatments: Prisma.$TreatmentPayload<ExtArgs>[]
      Medicians: Prisma.$MedicianPayload<ExtArgs>[]
      Injections: Prisma.$InjectionPayload<ExtArgs>[]
      TestingAndScannings: Prisma.$TestingAndScanningPPayload<ExtArgs>[]
      TestingAndScanningHs: Prisma.$TestingAndScanningHPayload<ExtArgs>[]
      RoomsAvailables: Prisma.$RoomsAvailablePayload<ExtArgs>[]
      Payments: Prisma.$PaymentPayload<ExtArgs>[]
      MedicineAndInjections: Prisma.$MedicineAndInjectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      photo: string
      HospitalStatus: $Enums.HospitalStatus
      phone: string
      mail: string
    }, ExtArgs["result"]["hospital"]>
    composites: {}
  }

  type HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = $Result.GetResult<Prisma.$HospitalPayload, S>

  type HospitalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HospitalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HospitalCountAggregateInputType | true
    }

  export interface HospitalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospital'], meta: { name: 'Hospital' } }
    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalFindUniqueArgs>(args: SelectSubset<T, HospitalFindUniqueArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hospital that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalFindFirstArgs>(args?: SelectSubset<T, HospitalFindFirstArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     * 
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalFindManyArgs>(args?: SelectSubset<T, HospitalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     * 
     */
    create<T extends HospitalCreateArgs>(args: SelectSubset<T, HospitalCreateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hospitals.
     * @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalCreateManyArgs>(args?: SelectSubset<T, HospitalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     * 
     */
    delete<T extends HospitalDeleteArgs>(args: SelectSubset<T, HospitalDeleteArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalUpdateArgs>(args: SelectSubset<T, HospitalUpdateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalDeleteManyArgs>(args?: SelectSubset<T, HospitalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalUpdateManyArgs>(args: SelectSubset<T, HospitalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
     */
    upsert<T extends HospitalUpsertArgs>(args: SelectSubset<T, HospitalUpsertArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(
      args?: Subset<T, HospitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): Prisma.PrismaPromise<GetHospitalAggregateType<T>>

    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalGroupByArgs['orderBy'] }
        : { orderBy?: HospitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospital model
   */
  readonly fields: HospitalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Hospital$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Admins<T extends Hospital$AdminsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$AdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Patients<T extends Hospital$PatientsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$PatientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Consultation<T extends Hospital$ConsultationArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$ConsultationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Treatments<T extends Hospital$TreatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$TreatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Medicians<T extends Hospital$MediciansArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$MediciansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Injections<T extends Hospital$InjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$InjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TestingAndScannings<T extends Hospital$TestingAndScanningsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$TestingAndScanningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TestingAndScanningHs<T extends Hospital$TestingAndScanningHsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$TestingAndScanningHsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RoomsAvailables<T extends Hospital$RoomsAvailablesArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$RoomsAvailablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payments<T extends Hospital$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MedicineAndInjections<T extends Hospital$MedicineAndInjectionsArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$MedicineAndInjectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospital model
   */
  interface HospitalFieldRefs {
    readonly id: FieldRef<"Hospital", 'Int'>
    readonly name: FieldRef<"Hospital", 'String'>
    readonly address: FieldRef<"Hospital", 'String'>
    readonly photo: FieldRef<"Hospital", 'String'>
    readonly HospitalStatus: FieldRef<"Hospital", 'HospitalStatus'>
    readonly phone: FieldRef<"Hospital", 'String'>
    readonly mail: FieldRef<"Hospital", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Hospital findUnique
   */
  export type HospitalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findUniqueOrThrow
   */
  export type HospitalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findFirst
   */
  export type HospitalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findFirstOrThrow
   */
  export type HospitalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findMany
   */
  export type HospitalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital create
   */
  export type HospitalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
  }

  /**
   * Hospital createMany
   */
  export type HospitalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital update
   */
  export type HospitalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital updateMany
   */
  export type HospitalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number
  }

  /**
   * Hospital upsert
   */
  export type HospitalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
  }

  /**
   * Hospital delete
   */
  export type HospitalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital deleteMany
   */
  export type HospitalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to delete.
     */
    limit?: number
  }

  /**
   * Hospital.Users
   */
  export type Hospital$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Hospital.Admins
   */
  export type Hospital$AdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Hospital.Patients
   */
  export type Hospital$PatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Hospital.Consultation
   */
  export type Hospital$ConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Hospital.Treatments
   */
  export type Hospital$TreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Hospital.Medicians
   */
  export type Hospital$MediciansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    where?: MedicianWhereInput
    orderBy?: MedicianOrderByWithRelationInput | MedicianOrderByWithRelationInput[]
    cursor?: MedicianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicianScalarFieldEnum | MedicianScalarFieldEnum[]
  }

  /**
   * Hospital.Injections
   */
  export type Hospital$InjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    where?: InjectionWhereInput
    orderBy?: InjectionOrderByWithRelationInput | InjectionOrderByWithRelationInput[]
    cursor?: InjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InjectionScalarFieldEnum | InjectionScalarFieldEnum[]
  }

  /**
   * Hospital.TestingAndScannings
   */
  export type Hospital$TestingAndScanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    where?: TestingAndScanningPWhereInput
    orderBy?: TestingAndScanningPOrderByWithRelationInput | TestingAndScanningPOrderByWithRelationInput[]
    cursor?: TestingAndScanningPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestingAndScanningPScalarFieldEnum | TestingAndScanningPScalarFieldEnum[]
  }

  /**
   * Hospital.TestingAndScanningHs
   */
  export type Hospital$TestingAndScanningHsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    where?: TestingAndScanningHWhereInput
    orderBy?: TestingAndScanningHOrderByWithRelationInput | TestingAndScanningHOrderByWithRelationInput[]
    cursor?: TestingAndScanningHWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestingAndScanningHScalarFieldEnum | TestingAndScanningHScalarFieldEnum[]
  }

  /**
   * Hospital.RoomsAvailables
   */
  export type Hospital$RoomsAvailablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    where?: RoomsAvailableWhereInput
    orderBy?: RoomsAvailableOrderByWithRelationInput | RoomsAvailableOrderByWithRelationInput[]
    cursor?: RoomsAvailableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomsAvailableScalarFieldEnum | RoomsAvailableScalarFieldEnum[]
  }

  /**
   * Hospital.Payments
   */
  export type Hospital$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Hospital.MedicineAndInjections
   */
  export type Hospital$MedicineAndInjectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    where?: MedicineAndInjectionWhereInput
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    cursor?: MedicineAndInjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * Hospital without action
   */
  export type HospitalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    password: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    password: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    hospital_Id: number
    user_Id: number
    password: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    hospital_Id: number
    user_Id: number
    password: string
    role: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    user_Id?: boolean
    password?: boolean
    role?: boolean
    AdminStrator?: boolean | User$AdminStratorArgs<ExtArgs>
    Admin?: boolean | User$AdminArgs<ExtArgs>
    Patient?: boolean | User$PatientArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    user_Id?: boolean
    password?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "user_Id" | "password" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminStrator?: boolean | User$AdminStratorArgs<ExtArgs>
    Admin?: boolean | User$AdminArgs<ExtArgs>
    Patient?: boolean | User$PatientArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      AdminStrator: Prisma.$AdminStratorPayload<ExtArgs>[]
      Admin: Prisma.$AdminPayload<ExtArgs>[]
      Patient: Prisma.$PatientPayload<ExtArgs>[]
      Hospital: Prisma.$HospitalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      user_Id: number
      password: string
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AdminStrator<T extends User$AdminStratorArgs<ExtArgs> = {}>(args?: Subset<T, User$AdminStratorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Admin<T extends User$AdminArgs<ExtArgs> = {}>(args?: Subset<T, User$AdminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Patient<T extends User$PatientArgs<ExtArgs> = {}>(args?: Subset<T, User$PatientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly hospital_Id: FieldRef<"User", 'Int'>
    readonly user_Id: FieldRef<"User", 'Int'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.AdminStrator
   */
  export type User$AdminStratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    where?: AdminStratorWhereInput
    orderBy?: AdminStratorOrderByWithRelationInput | AdminStratorOrderByWithRelationInput[]
    cursor?: AdminStratorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminStratorScalarFieldEnum | AdminStratorScalarFieldEnum[]
  }

  /**
   * User.Admin
   */
  export type User$AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * User.Patient
   */
  export type User$PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    destination: string | null
    phone: string | null
    email: string | null
    address: string | null
    photo: string | null
    name: string | null
    status: string | null
    gender: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    destination: string | null
    phone: string | null
    email: string | null
    address: string | null
    photo: string | null
    name: string | null
    status: string | null
    gender: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    hospital_Id: number
    user_Id: number
    destination: number
    phone: number
    email: number
    address: number
    photo: number
    name: number
    status: number
    gender: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    destination?: true
    phone?: true
    email?: true
    address?: true
    photo?: true
    name?: true
    status?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    destination?: true
    phone?: true
    email?: true
    address?: true
    photo?: true
    name?: true
    status?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    destination?: true
    phone?: true
    email?: true
    address?: true
    photo?: true
    name?: true
    status?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    hospital_Id: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    user_Id?: boolean
    destination?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    photo?: boolean
    name?: boolean
    status?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Consultation?: boolean | Admin$ConsultationArgs<ExtArgs>
    Doctor?: boolean | Admin$DoctorArgs<ExtArgs>
    Staff?: boolean | Admin$StaffArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    user_Id?: boolean
    destination?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    photo?: boolean
    name?: boolean
    status?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "user_Id" | "destination" | "phone" | "email" | "address" | "photo" | "name" | "status" | "gender" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Consultation?: boolean | Admin$ConsultationArgs<ExtArgs>
    Doctor?: boolean | Admin$DoctorArgs<ExtArgs>
    Staff?: boolean | Admin$StaffArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      Consultation: Prisma.$ConsultationPayload<ExtArgs>[]
      Doctor: Prisma.$TreatmentPayload<ExtArgs>[]
      Staff: Prisma.$TreatmentPayload<ExtArgs>[]
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      user_Id: number
      destination: string
      phone: string
      email: string
      address: string
      photo: string
      name: string
      status: string
      gender: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Consultation<T extends Admin$ConsultationArgs<ExtArgs> = {}>(args?: Subset<T, Admin$ConsultationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Doctor<T extends Admin$DoctorArgs<ExtArgs> = {}>(args?: Subset<T, Admin$DoctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Staff<T extends Admin$StaffArgs<ExtArgs> = {}>(args?: Subset<T, Admin$StaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly hospital_Id: FieldRef<"Admin", 'Int'>
    readonly user_Id: FieldRef<"Admin", 'Int'>
    readonly destination: FieldRef<"Admin", 'String'>
    readonly phone: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly address: FieldRef<"Admin", 'String'>
    readonly photo: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly status: FieldRef<"Admin", 'String'>
    readonly gender: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.Consultation
   */
  export type Admin$ConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Admin.Doctor
   */
  export type Admin$DoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Admin.Staff
   */
  export type Admin$StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model AdminStrator
   */

  export type AggregateAdminStrator = {
    _count: AdminStratorCountAggregateOutputType | null
    _avg: AdminStratorAvgAggregateOutputType | null
    _sum: AdminStratorSumAggregateOutputType | null
    _min: AdminStratorMinAggregateOutputType | null
    _max: AdminStratorMaxAggregateOutputType | null
  }

  export type AdminStratorAvgAggregateOutputType = {
    id: number | null
    user_Id: number | null
  }

  export type AdminStratorSumAggregateOutputType = {
    id: number | null
    user_Id: number | null
  }

  export type AdminStratorMinAggregateOutputType = {
    id: number | null
    user_Id: number | null
    name: string | null
    status: string | null
    destination: string | null
    phone: string | null
    email: string | null
    photo: string | null
    address: string | null
    gender: string | null
  }

  export type AdminStratorMaxAggregateOutputType = {
    id: number | null
    user_Id: number | null
    name: string | null
    status: string | null
    destination: string | null
    phone: string | null
    email: string | null
    photo: string | null
    address: string | null
    gender: string | null
  }

  export type AdminStratorCountAggregateOutputType = {
    id: number
    user_Id: number
    name: number
    status: number
    destination: number
    phone: number
    email: number
    photo: number
    address: number
    gender: number
    _all: number
  }


  export type AdminStratorAvgAggregateInputType = {
    id?: true
    user_Id?: true
  }

  export type AdminStratorSumAggregateInputType = {
    id?: true
    user_Id?: true
  }

  export type AdminStratorMinAggregateInputType = {
    id?: true
    user_Id?: true
    name?: true
    status?: true
    destination?: true
    phone?: true
    email?: true
    photo?: true
    address?: true
    gender?: true
  }

  export type AdminStratorMaxAggregateInputType = {
    id?: true
    user_Id?: true
    name?: true
    status?: true
    destination?: true
    phone?: true
    email?: true
    photo?: true
    address?: true
    gender?: true
  }

  export type AdminStratorCountAggregateInputType = {
    id?: true
    user_Id?: true
    name?: true
    status?: true
    destination?: true
    phone?: true
    email?: true
    photo?: true
    address?: true
    gender?: true
    _all?: true
  }

  export type AdminStratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminStrator to aggregate.
     */
    where?: AdminStratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrators to fetch.
     */
    orderBy?: AdminStratorOrderByWithRelationInput | AdminStratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminStratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminStrators
    **/
    _count?: true | AdminStratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminStratorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminStratorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminStratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminStratorMaxAggregateInputType
  }

  export type GetAdminStratorAggregateType<T extends AdminStratorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminStrator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminStrator[P]>
      : GetScalarType<T[P], AggregateAdminStrator[P]>
  }




  export type AdminStratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminStratorWhereInput
    orderBy?: AdminStratorOrderByWithAggregationInput | AdminStratorOrderByWithAggregationInput[]
    by: AdminStratorScalarFieldEnum[] | AdminStratorScalarFieldEnum
    having?: AdminStratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminStratorCountAggregateInputType | true
    _avg?: AdminStratorAvgAggregateInputType
    _sum?: AdminStratorSumAggregateInputType
    _min?: AdminStratorMinAggregateInputType
    _max?: AdminStratorMaxAggregateInputType
  }

  export type AdminStratorGroupByOutputType = {
    id: number
    user_Id: number
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
    _count: AdminStratorCountAggregateOutputType | null
    _avg: AdminStratorAvgAggregateOutputType | null
    _sum: AdminStratorSumAggregateOutputType | null
    _min: AdminStratorMinAggregateOutputType | null
    _max: AdminStratorMaxAggregateOutputType | null
  }

  type GetAdminStratorGroupByPayload<T extends AdminStratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminStratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminStratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminStratorGroupByOutputType[P]>
            : GetScalarType<T[P], AdminStratorGroupByOutputType[P]>
        }
      >
    >


  export type AdminStratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_Id?: boolean
    name?: boolean
    status?: boolean
    destination?: boolean
    phone?: boolean
    email?: boolean
    photo?: boolean
    address?: boolean
    gender?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminStrator"]>



  export type AdminStratorSelectScalar = {
    id?: boolean
    user_Id?: boolean
    name?: boolean
    status?: boolean
    destination?: boolean
    phone?: boolean
    email?: boolean
    photo?: boolean
    address?: boolean
    gender?: boolean
  }

  export type AdminStratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_Id" | "name" | "status" | "destination" | "phone" | "email" | "photo" | "address" | "gender", ExtArgs["result"]["adminStrator"]>
  export type AdminStratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminStratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminStrator"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_Id: number
      name: string
      status: string
      destination: string
      phone: string
      email: string
      photo: string
      address: string
      gender: string
    }, ExtArgs["result"]["adminStrator"]>
    composites: {}
  }

  type AdminStratorGetPayload<S extends boolean | null | undefined | AdminStratorDefaultArgs> = $Result.GetResult<Prisma.$AdminStratorPayload, S>

  type AdminStratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminStratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminStratorCountAggregateInputType | true
    }

  export interface AdminStratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminStrator'], meta: { name: 'AdminStrator' } }
    /**
     * Find zero or one AdminStrator that matches the filter.
     * @param {AdminStratorFindUniqueArgs} args - Arguments to find a AdminStrator
     * @example
     * // Get one AdminStrator
     * const adminStrator = await prisma.adminStrator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminStratorFindUniqueArgs>(args: SelectSubset<T, AdminStratorFindUniqueArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminStrator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminStratorFindUniqueOrThrowArgs} args - Arguments to find a AdminStrator
     * @example
     * // Get one AdminStrator
     * const adminStrator = await prisma.adminStrator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminStratorFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminStratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminStrator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorFindFirstArgs} args - Arguments to find a AdminStrator
     * @example
     * // Get one AdminStrator
     * const adminStrator = await prisma.adminStrator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminStratorFindFirstArgs>(args?: SelectSubset<T, AdminStratorFindFirstArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminStrator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorFindFirstOrThrowArgs} args - Arguments to find a AdminStrator
     * @example
     * // Get one AdminStrator
     * const adminStrator = await prisma.adminStrator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminStratorFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminStratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminStrators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminStrators
     * const adminStrators = await prisma.adminStrator.findMany()
     * 
     * // Get first 10 AdminStrators
     * const adminStrators = await prisma.adminStrator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminStratorWithIdOnly = await prisma.adminStrator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminStratorFindManyArgs>(args?: SelectSubset<T, AdminStratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminStrator.
     * @param {AdminStratorCreateArgs} args - Arguments to create a AdminStrator.
     * @example
     * // Create one AdminStrator
     * const AdminStrator = await prisma.adminStrator.create({
     *   data: {
     *     // ... data to create a AdminStrator
     *   }
     * })
     * 
     */
    create<T extends AdminStratorCreateArgs>(args: SelectSubset<T, AdminStratorCreateArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminStrators.
     * @param {AdminStratorCreateManyArgs} args - Arguments to create many AdminStrators.
     * @example
     * // Create many AdminStrators
     * const adminStrator = await prisma.adminStrator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminStratorCreateManyArgs>(args?: SelectSubset<T, AdminStratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminStrator.
     * @param {AdminStratorDeleteArgs} args - Arguments to delete one AdminStrator.
     * @example
     * // Delete one AdminStrator
     * const AdminStrator = await prisma.adminStrator.delete({
     *   where: {
     *     // ... filter to delete one AdminStrator
     *   }
     * })
     * 
     */
    delete<T extends AdminStratorDeleteArgs>(args: SelectSubset<T, AdminStratorDeleteArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminStrator.
     * @param {AdminStratorUpdateArgs} args - Arguments to update one AdminStrator.
     * @example
     * // Update one AdminStrator
     * const adminStrator = await prisma.adminStrator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminStratorUpdateArgs>(args: SelectSubset<T, AdminStratorUpdateArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminStrators.
     * @param {AdminStratorDeleteManyArgs} args - Arguments to filter AdminStrators to delete.
     * @example
     * // Delete a few AdminStrators
     * const { count } = await prisma.adminStrator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminStratorDeleteManyArgs>(args?: SelectSubset<T, AdminStratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminStrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminStrators
     * const adminStrator = await prisma.adminStrator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminStratorUpdateManyArgs>(args: SelectSubset<T, AdminStratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminStrator.
     * @param {AdminStratorUpsertArgs} args - Arguments to update or create a AdminStrator.
     * @example
     * // Update or create a AdminStrator
     * const adminStrator = await prisma.adminStrator.upsert({
     *   create: {
     *     // ... data to create a AdminStrator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminStrator we want to update
     *   }
     * })
     */
    upsert<T extends AdminStratorUpsertArgs>(args: SelectSubset<T, AdminStratorUpsertArgs<ExtArgs>>): Prisma__AdminStratorClient<$Result.GetResult<Prisma.$AdminStratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminStrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorCountArgs} args - Arguments to filter AdminStrators to count.
     * @example
     * // Count the number of AdminStrators
     * const count = await prisma.adminStrator.count({
     *   where: {
     *     // ... the filter for the AdminStrators we want to count
     *   }
     * })
    **/
    count<T extends AdminStratorCountArgs>(
      args?: Subset<T, AdminStratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminStratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminStrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminStratorAggregateArgs>(args: Subset<T, AdminStratorAggregateArgs>): Prisma.PrismaPromise<GetAdminStratorAggregateType<T>>

    /**
     * Group by AdminStrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminStratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminStratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminStratorGroupByArgs['orderBy'] }
        : { orderBy?: AdminStratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminStratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminStratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminStrator model
   */
  readonly fields: AdminStratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminStrator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminStratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminStrator model
   */
  interface AdminStratorFieldRefs {
    readonly id: FieldRef<"AdminStrator", 'Int'>
    readonly user_Id: FieldRef<"AdminStrator", 'Int'>
    readonly name: FieldRef<"AdminStrator", 'String'>
    readonly status: FieldRef<"AdminStrator", 'String'>
    readonly destination: FieldRef<"AdminStrator", 'String'>
    readonly phone: FieldRef<"AdminStrator", 'String'>
    readonly email: FieldRef<"AdminStrator", 'String'>
    readonly photo: FieldRef<"AdminStrator", 'String'>
    readonly address: FieldRef<"AdminStrator", 'String'>
    readonly gender: FieldRef<"AdminStrator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminStrator findUnique
   */
  export type AdminStratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrator to fetch.
     */
    where: AdminStratorWhereUniqueInput
  }

  /**
   * AdminStrator findUniqueOrThrow
   */
  export type AdminStratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrator to fetch.
     */
    where: AdminStratorWhereUniqueInput
  }

  /**
   * AdminStrator findFirst
   */
  export type AdminStratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrator to fetch.
     */
    where?: AdminStratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrators to fetch.
     */
    orderBy?: AdminStratorOrderByWithRelationInput | AdminStratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminStrators.
     */
    cursor?: AdminStratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminStrators.
     */
    distinct?: AdminStratorScalarFieldEnum | AdminStratorScalarFieldEnum[]
  }

  /**
   * AdminStrator findFirstOrThrow
   */
  export type AdminStratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrator to fetch.
     */
    where?: AdminStratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrators to fetch.
     */
    orderBy?: AdminStratorOrderByWithRelationInput | AdminStratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminStrators.
     */
    cursor?: AdminStratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminStrators.
     */
    distinct?: AdminStratorScalarFieldEnum | AdminStratorScalarFieldEnum[]
  }

  /**
   * AdminStrator findMany
   */
  export type AdminStratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * Filter, which AdminStrators to fetch.
     */
    where?: AdminStratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminStrators to fetch.
     */
    orderBy?: AdminStratorOrderByWithRelationInput | AdminStratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminStrators.
     */
    cursor?: AdminStratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminStrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminStrators.
     */
    skip?: number
    distinct?: AdminStratorScalarFieldEnum | AdminStratorScalarFieldEnum[]
  }

  /**
   * AdminStrator create
   */
  export type AdminStratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminStrator.
     */
    data: XOR<AdminStratorCreateInput, AdminStratorUncheckedCreateInput>
  }

  /**
   * AdminStrator createMany
   */
  export type AdminStratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminStrators.
     */
    data: AdminStratorCreateManyInput | AdminStratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminStrator update
   */
  export type AdminStratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminStrator.
     */
    data: XOR<AdminStratorUpdateInput, AdminStratorUncheckedUpdateInput>
    /**
     * Choose, which AdminStrator to update.
     */
    where: AdminStratorWhereUniqueInput
  }

  /**
   * AdminStrator updateMany
   */
  export type AdminStratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminStrators.
     */
    data: XOR<AdminStratorUpdateManyMutationInput, AdminStratorUncheckedUpdateManyInput>
    /**
     * Filter which AdminStrators to update
     */
    where?: AdminStratorWhereInput
    /**
     * Limit how many AdminStrators to update.
     */
    limit?: number
  }

  /**
   * AdminStrator upsert
   */
  export type AdminStratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminStrator to update in case it exists.
     */
    where: AdminStratorWhereUniqueInput
    /**
     * In case the AdminStrator found by the `where` argument doesn't exist, create a new AdminStrator with this data.
     */
    create: XOR<AdminStratorCreateInput, AdminStratorUncheckedCreateInput>
    /**
     * In case the AdminStrator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminStratorUpdateInput, AdminStratorUncheckedUpdateInput>
  }

  /**
   * AdminStrator delete
   */
  export type AdminStratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
    /**
     * Filter which AdminStrator to delete.
     */
    where: AdminStratorWhereUniqueInput
  }

  /**
   * AdminStrator deleteMany
   */
  export type AdminStratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminStrators to delete
     */
    where?: AdminStratorWhereInput
    /**
     * Limit how many AdminStrators to delete.
     */
    limit?: number
  }

  /**
   * AdminStrator without action
   */
  export type AdminStratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminStrator
     */
    select?: AdminStratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminStrator
     */
    omit?: AdminStratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminStratorInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    height: number | null
    weight: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    height: number | null
    weight: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    name: string | null
    photo: string | null
    status: string | null
    dob: Date | null
    gender: string | null
    bldGrp: string | null
    currentProblem: string | null
    medicalHistory: string | null
    height: number | null
    weight: number | null
    bp: string | null
    sugar: string | null
    tempCreatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    user_Id: number | null
    name: string | null
    photo: string | null
    status: string | null
    dob: Date | null
    gender: string | null
    bldGrp: string | null
    currentProblem: string | null
    medicalHistory: string | null
    height: number | null
    weight: number | null
    bp: string | null
    sugar: string | null
    tempCreatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    hospital_Id: number
    user_Id: number
    name: number
    phone: number
    email: number
    photo: number
    status: number
    address: number
    dob: number
    gender: number
    bldGrp: number
    currentProblem: number
    medicalHistory: number
    height: number
    weight: number
    bp: number
    sugar: number
    custom: number
    tempCreatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    height?: true
    weight?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    height?: true
    weight?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    name?: true
    photo?: true
    status?: true
    dob?: true
    gender?: true
    bldGrp?: true
    currentProblem?: true
    medicalHistory?: true
    height?: true
    weight?: true
    bp?: true
    sugar?: true
    tempCreatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    name?: true
    photo?: true
    status?: true
    dob?: true
    gender?: true
    bldGrp?: true
    currentProblem?: true
    medicalHistory?: true
    height?: true
    weight?: true
    bp?: true
    sugar?: true
    tempCreatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    user_Id?: true
    name?: true
    phone?: true
    email?: true
    photo?: true
    status?: true
    address?: true
    dob?: true
    gender?: true
    bldGrp?: true
    currentProblem?: true
    medicalHistory?: true
    height?: true
    weight?: true
    bp?: true
    sugar?: true
    custom?: true
    tempCreatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonValue
    email: JsonValue
    photo: string
    status: string
    address: JsonValue | null
    dob: Date
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonValue
    tempCreatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    user_Id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    photo?: boolean
    status?: boolean
    address?: boolean
    dob?: boolean
    gender?: boolean
    bldGrp?: boolean
    currentProblem?: boolean
    medicalHistory?: boolean
    height?: boolean
    weight?: boolean
    bp?: boolean
    sugar?: boolean
    custom?: boolean
    tempCreatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Consultation?: boolean | Patient$ConsultationArgs<ExtArgs>
    Treatment?: boolean | Patient$TreatmentArgs<ExtArgs>
    MedicineAndInjection?: boolean | Patient$MedicineAndInjectionArgs<ExtArgs>
    TestingAndScanning?: boolean | Patient$TestingAndScanningArgs<ExtArgs>
    Payments?: boolean | Patient$PaymentsArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>



  export type PatientSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    user_Id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    photo?: boolean
    status?: boolean
    address?: boolean
    dob?: boolean
    gender?: boolean
    bldGrp?: boolean
    currentProblem?: boolean
    medicalHistory?: boolean
    height?: boolean
    weight?: boolean
    bp?: boolean
    sugar?: boolean
    custom?: boolean
    tempCreatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "user_Id" | "name" | "phone" | "email" | "photo" | "status" | "address" | "dob" | "gender" | "bldGrp" | "currentProblem" | "medicalHistory" | "height" | "weight" | "bp" | "sugar" | "custom" | "tempCreatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Consultation?: boolean | Patient$ConsultationArgs<ExtArgs>
    Treatment?: boolean | Patient$TreatmentArgs<ExtArgs>
    MedicineAndInjection?: boolean | Patient$MedicineAndInjectionArgs<ExtArgs>
    TestingAndScanning?: boolean | Patient$TestingAndScanningArgs<ExtArgs>
    Payments?: boolean | Patient$PaymentsArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      Consultation: Prisma.$ConsultationPayload<ExtArgs>[]
      Treatment: Prisma.$TreatmentPayload<ExtArgs>[]
      MedicineAndInjection: Prisma.$MedicineAndInjectionPayload<ExtArgs>[]
      TestingAndScanning: Prisma.$TestingAndScanningPPayload<ExtArgs>[]
      Payments: Prisma.$PaymentPayload<ExtArgs>[]
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      user_Id: number
      name: string
      phone: Prisma.JsonValue
      email: Prisma.JsonValue
      photo: string
      status: string
      address: Prisma.JsonValue | null
      dob: Date
      gender: string
      bldGrp: string
      currentProblem: string
      medicalHistory: string
      height: number
      weight: number
      bp: string
      sugar: string
      custom: Prisma.JsonValue
      tempCreatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Consultation<T extends Patient$ConsultationArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ConsultationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Treatment<T extends Patient$TreatmentArgs<ExtArgs> = {}>(args?: Subset<T, Patient$TreatmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MedicineAndInjection<T extends Patient$MedicineAndInjectionArgs<ExtArgs> = {}>(args?: Subset<T, Patient$MedicineAndInjectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TestingAndScanning<T extends Patient$TestingAndScanningArgs<ExtArgs> = {}>(args?: Subset<T, Patient$TestingAndScanningArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payments<T extends Patient$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly hospital_Id: FieldRef<"Patient", 'Int'>
    readonly user_Id: FieldRef<"Patient", 'Int'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'Json'>
    readonly email: FieldRef<"Patient", 'Json'>
    readonly photo: FieldRef<"Patient", 'String'>
    readonly status: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'Json'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly bldGrp: FieldRef<"Patient", 'String'>
    readonly currentProblem: FieldRef<"Patient", 'String'>
    readonly medicalHistory: FieldRef<"Patient", 'String'>
    readonly height: FieldRef<"Patient", 'Float'>
    readonly weight: FieldRef<"Patient", 'Float'>
    readonly bp: FieldRef<"Patient", 'String'>
    readonly sugar: FieldRef<"Patient", 'String'>
    readonly custom: FieldRef<"Patient", 'Json'>
    readonly tempCreatedAt: FieldRef<"Patient", 'DateTime'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.Consultation
   */
  export type Patient$ConsultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Patient.Treatment
   */
  export type Patient$TreatmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    cursor?: TreatmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Patient.MedicineAndInjection
   */
  export type Patient$MedicineAndInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    where?: MedicineAndInjectionWhereInput
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    cursor?: MedicineAndInjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * Patient.TestingAndScanning
   */
  export type Patient$TestingAndScanningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    where?: TestingAndScanningPWhereInput
    orderBy?: TestingAndScanningPOrderByWithRelationInput | TestingAndScanningPOrderByWithRelationInput[]
    cursor?: TestingAndScanningPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestingAndScanningPScalarFieldEnum | TestingAndScanningPScalarFieldEnum[]
  }

  /**
   * Patient.Payments
   */
  export type Patient$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Consultation
   */

  export type AggregateConsultation = {
    _count: ConsultationCountAggregateOutputType | null
    _avg: ConsultationAvgAggregateOutputType | null
    _sum: ConsultationSumAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  export type ConsultationAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    doctor_Id: number | null
    temperature: number | null
  }

  export type ConsultationSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    doctor_Id: number | null
    temperature: number | null
  }

  export type ConsultationMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    doctor_Id: number | null
    date: Date | null
    purpose: string | null
    temperature: number | null
    symptoms: string | null
    diagnosis: string | null
    treatment: boolean | null
    medicineInjection: boolean | null
    scanningTesting: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentStatus: boolean | null
  }

  export type ConsultationMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    doctor_Id: number | null
    date: Date | null
    purpose: string | null
    temperature: number | null
    symptoms: string | null
    diagnosis: string | null
    treatment: boolean | null
    medicineInjection: boolean | null
    scanningTesting: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentStatus: boolean | null
  }

  export type ConsultationCountAggregateOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: number
    date: number
    purpose: number
    temperature: number
    symptoms: number
    notes: number
    diagnosis: number
    treatment: number
    medicineInjection: number
    scanningTesting: number
    status: number
    access: number
    createdAt: number
    updatedAt: number
    paymentStatus: number
    _all: number
  }


  export type ConsultationAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    temperature?: true
  }

  export type ConsultationSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    temperature?: true
  }

  export type ConsultationMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    date?: true
    purpose?: true
    temperature?: true
    symptoms?: true
    diagnosis?: true
    treatment?: true
    medicineInjection?: true
    scanningTesting?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
  }

  export type ConsultationMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    date?: true
    purpose?: true
    temperature?: true
    symptoms?: true
    diagnosis?: true
    treatment?: true
    medicineInjection?: true
    scanningTesting?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
  }

  export type ConsultationCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    date?: true
    purpose?: true
    temperature?: true
    symptoms?: true
    notes?: true
    diagnosis?: true
    treatment?: true
    medicineInjection?: true
    scanningTesting?: true
    status?: true
    access?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
    _all?: true
  }

  export type ConsultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultation to aggregate.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultations
    **/
    _count?: true | ConsultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationMaxAggregateInputType
  }

  export type GetConsultationAggregateType<T extends ConsultationAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultation[P]>
      : GetScalarType<T[P], AggregateConsultation[P]>
  }




  export type ConsultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithAggregationInput | ConsultationOrderByWithAggregationInput[]
    by: ConsultationScalarFieldEnum[] | ConsultationScalarFieldEnum
    having?: ConsultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationCountAggregateInputType | true
    _avg?: ConsultationAvgAggregateInputType
    _sum?: ConsultationSumAggregateInputType
    _min?: ConsultationMinAggregateInputType
    _max?: ConsultationMaxAggregateInputType
  }

  export type ConsultationGroupByOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: number
    date: Date
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonValue
    createdAt: Date
    updatedAt: Date
    paymentStatus: boolean
    _count: ConsultationCountAggregateOutputType | null
    _avg: ConsultationAvgAggregateOutputType | null
    _sum: ConsultationSumAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  type GetConsultationGroupByPayload<T extends ConsultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    date?: boolean
    purpose?: boolean
    temperature?: boolean
    symptoms?: boolean
    notes?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medicineInjection?: boolean
    scanningTesting?: boolean
    status?: boolean
    access?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentStatus?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
    Doctor?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>



  export type ConsultationSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    date?: boolean
    purpose?: boolean
    temperature?: boolean
    symptoms?: boolean
    notes?: boolean
    diagnosis?: boolean
    treatment?: boolean
    medicineInjection?: boolean
    scanningTesting?: boolean
    status?: boolean
    access?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentStatus?: boolean
  }

  export type ConsultationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "patient_Id" | "doctor_Id" | "date" | "purpose" | "temperature" | "symptoms" | "notes" | "diagnosis" | "treatment" | "medicineInjection" | "scanningTesting" | "status" | "access" | "createdAt" | "updatedAt" | "paymentStatus", ExtArgs["result"]["consultation"]>
  export type ConsultationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
    Doctor?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $ConsultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultation"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      Patient: Prisma.$PatientPayload<ExtArgs>
      Doctor: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      patient_Id: number
      doctor_Id: number
      date: Date
      purpose: string
      temperature: number
      symptoms: string
      notes: Prisma.JsonValue
      diagnosis: string
      treatment: boolean
      medicineInjection: boolean
      scanningTesting: boolean
      status: string
      access: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      paymentStatus: boolean
    }, ExtArgs["result"]["consultation"]>
    composites: {}
  }

  type ConsultationGetPayload<S extends boolean | null | undefined | ConsultationDefaultArgs> = $Result.GetResult<Prisma.$ConsultationPayload, S>

  type ConsultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsultationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultationCountAggregateInputType | true
    }

  export interface ConsultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultation'], meta: { name: 'Consultation' } }
    /**
     * Find zero or one Consultation that matches the filter.
     * @param {ConsultationFindUniqueArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationFindUniqueArgs>(args: SelectSubset<T, ConsultationFindUniqueArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consultation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsultationFindUniqueOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationFindFirstArgs>(args?: SelectSubset<T, ConsultationFindFirstArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultation.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationWithIdOnly = await prisma.consultation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationFindManyArgs>(args?: SelectSubset<T, ConsultationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consultation.
     * @param {ConsultationCreateArgs} args - Arguments to create a Consultation.
     * @example
     * // Create one Consultation
     * const Consultation = await prisma.consultation.create({
     *   data: {
     *     // ... data to create a Consultation
     *   }
     * })
     * 
     */
    create<T extends ConsultationCreateArgs>(args: SelectSubset<T, ConsultationCreateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consultations.
     * @param {ConsultationCreateManyArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultation = await prisma.consultation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationCreateManyArgs>(args?: SelectSubset<T, ConsultationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Consultation.
     * @param {ConsultationDeleteArgs} args - Arguments to delete one Consultation.
     * @example
     * // Delete one Consultation
     * const Consultation = await prisma.consultation.delete({
     *   where: {
     *     // ... filter to delete one Consultation
     *   }
     * })
     * 
     */
    delete<T extends ConsultationDeleteArgs>(args: SelectSubset<T, ConsultationDeleteArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consultation.
     * @param {ConsultationUpdateArgs} args - Arguments to update one Consultation.
     * @example
     * // Update one Consultation
     * const consultation = await prisma.consultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationUpdateArgs>(args: SelectSubset<T, ConsultationUpdateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consultations.
     * @param {ConsultationDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationDeleteManyArgs>(args?: SelectSubset<T, ConsultationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationUpdateManyArgs>(args: SelectSubset<T, ConsultationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultation.
     * @param {ConsultationUpsertArgs} args - Arguments to update or create a Consultation.
     * @example
     * // Update or create a Consultation
     * const consultation = await prisma.consultation.upsert({
     *   create: {
     *     // ... data to create a Consultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultation we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationUpsertArgs>(args: SelectSubset<T, ConsultationUpsertArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultation.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends ConsultationCountArgs>(
      args?: Subset<T, ConsultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationAggregateArgs>(args: Subset<T, ConsultationAggregateArgs>): Prisma.PrismaPromise<GetConsultationAggregateType<T>>

    /**
     * Group by Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultation model
   */
  readonly fields: ConsultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Doctor<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consultation model
   */
  interface ConsultationFieldRefs {
    readonly id: FieldRef<"Consultation", 'Int'>
    readonly hospital_Id: FieldRef<"Consultation", 'Int'>
    readonly patient_Id: FieldRef<"Consultation", 'Int'>
    readonly doctor_Id: FieldRef<"Consultation", 'Int'>
    readonly date: FieldRef<"Consultation", 'DateTime'>
    readonly purpose: FieldRef<"Consultation", 'String'>
    readonly temperature: FieldRef<"Consultation", 'Float'>
    readonly symptoms: FieldRef<"Consultation", 'String'>
    readonly notes: FieldRef<"Consultation", 'Json'>
    readonly diagnosis: FieldRef<"Consultation", 'String'>
    readonly treatment: FieldRef<"Consultation", 'Boolean'>
    readonly medicineInjection: FieldRef<"Consultation", 'Boolean'>
    readonly scanningTesting: FieldRef<"Consultation", 'Boolean'>
    readonly status: FieldRef<"Consultation", 'String'>
    readonly access: FieldRef<"Consultation", 'Json'>
    readonly createdAt: FieldRef<"Consultation", 'DateTime'>
    readonly updatedAt: FieldRef<"Consultation", 'DateTime'>
    readonly paymentStatus: FieldRef<"Consultation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Consultation findUnique
   */
  export type ConsultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findUniqueOrThrow
   */
  export type ConsultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findFirst
   */
  export type ConsultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findFirstOrThrow
   */
  export type ConsultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findMany
   */
  export type ConsultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultations to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation create
   */
  export type ConsultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultation.
     */
    data: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
  }

  /**
   * Consultation createMany
   */
  export type ConsultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consultation update
   */
  export type ConsultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultation.
     */
    data: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
    /**
     * Choose, which Consultation to update.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation updateMany
   */
  export type ConsultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to update.
     */
    limit?: number
  }

  /**
   * Consultation upsert
   */
  export type ConsultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultation to update in case it exists.
     */
    where: ConsultationWhereUniqueInput
    /**
     * In case the Consultation found by the `where` argument doesn't exist, create a new Consultation with this data.
     */
    create: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
    /**
     * In case the Consultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
  }

  /**
   * Consultation delete
   */
  export type ConsultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter which Consultation to delete.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation deleteMany
   */
  export type ConsultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultations to delete
     */
    where?: ConsultationWhereInput
    /**
     * Limit how many Consultations to delete.
     */
    limit?: number
  }

  /**
   * Consultation without action
   */
  export type ConsultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
  }


  /**
   * Model Treatment
   */

  export type AggregateTreatment = {
    _count: TreatmentCountAggregateOutputType | null
    _avg: TreatmentAvgAggregateOutputType | null
    _sum: TreatmentSumAggregateOutputType | null
    _min: TreatmentMinAggregateOutputType | null
    _max: TreatmentMaxAggregateOutputType | null
  }

  export type TreatmentAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
  }

  export type TreatmentSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
  }

  export type TreatmentMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    startDate: Date | null
    endDate: Date | null
    progress: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentStatus: boolean | null
  }

  export type TreatmentMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    startDate: Date | null
    endDate: Date | null
    progress: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentStatus: boolean | null
  }

  export type TreatmentCountAggregateOutputType = {
    id: number
    hospital_Id: number
    staff_Id: number
    patient_Id: number
    doctor_Id: number
    treatmentName: number
    startDate: number
    endDate: number
    progress: number
    status: number
    createdAt: number
    updatedAt: number
    paymentStatus: number
    _all: number
  }


  export type TreatmentAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
  }

  export type TreatmentSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
  }

  export type TreatmentMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    startDate?: true
    endDate?: true
    progress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
  }

  export type TreatmentMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    startDate?: true
    endDate?: true
    progress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
  }

  export type TreatmentCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    staff_Id?: true
    patient_Id?: true
    doctor_Id?: true
    treatmentName?: true
    startDate?: true
    endDate?: true
    progress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentStatus?: true
    _all?: true
  }

  export type TreatmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatment to aggregate.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Treatments
    **/
    _count?: true | TreatmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreatmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreatmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentMaxAggregateInputType
  }

  export type GetTreatmentAggregateType<T extends TreatmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatment[P]>
      : GetScalarType<T[P], AggregateTreatment[P]>
  }




  export type TreatmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentWhereInput
    orderBy?: TreatmentOrderByWithAggregationInput | TreatmentOrderByWithAggregationInput[]
    by: TreatmentScalarFieldEnum[] | TreatmentScalarFieldEnum
    having?: TreatmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentCountAggregateInputType | true
    _avg?: TreatmentAvgAggregateInputType
    _sum?: TreatmentSumAggregateInputType
    _min?: TreatmentMinAggregateInputType
    _max?: TreatmentMaxAggregateInputType
  }

  export type TreatmentGroupByOutputType = {
    id: number
    hospital_Id: number
    staff_Id: JsonValue
    patient_Id: number
    doctor_Id: JsonValue
    treatmentName: JsonValue
    startDate: Date
    endDate: Date
    progress: string
    status: string
    createdAt: Date
    updatedAt: Date
    paymentStatus: boolean
    _count: TreatmentCountAggregateOutputType | null
    _avg: TreatmentAvgAggregateOutputType | null
    _sum: TreatmentSumAggregateOutputType | null
    _min: TreatmentMinAggregateOutputType | null
    _max: TreatmentMaxAggregateOutputType | null
  }

  type GetTreatmentGroupByPayload<T extends TreatmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    staff_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    treatmentName?: boolean
    startDate?: boolean
    endDate?: boolean
    progress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentStatus?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
    Doctor?: boolean | Treatment$DoctorArgs<ExtArgs>
    Staff?: boolean | Treatment$StaffArgs<ExtArgs>
    _count?: boolean | TreatmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatment"]>



  export type TreatmentSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    staff_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    treatmentName?: boolean
    startDate?: boolean
    endDate?: boolean
    progress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentStatus?: boolean
  }

  export type TreatmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "staff_Id" | "patient_Id" | "doctor_Id" | "treatmentName" | "startDate" | "endDate" | "progress" | "status" | "createdAt" | "updatedAt" | "paymentStatus", ExtArgs["result"]["treatment"]>
  export type TreatmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
    Doctor?: boolean | Treatment$DoctorArgs<ExtArgs>
    Staff?: boolean | Treatment$StaffArgs<ExtArgs>
    _count?: boolean | TreatmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TreatmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Treatment"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      Patient: Prisma.$PatientPayload<ExtArgs>
      Doctor: Prisma.$AdminPayload<ExtArgs>[]
      Staff: Prisma.$AdminPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      staff_Id: Prisma.JsonValue
      patient_Id: number
      doctor_Id: Prisma.JsonValue
      treatmentName: Prisma.JsonValue
      startDate: Date
      endDate: Date
      progress: string
      status: string
      createdAt: Date
      updatedAt: Date
      paymentStatus: boolean
    }, ExtArgs["result"]["treatment"]>
    composites: {}
  }

  type TreatmentGetPayload<S extends boolean | null | undefined | TreatmentDefaultArgs> = $Result.GetResult<Prisma.$TreatmentPayload, S>

  type TreatmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TreatmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TreatmentCountAggregateInputType | true
    }

  export interface TreatmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Treatment'], meta: { name: 'Treatment' } }
    /**
     * Find zero or one Treatment that matches the filter.
     * @param {TreatmentFindUniqueArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentFindUniqueArgs>(args: SelectSubset<T, TreatmentFindUniqueArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Treatment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TreatmentFindUniqueOrThrowArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Treatment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindFirstArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentFindFirstArgs>(args?: SelectSubset<T, TreatmentFindFirstArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Treatment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindFirstOrThrowArgs} args - Arguments to find a Treatment
     * @example
     * // Get one Treatment
     * const treatment = await prisma.treatment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Treatments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treatments
     * const treatments = await prisma.treatment.findMany()
     * 
     * // Get first 10 Treatments
     * const treatments = await prisma.treatment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treatmentWithIdOnly = await prisma.treatment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreatmentFindManyArgs>(args?: SelectSubset<T, TreatmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Treatment.
     * @param {TreatmentCreateArgs} args - Arguments to create a Treatment.
     * @example
     * // Create one Treatment
     * const Treatment = await prisma.treatment.create({
     *   data: {
     *     // ... data to create a Treatment
     *   }
     * })
     * 
     */
    create<T extends TreatmentCreateArgs>(args: SelectSubset<T, TreatmentCreateArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Treatments.
     * @param {TreatmentCreateManyArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatment = await prisma.treatment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentCreateManyArgs>(args?: SelectSubset<T, TreatmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Treatment.
     * @param {TreatmentDeleteArgs} args - Arguments to delete one Treatment.
     * @example
     * // Delete one Treatment
     * const Treatment = await prisma.treatment.delete({
     *   where: {
     *     // ... filter to delete one Treatment
     *   }
     * })
     * 
     */
    delete<T extends TreatmentDeleteArgs>(args: SelectSubset<T, TreatmentDeleteArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Treatment.
     * @param {TreatmentUpdateArgs} args - Arguments to update one Treatment.
     * @example
     * // Update one Treatment
     * const treatment = await prisma.treatment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentUpdateArgs>(args: SelectSubset<T, TreatmentUpdateArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Treatments.
     * @param {TreatmentDeleteManyArgs} args - Arguments to filter Treatments to delete.
     * @example
     * // Delete a few Treatments
     * const { count } = await prisma.treatment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentDeleteManyArgs>(args?: SelectSubset<T, TreatmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treatments
     * const treatment = await prisma.treatment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentUpdateManyArgs>(args: SelectSubset<T, TreatmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Treatment.
     * @param {TreatmentUpsertArgs} args - Arguments to update or create a Treatment.
     * @example
     * // Update or create a Treatment
     * const treatment = await prisma.treatment.upsert({
     *   create: {
     *     // ... data to create a Treatment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treatment we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentUpsertArgs>(args: SelectSubset<T, TreatmentUpsertArgs<ExtArgs>>): Prisma__TreatmentClient<$Result.GetResult<Prisma.$TreatmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentCountArgs} args - Arguments to filter Treatments to count.
     * @example
     * // Count the number of Treatments
     * const count = await prisma.treatment.count({
     *   where: {
     *     // ... the filter for the Treatments we want to count
     *   }
     * })
    **/
    count<T extends TreatmentCountArgs>(
      args?: Subset<T, TreatmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentAggregateArgs>(args: Subset<T, TreatmentAggregateArgs>): Prisma.PrismaPromise<GetTreatmentAggregateType<T>>

    /**
     * Group by Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Treatment model
   */
  readonly fields: TreatmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Treatment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Doctor<T extends Treatment$DoctorArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$DoctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Staff<T extends Treatment$StaffArgs<ExtArgs> = {}>(args?: Subset<T, Treatment$StaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Treatment model
   */
  interface TreatmentFieldRefs {
    readonly id: FieldRef<"Treatment", 'Int'>
    readonly hospital_Id: FieldRef<"Treatment", 'Int'>
    readonly staff_Id: FieldRef<"Treatment", 'Json'>
    readonly patient_Id: FieldRef<"Treatment", 'Int'>
    readonly doctor_Id: FieldRef<"Treatment", 'Json'>
    readonly treatmentName: FieldRef<"Treatment", 'Json'>
    readonly startDate: FieldRef<"Treatment", 'DateTime'>
    readonly endDate: FieldRef<"Treatment", 'DateTime'>
    readonly progress: FieldRef<"Treatment", 'String'>
    readonly status: FieldRef<"Treatment", 'String'>
    readonly createdAt: FieldRef<"Treatment", 'DateTime'>
    readonly updatedAt: FieldRef<"Treatment", 'DateTime'>
    readonly paymentStatus: FieldRef<"Treatment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Treatment findUnique
   */
  export type TreatmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment findUniqueOrThrow
   */
  export type TreatmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment findFirst
   */
  export type TreatmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment findFirstOrThrow
   */
  export type TreatmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatment to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment findMany
   */
  export type TreatmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where?: TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentOrderByWithRelationInput | TreatmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Treatments.
     */
    cursor?: TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    distinct?: TreatmentScalarFieldEnum | TreatmentScalarFieldEnum[]
  }

  /**
   * Treatment create
   */
  export type TreatmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Treatment.
     */
    data: XOR<TreatmentCreateInput, TreatmentUncheckedCreateInput>
  }

  /**
   * Treatment createMany
   */
  export type TreatmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentCreateManyInput | TreatmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Treatment update
   */
  export type TreatmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Treatment.
     */
    data: XOR<TreatmentUpdateInput, TreatmentUncheckedUpdateInput>
    /**
     * Choose, which Treatment to update.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment updateMany
   */
  export type TreatmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Treatments.
     */
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyInput>
    /**
     * Filter which Treatments to update
     */
    where?: TreatmentWhereInput
    /**
     * Limit how many Treatments to update.
     */
    limit?: number
  }

  /**
   * Treatment upsert
   */
  export type TreatmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Treatment to update in case it exists.
     */
    where: TreatmentWhereUniqueInput
    /**
     * In case the Treatment found by the `where` argument doesn't exist, create a new Treatment with this data.
     */
    create: XOR<TreatmentCreateInput, TreatmentUncheckedCreateInput>
    /**
     * In case the Treatment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentUpdateInput, TreatmentUncheckedUpdateInput>
  }

  /**
   * Treatment delete
   */
  export type TreatmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
    /**
     * Filter which Treatment to delete.
     */
    where: TreatmentWhereUniqueInput
  }

  /**
   * Treatment deleteMany
   */
  export type TreatmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatments to delete
     */
    where?: TreatmentWhereInput
    /**
     * Limit how many Treatments to delete.
     */
    limit?: number
  }

  /**
   * Treatment.Doctor
   */
  export type Treatment$DoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Treatment.Staff
   */
  export type Treatment$StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Treatment without action
   */
  export type TreatmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatment
     */
    select?: TreatmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Treatment
     */
    omit?: TreatmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentInclude<ExtArgs> | null
  }


  /**
   * Model Medician
   */

  export type AggregateMedician = {
    _count: MedicianCountAggregateOutputType | null
    _avg: MedicianAvgAggregateOutputType | null
    _sum: MedicianSumAggregateOutputType | null
    _min: MedicianMinAggregateOutputType | null
    _max: MedicianMaxAggregateOutputType | null
  }

  export type MedicianAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    stock: number | null
    amount: number | null
  }

  export type MedicianSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    stock: number | null
    amount: number | null
  }

  export type MedicianMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    medicianName: string | null
    stock: number | null
    amount: number | null
  }

  export type MedicianMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    medicianName: string | null
    stock: number | null
    amount: number | null
  }

  export type MedicianCountAggregateOutputType = {
    id: number
    hospital_Id: number
    medicianName: number
    stock: number
    amount: number
    staffId: number
    _all: number
  }


  export type MedicianAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    stock?: true
    amount?: true
  }

  export type MedicianSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    stock?: true
    amount?: true
  }

  export type MedicianMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    medicianName?: true
    stock?: true
    amount?: true
  }

  export type MedicianMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    medicianName?: true
    stock?: true
    amount?: true
  }

  export type MedicianCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    medicianName?: true
    stock?: true
    amount?: true
    staffId?: true
    _all?: true
  }

  export type MedicianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medician to aggregate.
     */
    where?: MedicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicians to fetch.
     */
    orderBy?: MedicianOrderByWithRelationInput | MedicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicians
    **/
    _count?: true | MedicianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicianMaxAggregateInputType
  }

  export type GetMedicianAggregateType<T extends MedicianAggregateArgs> = {
        [P in keyof T & keyof AggregateMedician]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedician[P]>
      : GetScalarType<T[P], AggregateMedician[P]>
  }




  export type MedicianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicianWhereInput
    orderBy?: MedicianOrderByWithAggregationInput | MedicianOrderByWithAggregationInput[]
    by: MedicianScalarFieldEnum[] | MedicianScalarFieldEnum
    having?: MedicianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicianCountAggregateInputType | true
    _avg?: MedicianAvgAggregateInputType
    _sum?: MedicianSumAggregateInputType
    _min?: MedicianMinAggregateInputType
    _max?: MedicianMaxAggregateInputType
  }

  export type MedicianGroupByOutputType = {
    id: number
    hospital_Id: number
    medicianName: string
    stock: number
    amount: number
    staffId: JsonValue
    _count: MedicianCountAggregateOutputType | null
    _avg: MedicianAvgAggregateOutputType | null
    _sum: MedicianSumAggregateOutputType | null
    _min: MedicianMinAggregateOutputType | null
    _max: MedicianMaxAggregateOutputType | null
  }

  type GetMedicianGroupByPayload<T extends MedicianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicianGroupByOutputType[P]>
            : GetScalarType<T[P], MedicianGroupByOutputType[P]>
        }
      >
    >


  export type MedicianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    medicianName?: boolean
    stock?: boolean
    amount?: boolean
    staffId?: boolean
    MedicineAndInjection?: boolean | Medician$MedicineAndInjectionArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    _count?: boolean | MedicianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medician"]>



  export type MedicianSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    medicianName?: boolean
    stock?: boolean
    amount?: boolean
    staffId?: boolean
  }

  export type MedicianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "medicianName" | "stock" | "amount" | "staffId", ExtArgs["result"]["medician"]>
  export type MedicianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MedicineAndInjection?: boolean | Medician$MedicineAndInjectionArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    _count?: boolean | MedicianCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medician"
    objects: {
      MedicineAndInjection: Prisma.$MedicineAndInjectionPayload<ExtArgs>[]
      Hospital: Prisma.$HospitalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      medicianName: string
      stock: number
      amount: number
      staffId: Prisma.JsonValue
    }, ExtArgs["result"]["medician"]>
    composites: {}
  }

  type MedicianGetPayload<S extends boolean | null | undefined | MedicianDefaultArgs> = $Result.GetResult<Prisma.$MedicianPayload, S>

  type MedicianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicianCountAggregateInputType | true
    }

  export interface MedicianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medician'], meta: { name: 'Medician' } }
    /**
     * Find zero or one Medician that matches the filter.
     * @param {MedicianFindUniqueArgs} args - Arguments to find a Medician
     * @example
     * // Get one Medician
     * const medician = await prisma.medician.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicianFindUniqueArgs>(args: SelectSubset<T, MedicianFindUniqueArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medician that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicianFindUniqueOrThrowArgs} args - Arguments to find a Medician
     * @example
     * // Get one Medician
     * const medician = await prisma.medician.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicianFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medician that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianFindFirstArgs} args - Arguments to find a Medician
     * @example
     * // Get one Medician
     * const medician = await prisma.medician.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicianFindFirstArgs>(args?: SelectSubset<T, MedicianFindFirstArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medician that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianFindFirstOrThrowArgs} args - Arguments to find a Medician
     * @example
     * // Get one Medician
     * const medician = await prisma.medician.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicianFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicianFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicians
     * const medicians = await prisma.medician.findMany()
     * 
     * // Get first 10 Medicians
     * const medicians = await prisma.medician.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicianWithIdOnly = await prisma.medician.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicianFindManyArgs>(args?: SelectSubset<T, MedicianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medician.
     * @param {MedicianCreateArgs} args - Arguments to create a Medician.
     * @example
     * // Create one Medician
     * const Medician = await prisma.medician.create({
     *   data: {
     *     // ... data to create a Medician
     *   }
     * })
     * 
     */
    create<T extends MedicianCreateArgs>(args: SelectSubset<T, MedicianCreateArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicians.
     * @param {MedicianCreateManyArgs} args - Arguments to create many Medicians.
     * @example
     * // Create many Medicians
     * const medician = await prisma.medician.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicianCreateManyArgs>(args?: SelectSubset<T, MedicianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medician.
     * @param {MedicianDeleteArgs} args - Arguments to delete one Medician.
     * @example
     * // Delete one Medician
     * const Medician = await prisma.medician.delete({
     *   where: {
     *     // ... filter to delete one Medician
     *   }
     * })
     * 
     */
    delete<T extends MedicianDeleteArgs>(args: SelectSubset<T, MedicianDeleteArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medician.
     * @param {MedicianUpdateArgs} args - Arguments to update one Medician.
     * @example
     * // Update one Medician
     * const medician = await prisma.medician.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicianUpdateArgs>(args: SelectSubset<T, MedicianUpdateArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicians.
     * @param {MedicianDeleteManyArgs} args - Arguments to filter Medicians to delete.
     * @example
     * // Delete a few Medicians
     * const { count } = await prisma.medician.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicianDeleteManyArgs>(args?: SelectSubset<T, MedicianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicians
     * const medician = await prisma.medician.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicianUpdateManyArgs>(args: SelectSubset<T, MedicianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medician.
     * @param {MedicianUpsertArgs} args - Arguments to update or create a Medician.
     * @example
     * // Update or create a Medician
     * const medician = await prisma.medician.upsert({
     *   create: {
     *     // ... data to create a Medician
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medician we want to update
     *   }
     * })
     */
    upsert<T extends MedicianUpsertArgs>(args: SelectSubset<T, MedicianUpsertArgs<ExtArgs>>): Prisma__MedicianClient<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianCountArgs} args - Arguments to filter Medicians to count.
     * @example
     * // Count the number of Medicians
     * const count = await prisma.medician.count({
     *   where: {
     *     // ... the filter for the Medicians we want to count
     *   }
     * })
    **/
    count<T extends MedicianCountArgs>(
      args?: Subset<T, MedicianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicianAggregateArgs>(args: Subset<T, MedicianAggregateArgs>): Prisma.PrismaPromise<GetMedicianAggregateType<T>>

    /**
     * Group by Medician.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicianGroupByArgs['orderBy'] }
        : { orderBy?: MedicianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medician model
   */
  readonly fields: MedicianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medician.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MedicineAndInjection<T extends Medician$MedicineAndInjectionArgs<ExtArgs> = {}>(args?: Subset<T, Medician$MedicineAndInjectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medician model
   */
  interface MedicianFieldRefs {
    readonly id: FieldRef<"Medician", 'Int'>
    readonly hospital_Id: FieldRef<"Medician", 'Int'>
    readonly medicianName: FieldRef<"Medician", 'String'>
    readonly stock: FieldRef<"Medician", 'Int'>
    readonly amount: FieldRef<"Medician", 'Float'>
    readonly staffId: FieldRef<"Medician", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Medician findUnique
   */
  export type MedicianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * Filter, which Medician to fetch.
     */
    where: MedicianWhereUniqueInput
  }

  /**
   * Medician findUniqueOrThrow
   */
  export type MedicianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * Filter, which Medician to fetch.
     */
    where: MedicianWhereUniqueInput
  }

  /**
   * Medician findFirst
   */
  export type MedicianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * Filter, which Medician to fetch.
     */
    where?: MedicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicians to fetch.
     */
    orderBy?: MedicianOrderByWithRelationInput | MedicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicians.
     */
    cursor?: MedicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicians.
     */
    distinct?: MedicianScalarFieldEnum | MedicianScalarFieldEnum[]
  }

  /**
   * Medician findFirstOrThrow
   */
  export type MedicianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * Filter, which Medician to fetch.
     */
    where?: MedicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicians to fetch.
     */
    orderBy?: MedicianOrderByWithRelationInput | MedicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicians.
     */
    cursor?: MedicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicians.
     */
    distinct?: MedicianScalarFieldEnum | MedicianScalarFieldEnum[]
  }

  /**
   * Medician findMany
   */
  export type MedicianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * Filter, which Medicians to fetch.
     */
    where?: MedicianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicians to fetch.
     */
    orderBy?: MedicianOrderByWithRelationInput | MedicianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicians.
     */
    cursor?: MedicianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicians.
     */
    skip?: number
    distinct?: MedicianScalarFieldEnum | MedicianScalarFieldEnum[]
  }

  /**
   * Medician create
   */
  export type MedicianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * The data needed to create a Medician.
     */
    data: XOR<MedicianCreateInput, MedicianUncheckedCreateInput>
  }

  /**
   * Medician createMany
   */
  export type MedicianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicians.
     */
    data: MedicianCreateManyInput | MedicianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medician update
   */
  export type MedicianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * The data needed to update a Medician.
     */
    data: XOR<MedicianUpdateInput, MedicianUncheckedUpdateInput>
    /**
     * Choose, which Medician to update.
     */
    where: MedicianWhereUniqueInput
  }

  /**
   * Medician updateMany
   */
  export type MedicianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicians.
     */
    data: XOR<MedicianUpdateManyMutationInput, MedicianUncheckedUpdateManyInput>
    /**
     * Filter which Medicians to update
     */
    where?: MedicianWhereInput
    /**
     * Limit how many Medicians to update.
     */
    limit?: number
  }

  /**
   * Medician upsert
   */
  export type MedicianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * The filter to search for the Medician to update in case it exists.
     */
    where: MedicianWhereUniqueInput
    /**
     * In case the Medician found by the `where` argument doesn't exist, create a new Medician with this data.
     */
    create: XOR<MedicianCreateInput, MedicianUncheckedCreateInput>
    /**
     * In case the Medician was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicianUpdateInput, MedicianUncheckedUpdateInput>
  }

  /**
   * Medician delete
   */
  export type MedicianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    /**
     * Filter which Medician to delete.
     */
    where: MedicianWhereUniqueInput
  }

  /**
   * Medician deleteMany
   */
  export type MedicianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicians to delete
     */
    where?: MedicianWhereInput
    /**
     * Limit how many Medicians to delete.
     */
    limit?: number
  }

  /**
   * Medician.MedicineAndInjection
   */
  export type Medician$MedicineAndInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    where?: MedicineAndInjectionWhereInput
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    cursor?: MedicineAndInjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * Medician without action
   */
  export type MedicianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
  }


  /**
   * Model Injection
   */

  export type AggregateInjection = {
    _count: InjectionCountAggregateOutputType | null
    _avg: InjectionAvgAggregateOutputType | null
    _sum: InjectionSumAggregateOutputType | null
    _min: InjectionMinAggregateOutputType | null
    _max: InjectionMaxAggregateOutputType | null
  }

  export type InjectionAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    stock: number | null
    amount: number | null
  }

  export type InjectionSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    stock: number | null
    amount: number | null
  }

  export type InjectionMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    injectionName: string | null
    stock: number | null
    amount: number | null
  }

  export type InjectionMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    injectionName: string | null
    stock: number | null
    amount: number | null
  }

  export type InjectionCountAggregateOutputType = {
    id: number
    hospital_Id: number
    injectionName: number
    stock: number
    amount: number
    staffId: number
    _all: number
  }


  export type InjectionAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    stock?: true
    amount?: true
  }

  export type InjectionSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    stock?: true
    amount?: true
  }

  export type InjectionMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    injectionName?: true
    stock?: true
    amount?: true
  }

  export type InjectionMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    injectionName?: true
    stock?: true
    amount?: true
  }

  export type InjectionCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    injectionName?: true
    stock?: true
    amount?: true
    staffId?: true
    _all?: true
  }

  export type InjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Injection to aggregate.
     */
    where?: InjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injections to fetch.
     */
    orderBy?: InjectionOrderByWithRelationInput | InjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Injections
    **/
    _count?: true | InjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InjectionMaxAggregateInputType
  }

  export type GetInjectionAggregateType<T extends InjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateInjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInjection[P]>
      : GetScalarType<T[P], AggregateInjection[P]>
  }




  export type InjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InjectionWhereInput
    orderBy?: InjectionOrderByWithAggregationInput | InjectionOrderByWithAggregationInput[]
    by: InjectionScalarFieldEnum[] | InjectionScalarFieldEnum
    having?: InjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InjectionCountAggregateInputType | true
    _avg?: InjectionAvgAggregateInputType
    _sum?: InjectionSumAggregateInputType
    _min?: InjectionMinAggregateInputType
    _max?: InjectionMaxAggregateInputType
  }

  export type InjectionGroupByOutputType = {
    id: number
    hospital_Id: number
    injectionName: string
    stock: number
    amount: number
    staffId: JsonValue
    _count: InjectionCountAggregateOutputType | null
    _avg: InjectionAvgAggregateOutputType | null
    _sum: InjectionSumAggregateOutputType | null
    _min: InjectionMinAggregateOutputType | null
    _max: InjectionMaxAggregateOutputType | null
  }

  type GetInjectionGroupByPayload<T extends InjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InjectionGroupByOutputType[P]>
            : GetScalarType<T[P], InjectionGroupByOutputType[P]>
        }
      >
    >


  export type InjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    injectionName?: boolean
    stock?: boolean
    amount?: boolean
    staffId?: boolean
    MedicineAndInjection?: boolean | Injection$MedicineAndInjectionArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    _count?: boolean | InjectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["injection"]>



  export type InjectionSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    injectionName?: boolean
    stock?: boolean
    amount?: boolean
    staffId?: boolean
  }

  export type InjectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "injectionName" | "stock" | "amount" | "staffId", ExtArgs["result"]["injection"]>
  export type InjectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MedicineAndInjection?: boolean | Injection$MedicineAndInjectionArgs<ExtArgs>
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    _count?: boolean | InjectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Injection"
    objects: {
      MedicineAndInjection: Prisma.$MedicineAndInjectionPayload<ExtArgs>[]
      Hospital: Prisma.$HospitalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      injectionName: string
      stock: number
      amount: number
      staffId: Prisma.JsonValue
    }, ExtArgs["result"]["injection"]>
    composites: {}
  }

  type InjectionGetPayload<S extends boolean | null | undefined | InjectionDefaultArgs> = $Result.GetResult<Prisma.$InjectionPayload, S>

  type InjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InjectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InjectionCountAggregateInputType | true
    }

  export interface InjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Injection'], meta: { name: 'Injection' } }
    /**
     * Find zero or one Injection that matches the filter.
     * @param {InjectionFindUniqueArgs} args - Arguments to find a Injection
     * @example
     * // Get one Injection
     * const injection = await prisma.injection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InjectionFindUniqueArgs>(args: SelectSubset<T, InjectionFindUniqueArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Injection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InjectionFindUniqueOrThrowArgs} args - Arguments to find a Injection
     * @example
     * // Get one Injection
     * const injection = await prisma.injection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, InjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Injection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionFindFirstArgs} args - Arguments to find a Injection
     * @example
     * // Get one Injection
     * const injection = await prisma.injection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InjectionFindFirstArgs>(args?: SelectSubset<T, InjectionFindFirstArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Injection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionFindFirstOrThrowArgs} args - Arguments to find a Injection
     * @example
     * // Get one Injection
     * const injection = await prisma.injection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, InjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Injections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Injections
     * const injections = await prisma.injection.findMany()
     * 
     * // Get first 10 Injections
     * const injections = await prisma.injection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const injectionWithIdOnly = await prisma.injection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InjectionFindManyArgs>(args?: SelectSubset<T, InjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Injection.
     * @param {InjectionCreateArgs} args - Arguments to create a Injection.
     * @example
     * // Create one Injection
     * const Injection = await prisma.injection.create({
     *   data: {
     *     // ... data to create a Injection
     *   }
     * })
     * 
     */
    create<T extends InjectionCreateArgs>(args: SelectSubset<T, InjectionCreateArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Injections.
     * @param {InjectionCreateManyArgs} args - Arguments to create many Injections.
     * @example
     * // Create many Injections
     * const injection = await prisma.injection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InjectionCreateManyArgs>(args?: SelectSubset<T, InjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Injection.
     * @param {InjectionDeleteArgs} args - Arguments to delete one Injection.
     * @example
     * // Delete one Injection
     * const Injection = await prisma.injection.delete({
     *   where: {
     *     // ... filter to delete one Injection
     *   }
     * })
     * 
     */
    delete<T extends InjectionDeleteArgs>(args: SelectSubset<T, InjectionDeleteArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Injection.
     * @param {InjectionUpdateArgs} args - Arguments to update one Injection.
     * @example
     * // Update one Injection
     * const injection = await prisma.injection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InjectionUpdateArgs>(args: SelectSubset<T, InjectionUpdateArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Injections.
     * @param {InjectionDeleteManyArgs} args - Arguments to filter Injections to delete.
     * @example
     * // Delete a few Injections
     * const { count } = await prisma.injection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InjectionDeleteManyArgs>(args?: SelectSubset<T, InjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Injections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Injections
     * const injection = await prisma.injection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InjectionUpdateManyArgs>(args: SelectSubset<T, InjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Injection.
     * @param {InjectionUpsertArgs} args - Arguments to update or create a Injection.
     * @example
     * // Update or create a Injection
     * const injection = await prisma.injection.upsert({
     *   create: {
     *     // ... data to create a Injection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Injection we want to update
     *   }
     * })
     */
    upsert<T extends InjectionUpsertArgs>(args: SelectSubset<T, InjectionUpsertArgs<ExtArgs>>): Prisma__InjectionClient<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Injections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionCountArgs} args - Arguments to filter Injections to count.
     * @example
     * // Count the number of Injections
     * const count = await prisma.injection.count({
     *   where: {
     *     // ... the filter for the Injections we want to count
     *   }
     * })
    **/
    count<T extends InjectionCountArgs>(
      args?: Subset<T, InjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Injection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InjectionAggregateArgs>(args: Subset<T, InjectionAggregateArgs>): Prisma.PrismaPromise<GetInjectionAggregateType<T>>

    /**
     * Group by Injection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InjectionGroupByArgs['orderBy'] }
        : { orderBy?: InjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Injection model
   */
  readonly fields: InjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Injection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MedicineAndInjection<T extends Injection$MedicineAndInjectionArgs<ExtArgs> = {}>(args?: Subset<T, Injection$MedicineAndInjectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Injection model
   */
  interface InjectionFieldRefs {
    readonly id: FieldRef<"Injection", 'Int'>
    readonly hospital_Id: FieldRef<"Injection", 'Int'>
    readonly injectionName: FieldRef<"Injection", 'String'>
    readonly stock: FieldRef<"Injection", 'Int'>
    readonly amount: FieldRef<"Injection", 'Float'>
    readonly staffId: FieldRef<"Injection", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Injection findUnique
   */
  export type InjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * Filter, which Injection to fetch.
     */
    where: InjectionWhereUniqueInput
  }

  /**
   * Injection findUniqueOrThrow
   */
  export type InjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * Filter, which Injection to fetch.
     */
    where: InjectionWhereUniqueInput
  }

  /**
   * Injection findFirst
   */
  export type InjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * Filter, which Injection to fetch.
     */
    where?: InjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injections to fetch.
     */
    orderBy?: InjectionOrderByWithRelationInput | InjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Injections.
     */
    cursor?: InjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Injections.
     */
    distinct?: InjectionScalarFieldEnum | InjectionScalarFieldEnum[]
  }

  /**
   * Injection findFirstOrThrow
   */
  export type InjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * Filter, which Injection to fetch.
     */
    where?: InjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injections to fetch.
     */
    orderBy?: InjectionOrderByWithRelationInput | InjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Injections.
     */
    cursor?: InjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Injections.
     */
    distinct?: InjectionScalarFieldEnum | InjectionScalarFieldEnum[]
  }

  /**
   * Injection findMany
   */
  export type InjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * Filter, which Injections to fetch.
     */
    where?: InjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Injections to fetch.
     */
    orderBy?: InjectionOrderByWithRelationInput | InjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Injections.
     */
    cursor?: InjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Injections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Injections.
     */
    skip?: number
    distinct?: InjectionScalarFieldEnum | InjectionScalarFieldEnum[]
  }

  /**
   * Injection create
   */
  export type InjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Injection.
     */
    data: XOR<InjectionCreateInput, InjectionUncheckedCreateInput>
  }

  /**
   * Injection createMany
   */
  export type InjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Injections.
     */
    data: InjectionCreateManyInput | InjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Injection update
   */
  export type InjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Injection.
     */
    data: XOR<InjectionUpdateInput, InjectionUncheckedUpdateInput>
    /**
     * Choose, which Injection to update.
     */
    where: InjectionWhereUniqueInput
  }

  /**
   * Injection updateMany
   */
  export type InjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Injections.
     */
    data: XOR<InjectionUpdateManyMutationInput, InjectionUncheckedUpdateManyInput>
    /**
     * Filter which Injections to update
     */
    where?: InjectionWhereInput
    /**
     * Limit how many Injections to update.
     */
    limit?: number
  }

  /**
   * Injection upsert
   */
  export type InjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Injection to update in case it exists.
     */
    where: InjectionWhereUniqueInput
    /**
     * In case the Injection found by the `where` argument doesn't exist, create a new Injection with this data.
     */
    create: XOR<InjectionCreateInput, InjectionUncheckedCreateInput>
    /**
     * In case the Injection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InjectionUpdateInput, InjectionUncheckedUpdateInput>
  }

  /**
   * Injection delete
   */
  export type InjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    /**
     * Filter which Injection to delete.
     */
    where: InjectionWhereUniqueInput
  }

  /**
   * Injection deleteMany
   */
  export type InjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Injections to delete
     */
    where?: InjectionWhereInput
    /**
     * Limit how many Injections to delete.
     */
    limit?: number
  }

  /**
   * Injection.MedicineAndInjection
   */
  export type Injection$MedicineAndInjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    where?: MedicineAndInjectionWhereInput
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    cursor?: MedicineAndInjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * Injection without action
   */
  export type InjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
  }


  /**
   * Model TestingAndScanningH
   */

  export type AggregateTestingAndScanningH = {
    _count: TestingAndScanningHCountAggregateOutputType | null
    _avg: TestingAndScanningHAvgAggregateOutputType | null
    _sum: TestingAndScanningHSumAggregateOutputType | null
    _min: TestingAndScanningHMinAggregateOutputType | null
    _max: TestingAndScanningHMaxAggregateOutputType | null
  }

  export type TestingAndScanningHAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    staffId: number | null
    amount: number | null
  }

  export type TestingAndScanningHSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    staffId: number | null
    amount: number | null
  }

  export type TestingAndScanningHMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    type: string | null
    status: string | null
    roomNo: string | null
    staffId: number | null
    amount: number | null
  }

  export type TestingAndScanningHMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    type: string | null
    status: string | null
    roomNo: string | null
    staffId: number | null
    amount: number | null
  }

  export type TestingAndScanningHCountAggregateOutputType = {
    id: number
    hospital_Id: number
    type: number
    status: number
    roomNo: number
    staffId: number
    amount: number
    _all: number
  }


  export type TestingAndScanningHAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    amount?: true
  }

  export type TestingAndScanningHSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    amount?: true
  }

  export type TestingAndScanningHMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    type?: true
    status?: true
    roomNo?: true
    staffId?: true
    amount?: true
  }

  export type TestingAndScanningHMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    type?: true
    status?: true
    roomNo?: true
    staffId?: true
    amount?: true
  }

  export type TestingAndScanningHCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    type?: true
    status?: true
    roomNo?: true
    staffId?: true
    amount?: true
    _all?: true
  }

  export type TestingAndScanningHAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestingAndScanningH to aggregate.
     */
    where?: TestingAndScanningHWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningHS to fetch.
     */
    orderBy?: TestingAndScanningHOrderByWithRelationInput | TestingAndScanningHOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestingAndScanningHWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningHS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningHS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestingAndScanningHS
    **/
    _count?: true | TestingAndScanningHCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestingAndScanningHAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestingAndScanningHSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestingAndScanningHMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestingAndScanningHMaxAggregateInputType
  }

  export type GetTestingAndScanningHAggregateType<T extends TestingAndScanningHAggregateArgs> = {
        [P in keyof T & keyof AggregateTestingAndScanningH]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestingAndScanningH[P]>
      : GetScalarType<T[P], AggregateTestingAndScanningH[P]>
  }




  export type TestingAndScanningHGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestingAndScanningHWhereInput
    orderBy?: TestingAndScanningHOrderByWithAggregationInput | TestingAndScanningHOrderByWithAggregationInput[]
    by: TestingAndScanningHScalarFieldEnum[] | TestingAndScanningHScalarFieldEnum
    having?: TestingAndScanningHScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestingAndScanningHCountAggregateInputType | true
    _avg?: TestingAndScanningHAvgAggregateInputType
    _sum?: TestingAndScanningHSumAggregateInputType
    _min?: TestingAndScanningHMinAggregateInputType
    _max?: TestingAndScanningHMaxAggregateInputType
  }

  export type TestingAndScanningHGroupByOutputType = {
    id: number
    hospital_Id: number
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
    _count: TestingAndScanningHCountAggregateOutputType | null
    _avg: TestingAndScanningHAvgAggregateOutputType | null
    _sum: TestingAndScanningHSumAggregateOutputType | null
    _min: TestingAndScanningHMinAggregateOutputType | null
    _max: TestingAndScanningHMaxAggregateOutputType | null
  }

  type GetTestingAndScanningHGroupByPayload<T extends TestingAndScanningHGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestingAndScanningHGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestingAndScanningHGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestingAndScanningHGroupByOutputType[P]>
            : GetScalarType<T[P], TestingAndScanningHGroupByOutputType[P]>
        }
      >
    >


  export type TestingAndScanningHSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    type?: boolean
    status?: boolean
    roomNo?: boolean
    staffId?: boolean
    amount?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testingAndScanningH"]>



  export type TestingAndScanningHSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    type?: boolean
    status?: boolean
    roomNo?: boolean
    staffId?: boolean
    amount?: boolean
  }

  export type TestingAndScanningHOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "type" | "status" | "roomNo" | "staffId" | "amount", ExtArgs["result"]["testingAndScanningH"]>
  export type TestingAndScanningHInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }

  export type $TestingAndScanningHPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestingAndScanningH"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      type: string
      status: string
      roomNo: string
      staffId: number
      amount: number
    }, ExtArgs["result"]["testingAndScanningH"]>
    composites: {}
  }

  type TestingAndScanningHGetPayload<S extends boolean | null | undefined | TestingAndScanningHDefaultArgs> = $Result.GetResult<Prisma.$TestingAndScanningHPayload, S>

  type TestingAndScanningHCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestingAndScanningHFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestingAndScanningHCountAggregateInputType | true
    }

  export interface TestingAndScanningHDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestingAndScanningH'], meta: { name: 'TestingAndScanningH' } }
    /**
     * Find zero or one TestingAndScanningH that matches the filter.
     * @param {TestingAndScanningHFindUniqueArgs} args - Arguments to find a TestingAndScanningH
     * @example
     * // Get one TestingAndScanningH
     * const testingAndScanningH = await prisma.testingAndScanningH.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestingAndScanningHFindUniqueArgs>(args: SelectSubset<T, TestingAndScanningHFindUniqueArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestingAndScanningH that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestingAndScanningHFindUniqueOrThrowArgs} args - Arguments to find a TestingAndScanningH
     * @example
     * // Get one TestingAndScanningH
     * const testingAndScanningH = await prisma.testingAndScanningH.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestingAndScanningHFindUniqueOrThrowArgs>(args: SelectSubset<T, TestingAndScanningHFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestingAndScanningH that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHFindFirstArgs} args - Arguments to find a TestingAndScanningH
     * @example
     * // Get one TestingAndScanningH
     * const testingAndScanningH = await prisma.testingAndScanningH.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestingAndScanningHFindFirstArgs>(args?: SelectSubset<T, TestingAndScanningHFindFirstArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestingAndScanningH that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHFindFirstOrThrowArgs} args - Arguments to find a TestingAndScanningH
     * @example
     * // Get one TestingAndScanningH
     * const testingAndScanningH = await prisma.testingAndScanningH.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestingAndScanningHFindFirstOrThrowArgs>(args?: SelectSubset<T, TestingAndScanningHFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestingAndScanningHS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestingAndScanningHS
     * const testingAndScanningHS = await prisma.testingAndScanningH.findMany()
     * 
     * // Get first 10 TestingAndScanningHS
     * const testingAndScanningHS = await prisma.testingAndScanningH.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testingAndScanningHWithIdOnly = await prisma.testingAndScanningH.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestingAndScanningHFindManyArgs>(args?: SelectSubset<T, TestingAndScanningHFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestingAndScanningH.
     * @param {TestingAndScanningHCreateArgs} args - Arguments to create a TestingAndScanningH.
     * @example
     * // Create one TestingAndScanningH
     * const TestingAndScanningH = await prisma.testingAndScanningH.create({
     *   data: {
     *     // ... data to create a TestingAndScanningH
     *   }
     * })
     * 
     */
    create<T extends TestingAndScanningHCreateArgs>(args: SelectSubset<T, TestingAndScanningHCreateArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestingAndScanningHS.
     * @param {TestingAndScanningHCreateManyArgs} args - Arguments to create many TestingAndScanningHS.
     * @example
     * // Create many TestingAndScanningHS
     * const testingAndScanningH = await prisma.testingAndScanningH.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestingAndScanningHCreateManyArgs>(args?: SelectSubset<T, TestingAndScanningHCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestingAndScanningH.
     * @param {TestingAndScanningHDeleteArgs} args - Arguments to delete one TestingAndScanningH.
     * @example
     * // Delete one TestingAndScanningH
     * const TestingAndScanningH = await prisma.testingAndScanningH.delete({
     *   where: {
     *     // ... filter to delete one TestingAndScanningH
     *   }
     * })
     * 
     */
    delete<T extends TestingAndScanningHDeleteArgs>(args: SelectSubset<T, TestingAndScanningHDeleteArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestingAndScanningH.
     * @param {TestingAndScanningHUpdateArgs} args - Arguments to update one TestingAndScanningH.
     * @example
     * // Update one TestingAndScanningH
     * const testingAndScanningH = await prisma.testingAndScanningH.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestingAndScanningHUpdateArgs>(args: SelectSubset<T, TestingAndScanningHUpdateArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestingAndScanningHS.
     * @param {TestingAndScanningHDeleteManyArgs} args - Arguments to filter TestingAndScanningHS to delete.
     * @example
     * // Delete a few TestingAndScanningHS
     * const { count } = await prisma.testingAndScanningH.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestingAndScanningHDeleteManyArgs>(args?: SelectSubset<T, TestingAndScanningHDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestingAndScanningHS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestingAndScanningHS
     * const testingAndScanningH = await prisma.testingAndScanningH.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestingAndScanningHUpdateManyArgs>(args: SelectSubset<T, TestingAndScanningHUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestingAndScanningH.
     * @param {TestingAndScanningHUpsertArgs} args - Arguments to update or create a TestingAndScanningH.
     * @example
     * // Update or create a TestingAndScanningH
     * const testingAndScanningH = await prisma.testingAndScanningH.upsert({
     *   create: {
     *     // ... data to create a TestingAndScanningH
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestingAndScanningH we want to update
     *   }
     * })
     */
    upsert<T extends TestingAndScanningHUpsertArgs>(args: SelectSubset<T, TestingAndScanningHUpsertArgs<ExtArgs>>): Prisma__TestingAndScanningHClient<$Result.GetResult<Prisma.$TestingAndScanningHPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestingAndScanningHS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHCountArgs} args - Arguments to filter TestingAndScanningHS to count.
     * @example
     * // Count the number of TestingAndScanningHS
     * const count = await prisma.testingAndScanningH.count({
     *   where: {
     *     // ... the filter for the TestingAndScanningHS we want to count
     *   }
     * })
    **/
    count<T extends TestingAndScanningHCountArgs>(
      args?: Subset<T, TestingAndScanningHCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestingAndScanningHCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestingAndScanningH.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestingAndScanningHAggregateArgs>(args: Subset<T, TestingAndScanningHAggregateArgs>): Prisma.PrismaPromise<GetTestingAndScanningHAggregateType<T>>

    /**
     * Group by TestingAndScanningH.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningHGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestingAndScanningHGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestingAndScanningHGroupByArgs['orderBy'] }
        : { orderBy?: TestingAndScanningHGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestingAndScanningHGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestingAndScanningHGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestingAndScanningH model
   */
  readonly fields: TestingAndScanningHFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestingAndScanningH.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestingAndScanningHClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestingAndScanningH model
   */
  interface TestingAndScanningHFieldRefs {
    readonly id: FieldRef<"TestingAndScanningH", 'Int'>
    readonly hospital_Id: FieldRef<"TestingAndScanningH", 'Int'>
    readonly type: FieldRef<"TestingAndScanningH", 'String'>
    readonly status: FieldRef<"TestingAndScanningH", 'String'>
    readonly roomNo: FieldRef<"TestingAndScanningH", 'String'>
    readonly staffId: FieldRef<"TestingAndScanningH", 'Int'>
    readonly amount: FieldRef<"TestingAndScanningH", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TestingAndScanningH findUnique
   */
  export type TestingAndScanningHFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningH to fetch.
     */
    where: TestingAndScanningHWhereUniqueInput
  }

  /**
   * TestingAndScanningH findUniqueOrThrow
   */
  export type TestingAndScanningHFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningH to fetch.
     */
    where: TestingAndScanningHWhereUniqueInput
  }

  /**
   * TestingAndScanningH findFirst
   */
  export type TestingAndScanningHFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningH to fetch.
     */
    where?: TestingAndScanningHWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningHS to fetch.
     */
    orderBy?: TestingAndScanningHOrderByWithRelationInput | TestingAndScanningHOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestingAndScanningHS.
     */
    cursor?: TestingAndScanningHWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningHS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningHS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestingAndScanningHS.
     */
    distinct?: TestingAndScanningHScalarFieldEnum | TestingAndScanningHScalarFieldEnum[]
  }

  /**
   * TestingAndScanningH findFirstOrThrow
   */
  export type TestingAndScanningHFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningH to fetch.
     */
    where?: TestingAndScanningHWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningHS to fetch.
     */
    orderBy?: TestingAndScanningHOrderByWithRelationInput | TestingAndScanningHOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestingAndScanningHS.
     */
    cursor?: TestingAndScanningHWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningHS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningHS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestingAndScanningHS.
     */
    distinct?: TestingAndScanningHScalarFieldEnum | TestingAndScanningHScalarFieldEnum[]
  }

  /**
   * TestingAndScanningH findMany
   */
  export type TestingAndScanningHFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningHS to fetch.
     */
    where?: TestingAndScanningHWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningHS to fetch.
     */
    orderBy?: TestingAndScanningHOrderByWithRelationInput | TestingAndScanningHOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestingAndScanningHS.
     */
    cursor?: TestingAndScanningHWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningHS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningHS.
     */
    skip?: number
    distinct?: TestingAndScanningHScalarFieldEnum | TestingAndScanningHScalarFieldEnum[]
  }

  /**
   * TestingAndScanningH create
   */
  export type TestingAndScanningHCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * The data needed to create a TestingAndScanningH.
     */
    data: XOR<TestingAndScanningHCreateInput, TestingAndScanningHUncheckedCreateInput>
  }

  /**
   * TestingAndScanningH createMany
   */
  export type TestingAndScanningHCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestingAndScanningHS.
     */
    data: TestingAndScanningHCreateManyInput | TestingAndScanningHCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestingAndScanningH update
   */
  export type TestingAndScanningHUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * The data needed to update a TestingAndScanningH.
     */
    data: XOR<TestingAndScanningHUpdateInput, TestingAndScanningHUncheckedUpdateInput>
    /**
     * Choose, which TestingAndScanningH to update.
     */
    where: TestingAndScanningHWhereUniqueInput
  }

  /**
   * TestingAndScanningH updateMany
   */
  export type TestingAndScanningHUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestingAndScanningHS.
     */
    data: XOR<TestingAndScanningHUpdateManyMutationInput, TestingAndScanningHUncheckedUpdateManyInput>
    /**
     * Filter which TestingAndScanningHS to update
     */
    where?: TestingAndScanningHWhereInput
    /**
     * Limit how many TestingAndScanningHS to update.
     */
    limit?: number
  }

  /**
   * TestingAndScanningH upsert
   */
  export type TestingAndScanningHUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * The filter to search for the TestingAndScanningH to update in case it exists.
     */
    where: TestingAndScanningHWhereUniqueInput
    /**
     * In case the TestingAndScanningH found by the `where` argument doesn't exist, create a new TestingAndScanningH with this data.
     */
    create: XOR<TestingAndScanningHCreateInput, TestingAndScanningHUncheckedCreateInput>
    /**
     * In case the TestingAndScanningH was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestingAndScanningHUpdateInput, TestingAndScanningHUncheckedUpdateInput>
  }

  /**
   * TestingAndScanningH delete
   */
  export type TestingAndScanningHDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
    /**
     * Filter which TestingAndScanningH to delete.
     */
    where: TestingAndScanningHWhereUniqueInput
  }

  /**
   * TestingAndScanningH deleteMany
   */
  export type TestingAndScanningHDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestingAndScanningHS to delete
     */
    where?: TestingAndScanningHWhereInput
    /**
     * Limit how many TestingAndScanningHS to delete.
     */
    limit?: number
  }

  /**
   * TestingAndScanningH without action
   */
  export type TestingAndScanningHDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningH
     */
    select?: TestingAndScanningHSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningH
     */
    omit?: TestingAndScanningHOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningHInclude<ExtArgs> | null
  }


  /**
   * Model MedicineAndInjection
   */

  export type AggregateMedicineAndInjection = {
    _count: MedicineAndInjectionCountAggregateOutputType | null
    _avg: MedicineAndInjectionAvgAggregateOutputType | null
    _sum: MedicineAndInjectionSumAggregateOutputType | null
    _min: MedicineAndInjectionMinAggregateOutputType | null
    _max: MedicineAndInjectionMaxAggregateOutputType | null
  }

  export type MedicineAndInjectionAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
  }

  export type MedicineAndInjectionSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
  }

  export type MedicineAndInjectionMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    status: string | null
    paymentStatus: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineAndInjectionMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    status: string | null
    paymentStatus: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineAndInjectionCountAggregateOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: number
    staff_Id: number
    medicine_Id: number
    frequencyMedicine: number
    injection_Id: number
    frequencyInjection: number
    status: number
    notes: number
    paymentStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineAndInjectionAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
  }

  export type MedicineAndInjectionSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
  }

  export type MedicineAndInjectionMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineAndInjectionMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    status?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineAndInjectionCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    staff_Id?: true
    medicine_Id?: true
    frequencyMedicine?: true
    injection_Id?: true
    frequencyInjection?: true
    status?: true
    notes?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineAndInjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineAndInjection to aggregate.
     */
    where?: MedicineAndInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineAndInjections to fetch.
     */
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineAndInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineAndInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineAndInjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineAndInjections
    **/
    _count?: true | MedicineAndInjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineAndInjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineAndInjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineAndInjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineAndInjectionMaxAggregateInputType
  }

  export type GetMedicineAndInjectionAggregateType<T extends MedicineAndInjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineAndInjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineAndInjection[P]>
      : GetScalarType<T[P], AggregateMedicineAndInjection[P]>
  }




  export type MedicineAndInjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineAndInjectionWhereInput
    orderBy?: MedicineAndInjectionOrderByWithAggregationInput | MedicineAndInjectionOrderByWithAggregationInput[]
    by: MedicineAndInjectionScalarFieldEnum[] | MedicineAndInjectionScalarFieldEnum
    having?: MedicineAndInjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineAndInjectionCountAggregateInputType | true
    _avg?: MedicineAndInjectionAvgAggregateInputType
    _sum?: MedicineAndInjectionSumAggregateInputType
    _min?: MedicineAndInjectionMinAggregateInputType
    _max?: MedicineAndInjectionMaxAggregateInputType
  }

  export type MedicineAndInjectionGroupByOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonValue
    staff_Id: JsonValue
    medicine_Id: JsonValue
    frequencyMedicine: JsonValue
    injection_Id: JsonValue
    frequencyInjection: JsonValue
    status: string
    notes: JsonValue
    paymentStatus: boolean
    createdAt: Date
    updatedAt: Date
    _count: MedicineAndInjectionCountAggregateOutputType | null
    _avg: MedicineAndInjectionAvgAggregateOutputType | null
    _sum: MedicineAndInjectionSumAggregateOutputType | null
    _min: MedicineAndInjectionMinAggregateOutputType | null
    _max: MedicineAndInjectionMaxAggregateOutputType | null
  }

  type GetMedicineAndInjectionGroupByPayload<T extends MedicineAndInjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineAndInjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineAndInjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineAndInjectionGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineAndInjectionGroupByOutputType[P]>
        }
      >
    >


  export type MedicineAndInjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    staff_Id?: boolean
    medicine_Id?: boolean
    frequencyMedicine?: boolean
    injection_Id?: boolean
    frequencyInjection?: boolean
    status?: boolean
    notes?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
    Medician?: boolean | MedicineAndInjection$MedicianArgs<ExtArgs>
    Injection?: boolean | MedicineAndInjection$InjectionArgs<ExtArgs>
    _count?: boolean | MedicineAndInjectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineAndInjection"]>



  export type MedicineAndInjectionSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    staff_Id?: boolean
    medicine_Id?: boolean
    frequencyMedicine?: boolean
    injection_Id?: boolean
    frequencyInjection?: boolean
    status?: boolean
    notes?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineAndInjectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "patient_Id" | "doctor_Id" | "staff_Id" | "medicine_Id" | "frequencyMedicine" | "injection_Id" | "frequencyInjection" | "status" | "notes" | "paymentStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["medicineAndInjection"]>
  export type MedicineAndInjectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
    Medician?: boolean | MedicineAndInjection$MedicianArgs<ExtArgs>
    Injection?: boolean | MedicineAndInjection$InjectionArgs<ExtArgs>
    _count?: boolean | MedicineAndInjectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicineAndInjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineAndInjection"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      Patient: Prisma.$PatientPayload<ExtArgs>
      Medician: Prisma.$MedicianPayload<ExtArgs>[]
      Injection: Prisma.$InjectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      patient_Id: number
      doctor_Id: Prisma.JsonValue
      staff_Id: Prisma.JsonValue
      medicine_Id: Prisma.JsonValue
      frequencyMedicine: Prisma.JsonValue
      injection_Id: Prisma.JsonValue
      frequencyInjection: Prisma.JsonValue
      status: string
      notes: Prisma.JsonValue
      paymentStatus: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineAndInjection"]>
    composites: {}
  }

  type MedicineAndInjectionGetPayload<S extends boolean | null | undefined | MedicineAndInjectionDefaultArgs> = $Result.GetResult<Prisma.$MedicineAndInjectionPayload, S>

  type MedicineAndInjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineAndInjectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineAndInjectionCountAggregateInputType | true
    }

  export interface MedicineAndInjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineAndInjection'], meta: { name: 'MedicineAndInjection' } }
    /**
     * Find zero or one MedicineAndInjection that matches the filter.
     * @param {MedicineAndInjectionFindUniqueArgs} args - Arguments to find a MedicineAndInjection
     * @example
     * // Get one MedicineAndInjection
     * const medicineAndInjection = await prisma.medicineAndInjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineAndInjectionFindUniqueArgs>(args: SelectSubset<T, MedicineAndInjectionFindUniqueArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicineAndInjection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineAndInjectionFindUniqueOrThrowArgs} args - Arguments to find a MedicineAndInjection
     * @example
     * // Get one MedicineAndInjection
     * const medicineAndInjection = await prisma.medicineAndInjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineAndInjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineAndInjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineAndInjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionFindFirstArgs} args - Arguments to find a MedicineAndInjection
     * @example
     * // Get one MedicineAndInjection
     * const medicineAndInjection = await prisma.medicineAndInjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineAndInjectionFindFirstArgs>(args?: SelectSubset<T, MedicineAndInjectionFindFirstArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicineAndInjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionFindFirstOrThrowArgs} args - Arguments to find a MedicineAndInjection
     * @example
     * // Get one MedicineAndInjection
     * const medicineAndInjection = await prisma.medicineAndInjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineAndInjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineAndInjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicineAndInjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineAndInjections
     * const medicineAndInjections = await prisma.medicineAndInjection.findMany()
     * 
     * // Get first 10 MedicineAndInjections
     * const medicineAndInjections = await prisma.medicineAndInjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineAndInjectionWithIdOnly = await prisma.medicineAndInjection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineAndInjectionFindManyArgs>(args?: SelectSubset<T, MedicineAndInjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicineAndInjection.
     * @param {MedicineAndInjectionCreateArgs} args - Arguments to create a MedicineAndInjection.
     * @example
     * // Create one MedicineAndInjection
     * const MedicineAndInjection = await prisma.medicineAndInjection.create({
     *   data: {
     *     // ... data to create a MedicineAndInjection
     *   }
     * })
     * 
     */
    create<T extends MedicineAndInjectionCreateArgs>(args: SelectSubset<T, MedicineAndInjectionCreateArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicineAndInjections.
     * @param {MedicineAndInjectionCreateManyArgs} args - Arguments to create many MedicineAndInjections.
     * @example
     * // Create many MedicineAndInjections
     * const medicineAndInjection = await prisma.medicineAndInjection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineAndInjectionCreateManyArgs>(args?: SelectSubset<T, MedicineAndInjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicineAndInjection.
     * @param {MedicineAndInjectionDeleteArgs} args - Arguments to delete one MedicineAndInjection.
     * @example
     * // Delete one MedicineAndInjection
     * const MedicineAndInjection = await prisma.medicineAndInjection.delete({
     *   where: {
     *     // ... filter to delete one MedicineAndInjection
     *   }
     * })
     * 
     */
    delete<T extends MedicineAndInjectionDeleteArgs>(args: SelectSubset<T, MedicineAndInjectionDeleteArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicineAndInjection.
     * @param {MedicineAndInjectionUpdateArgs} args - Arguments to update one MedicineAndInjection.
     * @example
     * // Update one MedicineAndInjection
     * const medicineAndInjection = await prisma.medicineAndInjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineAndInjectionUpdateArgs>(args: SelectSubset<T, MedicineAndInjectionUpdateArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicineAndInjections.
     * @param {MedicineAndInjectionDeleteManyArgs} args - Arguments to filter MedicineAndInjections to delete.
     * @example
     * // Delete a few MedicineAndInjections
     * const { count } = await prisma.medicineAndInjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineAndInjectionDeleteManyArgs>(args?: SelectSubset<T, MedicineAndInjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineAndInjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineAndInjections
     * const medicineAndInjection = await prisma.medicineAndInjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineAndInjectionUpdateManyArgs>(args: SelectSubset<T, MedicineAndInjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicineAndInjection.
     * @param {MedicineAndInjectionUpsertArgs} args - Arguments to update or create a MedicineAndInjection.
     * @example
     * // Update or create a MedicineAndInjection
     * const medicineAndInjection = await prisma.medicineAndInjection.upsert({
     *   create: {
     *     // ... data to create a MedicineAndInjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineAndInjection we want to update
     *   }
     * })
     */
    upsert<T extends MedicineAndInjectionUpsertArgs>(args: SelectSubset<T, MedicineAndInjectionUpsertArgs<ExtArgs>>): Prisma__MedicineAndInjectionClient<$Result.GetResult<Prisma.$MedicineAndInjectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicineAndInjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionCountArgs} args - Arguments to filter MedicineAndInjections to count.
     * @example
     * // Count the number of MedicineAndInjections
     * const count = await prisma.medicineAndInjection.count({
     *   where: {
     *     // ... the filter for the MedicineAndInjections we want to count
     *   }
     * })
    **/
    count<T extends MedicineAndInjectionCountArgs>(
      args?: Subset<T, MedicineAndInjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineAndInjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineAndInjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineAndInjectionAggregateArgs>(args: Subset<T, MedicineAndInjectionAggregateArgs>): Prisma.PrismaPromise<GetMedicineAndInjectionAggregateType<T>>

    /**
     * Group by MedicineAndInjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAndInjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineAndInjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineAndInjectionGroupByArgs['orderBy'] }
        : { orderBy?: MedicineAndInjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineAndInjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineAndInjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineAndInjection model
   */
  readonly fields: MedicineAndInjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineAndInjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineAndInjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Medician<T extends MedicineAndInjection$MedicianArgs<ExtArgs> = {}>(args?: Subset<T, MedicineAndInjection$MedicianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Injection<T extends MedicineAndInjection$InjectionArgs<ExtArgs> = {}>(args?: Subset<T, MedicineAndInjection$InjectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineAndInjection model
   */
  interface MedicineAndInjectionFieldRefs {
    readonly id: FieldRef<"MedicineAndInjection", 'Int'>
    readonly hospital_Id: FieldRef<"MedicineAndInjection", 'Int'>
    readonly patient_Id: FieldRef<"MedicineAndInjection", 'Int'>
    readonly doctor_Id: FieldRef<"MedicineAndInjection", 'Json'>
    readonly staff_Id: FieldRef<"MedicineAndInjection", 'Json'>
    readonly medicine_Id: FieldRef<"MedicineAndInjection", 'Json'>
    readonly frequencyMedicine: FieldRef<"MedicineAndInjection", 'Json'>
    readonly injection_Id: FieldRef<"MedicineAndInjection", 'Json'>
    readonly frequencyInjection: FieldRef<"MedicineAndInjection", 'Json'>
    readonly status: FieldRef<"MedicineAndInjection", 'String'>
    readonly notes: FieldRef<"MedicineAndInjection", 'Json'>
    readonly paymentStatus: FieldRef<"MedicineAndInjection", 'Boolean'>
    readonly createdAt: FieldRef<"MedicineAndInjection", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineAndInjection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineAndInjection findUnique
   */
  export type MedicineAndInjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * Filter, which MedicineAndInjection to fetch.
     */
    where: MedicineAndInjectionWhereUniqueInput
  }

  /**
   * MedicineAndInjection findUniqueOrThrow
   */
  export type MedicineAndInjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * Filter, which MedicineAndInjection to fetch.
     */
    where: MedicineAndInjectionWhereUniqueInput
  }

  /**
   * MedicineAndInjection findFirst
   */
  export type MedicineAndInjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * Filter, which MedicineAndInjection to fetch.
     */
    where?: MedicineAndInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineAndInjections to fetch.
     */
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineAndInjections.
     */
    cursor?: MedicineAndInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineAndInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineAndInjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineAndInjections.
     */
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * MedicineAndInjection findFirstOrThrow
   */
  export type MedicineAndInjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * Filter, which MedicineAndInjection to fetch.
     */
    where?: MedicineAndInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineAndInjections to fetch.
     */
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineAndInjections.
     */
    cursor?: MedicineAndInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineAndInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineAndInjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineAndInjections.
     */
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * MedicineAndInjection findMany
   */
  export type MedicineAndInjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * Filter, which MedicineAndInjections to fetch.
     */
    where?: MedicineAndInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineAndInjections to fetch.
     */
    orderBy?: MedicineAndInjectionOrderByWithRelationInput | MedicineAndInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineAndInjections.
     */
    cursor?: MedicineAndInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineAndInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineAndInjections.
     */
    skip?: number
    distinct?: MedicineAndInjectionScalarFieldEnum | MedicineAndInjectionScalarFieldEnum[]
  }

  /**
   * MedicineAndInjection create
   */
  export type MedicineAndInjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineAndInjection.
     */
    data: XOR<MedicineAndInjectionCreateInput, MedicineAndInjectionUncheckedCreateInput>
  }

  /**
   * MedicineAndInjection createMany
   */
  export type MedicineAndInjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineAndInjections.
     */
    data: MedicineAndInjectionCreateManyInput | MedicineAndInjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineAndInjection update
   */
  export type MedicineAndInjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineAndInjection.
     */
    data: XOR<MedicineAndInjectionUpdateInput, MedicineAndInjectionUncheckedUpdateInput>
    /**
     * Choose, which MedicineAndInjection to update.
     */
    where: MedicineAndInjectionWhereUniqueInput
  }

  /**
   * MedicineAndInjection updateMany
   */
  export type MedicineAndInjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineAndInjections.
     */
    data: XOR<MedicineAndInjectionUpdateManyMutationInput, MedicineAndInjectionUncheckedUpdateManyInput>
    /**
     * Filter which MedicineAndInjections to update
     */
    where?: MedicineAndInjectionWhereInput
    /**
     * Limit how many MedicineAndInjections to update.
     */
    limit?: number
  }

  /**
   * MedicineAndInjection upsert
   */
  export type MedicineAndInjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineAndInjection to update in case it exists.
     */
    where: MedicineAndInjectionWhereUniqueInput
    /**
     * In case the MedicineAndInjection found by the `where` argument doesn't exist, create a new MedicineAndInjection with this data.
     */
    create: XOR<MedicineAndInjectionCreateInput, MedicineAndInjectionUncheckedCreateInput>
    /**
     * In case the MedicineAndInjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineAndInjectionUpdateInput, MedicineAndInjectionUncheckedUpdateInput>
  }

  /**
   * MedicineAndInjection delete
   */
  export type MedicineAndInjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
    /**
     * Filter which MedicineAndInjection to delete.
     */
    where: MedicineAndInjectionWhereUniqueInput
  }

  /**
   * MedicineAndInjection deleteMany
   */
  export type MedicineAndInjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineAndInjections to delete
     */
    where?: MedicineAndInjectionWhereInput
    /**
     * Limit how many MedicineAndInjections to delete.
     */
    limit?: number
  }

  /**
   * MedicineAndInjection.Medician
   */
  export type MedicineAndInjection$MedicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medician
     */
    select?: MedicianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medician
     */
    omit?: MedicianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicianInclude<ExtArgs> | null
    where?: MedicianWhereInput
    orderBy?: MedicianOrderByWithRelationInput | MedicianOrderByWithRelationInput[]
    cursor?: MedicianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicianScalarFieldEnum | MedicianScalarFieldEnum[]
  }

  /**
   * MedicineAndInjection.Injection
   */
  export type MedicineAndInjection$InjectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Injection
     */
    select?: InjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Injection
     */
    omit?: InjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InjectionInclude<ExtArgs> | null
    where?: InjectionWhereInput
    orderBy?: InjectionOrderByWithRelationInput | InjectionOrderByWithRelationInput[]
    cursor?: InjectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InjectionScalarFieldEnum | InjectionScalarFieldEnum[]
  }

  /**
   * MedicineAndInjection without action
   */
  export type MedicineAndInjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineAndInjection
     */
    select?: MedicineAndInjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineAndInjection
     */
    omit?: MedicineAndInjectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineAndInjectionInclude<ExtArgs> | null
  }


  /**
   * Model TestingAndScanningP
   */

  export type AggregateTestingAndScanningP = {
    _count: TestingAndScanningPCountAggregateOutputType | null
    _avg: TestingAndScanningPAvgAggregateOutputType | null
    _sum: TestingAndScanningPSumAggregateOutputType | null
    _min: TestingAndScanningPMinAggregateOutputType | null
    _max: TestingAndScanningPMaxAggregateOutputType | null
  }

  export type TestingAndScanningPAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
  }

  export type TestingAndScanningPSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
  }

  export type TestingAndScanningPMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    title: string | null
    scheduleDate: Date | null
    type: string | null
    status: string | null
    paymentStatus: boolean | null
    result: string | null
  }

  export type TestingAndScanningPMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    title: string | null
    scheduleDate: Date | null
    type: string | null
    status: string | null
    paymentStatus: boolean | null
    result: string | null
  }

  export type TestingAndScanningPCountAggregateOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: number
    staff_Id: number
    title: number
    scheduleDate: number
    type: number
    status: number
    paymentStatus: number
    result: number
    _all: number
  }


  export type TestingAndScanningPAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
  }

  export type TestingAndScanningPSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
  }

  export type TestingAndScanningPMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    title?: true
    scheduleDate?: true
    type?: true
    status?: true
    paymentStatus?: true
    result?: true
  }

  export type TestingAndScanningPMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    title?: true
    scheduleDate?: true
    type?: true
    status?: true
    paymentStatus?: true
    result?: true
  }

  export type TestingAndScanningPCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    doctor_Id?: true
    staff_Id?: true
    title?: true
    scheduleDate?: true
    type?: true
    status?: true
    paymentStatus?: true
    result?: true
    _all?: true
  }

  export type TestingAndScanningPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestingAndScanningP to aggregate.
     */
    where?: TestingAndScanningPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningPS to fetch.
     */
    orderBy?: TestingAndScanningPOrderByWithRelationInput | TestingAndScanningPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestingAndScanningPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestingAndScanningPS
    **/
    _count?: true | TestingAndScanningPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestingAndScanningPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestingAndScanningPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestingAndScanningPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestingAndScanningPMaxAggregateInputType
  }

  export type GetTestingAndScanningPAggregateType<T extends TestingAndScanningPAggregateArgs> = {
        [P in keyof T & keyof AggregateTestingAndScanningP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestingAndScanningP[P]>
      : GetScalarType<T[P], AggregateTestingAndScanningP[P]>
  }




  export type TestingAndScanningPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestingAndScanningPWhereInput
    orderBy?: TestingAndScanningPOrderByWithAggregationInput | TestingAndScanningPOrderByWithAggregationInput[]
    by: TestingAndScanningPScalarFieldEnum[] | TestingAndScanningPScalarFieldEnum
    having?: TestingAndScanningPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestingAndScanningPCountAggregateInputType | true
    _avg?: TestingAndScanningPAvgAggregateInputType
    _sum?: TestingAndScanningPSumAggregateInputType
    _min?: TestingAndScanningPMinAggregateInputType
    _max?: TestingAndScanningPMaxAggregateInputType
  }

  export type TestingAndScanningPGroupByOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonValue
    staff_Id: JsonValue
    title: string
    scheduleDate: Date
    type: string
    status: string
    paymentStatus: boolean
    result: string
    _count: TestingAndScanningPCountAggregateOutputType | null
    _avg: TestingAndScanningPAvgAggregateOutputType | null
    _sum: TestingAndScanningPSumAggregateOutputType | null
    _min: TestingAndScanningPMinAggregateOutputType | null
    _max: TestingAndScanningPMaxAggregateOutputType | null
  }

  type GetTestingAndScanningPGroupByPayload<T extends TestingAndScanningPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestingAndScanningPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestingAndScanningPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestingAndScanningPGroupByOutputType[P]>
            : GetScalarType<T[P], TestingAndScanningPGroupByOutputType[P]>
        }
      >
    >


  export type TestingAndScanningPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    staff_Id?: boolean
    title?: boolean
    scheduleDate?: boolean
    type?: boolean
    status?: boolean
    paymentStatus?: boolean
    result?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testingAndScanningP"]>



  export type TestingAndScanningPSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    doctor_Id?: boolean
    staff_Id?: boolean
    title?: boolean
    scheduleDate?: boolean
    type?: boolean
    status?: boolean
    paymentStatus?: boolean
    result?: boolean
  }

  export type TestingAndScanningPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "patient_Id" | "doctor_Id" | "staff_Id" | "title" | "scheduleDate" | "type" | "status" | "paymentStatus" | "result", ExtArgs["result"]["testingAndScanningP"]>
  export type TestingAndScanningPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $TestingAndScanningPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestingAndScanningP"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      Patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      patient_Id: number
      doctor_Id: Prisma.JsonValue
      staff_Id: Prisma.JsonValue
      title: string
      scheduleDate: Date
      type: string
      status: string
      paymentStatus: boolean
      result: string
    }, ExtArgs["result"]["testingAndScanningP"]>
    composites: {}
  }

  type TestingAndScanningPGetPayload<S extends boolean | null | undefined | TestingAndScanningPDefaultArgs> = $Result.GetResult<Prisma.$TestingAndScanningPPayload, S>

  type TestingAndScanningPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestingAndScanningPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestingAndScanningPCountAggregateInputType | true
    }

  export interface TestingAndScanningPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestingAndScanningP'], meta: { name: 'TestingAndScanningP' } }
    /**
     * Find zero or one TestingAndScanningP that matches the filter.
     * @param {TestingAndScanningPFindUniqueArgs} args - Arguments to find a TestingAndScanningP
     * @example
     * // Get one TestingAndScanningP
     * const testingAndScanningP = await prisma.testingAndScanningP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestingAndScanningPFindUniqueArgs>(args: SelectSubset<T, TestingAndScanningPFindUniqueArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestingAndScanningP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestingAndScanningPFindUniqueOrThrowArgs} args - Arguments to find a TestingAndScanningP
     * @example
     * // Get one TestingAndScanningP
     * const testingAndScanningP = await prisma.testingAndScanningP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestingAndScanningPFindUniqueOrThrowArgs>(args: SelectSubset<T, TestingAndScanningPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestingAndScanningP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPFindFirstArgs} args - Arguments to find a TestingAndScanningP
     * @example
     * // Get one TestingAndScanningP
     * const testingAndScanningP = await prisma.testingAndScanningP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestingAndScanningPFindFirstArgs>(args?: SelectSubset<T, TestingAndScanningPFindFirstArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestingAndScanningP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPFindFirstOrThrowArgs} args - Arguments to find a TestingAndScanningP
     * @example
     * // Get one TestingAndScanningP
     * const testingAndScanningP = await prisma.testingAndScanningP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestingAndScanningPFindFirstOrThrowArgs>(args?: SelectSubset<T, TestingAndScanningPFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestingAndScanningPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestingAndScanningPS
     * const testingAndScanningPS = await prisma.testingAndScanningP.findMany()
     * 
     * // Get first 10 TestingAndScanningPS
     * const testingAndScanningPS = await prisma.testingAndScanningP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testingAndScanningPWithIdOnly = await prisma.testingAndScanningP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestingAndScanningPFindManyArgs>(args?: SelectSubset<T, TestingAndScanningPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestingAndScanningP.
     * @param {TestingAndScanningPCreateArgs} args - Arguments to create a TestingAndScanningP.
     * @example
     * // Create one TestingAndScanningP
     * const TestingAndScanningP = await prisma.testingAndScanningP.create({
     *   data: {
     *     // ... data to create a TestingAndScanningP
     *   }
     * })
     * 
     */
    create<T extends TestingAndScanningPCreateArgs>(args: SelectSubset<T, TestingAndScanningPCreateArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestingAndScanningPS.
     * @param {TestingAndScanningPCreateManyArgs} args - Arguments to create many TestingAndScanningPS.
     * @example
     * // Create many TestingAndScanningPS
     * const testingAndScanningP = await prisma.testingAndScanningP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestingAndScanningPCreateManyArgs>(args?: SelectSubset<T, TestingAndScanningPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestingAndScanningP.
     * @param {TestingAndScanningPDeleteArgs} args - Arguments to delete one TestingAndScanningP.
     * @example
     * // Delete one TestingAndScanningP
     * const TestingAndScanningP = await prisma.testingAndScanningP.delete({
     *   where: {
     *     // ... filter to delete one TestingAndScanningP
     *   }
     * })
     * 
     */
    delete<T extends TestingAndScanningPDeleteArgs>(args: SelectSubset<T, TestingAndScanningPDeleteArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestingAndScanningP.
     * @param {TestingAndScanningPUpdateArgs} args - Arguments to update one TestingAndScanningP.
     * @example
     * // Update one TestingAndScanningP
     * const testingAndScanningP = await prisma.testingAndScanningP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestingAndScanningPUpdateArgs>(args: SelectSubset<T, TestingAndScanningPUpdateArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestingAndScanningPS.
     * @param {TestingAndScanningPDeleteManyArgs} args - Arguments to filter TestingAndScanningPS to delete.
     * @example
     * // Delete a few TestingAndScanningPS
     * const { count } = await prisma.testingAndScanningP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestingAndScanningPDeleteManyArgs>(args?: SelectSubset<T, TestingAndScanningPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestingAndScanningPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestingAndScanningPS
     * const testingAndScanningP = await prisma.testingAndScanningP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestingAndScanningPUpdateManyArgs>(args: SelectSubset<T, TestingAndScanningPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestingAndScanningP.
     * @param {TestingAndScanningPUpsertArgs} args - Arguments to update or create a TestingAndScanningP.
     * @example
     * // Update or create a TestingAndScanningP
     * const testingAndScanningP = await prisma.testingAndScanningP.upsert({
     *   create: {
     *     // ... data to create a TestingAndScanningP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestingAndScanningP we want to update
     *   }
     * })
     */
    upsert<T extends TestingAndScanningPUpsertArgs>(args: SelectSubset<T, TestingAndScanningPUpsertArgs<ExtArgs>>): Prisma__TestingAndScanningPClient<$Result.GetResult<Prisma.$TestingAndScanningPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestingAndScanningPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPCountArgs} args - Arguments to filter TestingAndScanningPS to count.
     * @example
     * // Count the number of TestingAndScanningPS
     * const count = await prisma.testingAndScanningP.count({
     *   where: {
     *     // ... the filter for the TestingAndScanningPS we want to count
     *   }
     * })
    **/
    count<T extends TestingAndScanningPCountArgs>(
      args?: Subset<T, TestingAndScanningPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestingAndScanningPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestingAndScanningP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestingAndScanningPAggregateArgs>(args: Subset<T, TestingAndScanningPAggregateArgs>): Prisma.PrismaPromise<GetTestingAndScanningPAggregateType<T>>

    /**
     * Group by TestingAndScanningP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestingAndScanningPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestingAndScanningPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestingAndScanningPGroupByArgs['orderBy'] }
        : { orderBy?: TestingAndScanningPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestingAndScanningPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestingAndScanningPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestingAndScanningP model
   */
  readonly fields: TestingAndScanningPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestingAndScanningP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestingAndScanningPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestingAndScanningP model
   */
  interface TestingAndScanningPFieldRefs {
    readonly id: FieldRef<"TestingAndScanningP", 'Int'>
    readonly hospital_Id: FieldRef<"TestingAndScanningP", 'Int'>
    readonly patient_Id: FieldRef<"TestingAndScanningP", 'Int'>
    readonly doctor_Id: FieldRef<"TestingAndScanningP", 'Json'>
    readonly staff_Id: FieldRef<"TestingAndScanningP", 'Json'>
    readonly title: FieldRef<"TestingAndScanningP", 'String'>
    readonly scheduleDate: FieldRef<"TestingAndScanningP", 'DateTime'>
    readonly type: FieldRef<"TestingAndScanningP", 'String'>
    readonly status: FieldRef<"TestingAndScanningP", 'String'>
    readonly paymentStatus: FieldRef<"TestingAndScanningP", 'Boolean'>
    readonly result: FieldRef<"TestingAndScanningP", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestingAndScanningP findUnique
   */
  export type TestingAndScanningPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningP to fetch.
     */
    where: TestingAndScanningPWhereUniqueInput
  }

  /**
   * TestingAndScanningP findUniqueOrThrow
   */
  export type TestingAndScanningPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningP to fetch.
     */
    where: TestingAndScanningPWhereUniqueInput
  }

  /**
   * TestingAndScanningP findFirst
   */
  export type TestingAndScanningPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningP to fetch.
     */
    where?: TestingAndScanningPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningPS to fetch.
     */
    orderBy?: TestingAndScanningPOrderByWithRelationInput | TestingAndScanningPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestingAndScanningPS.
     */
    cursor?: TestingAndScanningPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestingAndScanningPS.
     */
    distinct?: TestingAndScanningPScalarFieldEnum | TestingAndScanningPScalarFieldEnum[]
  }

  /**
   * TestingAndScanningP findFirstOrThrow
   */
  export type TestingAndScanningPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningP to fetch.
     */
    where?: TestingAndScanningPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningPS to fetch.
     */
    orderBy?: TestingAndScanningPOrderByWithRelationInput | TestingAndScanningPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestingAndScanningPS.
     */
    cursor?: TestingAndScanningPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestingAndScanningPS.
     */
    distinct?: TestingAndScanningPScalarFieldEnum | TestingAndScanningPScalarFieldEnum[]
  }

  /**
   * TestingAndScanningP findMany
   */
  export type TestingAndScanningPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * Filter, which TestingAndScanningPS to fetch.
     */
    where?: TestingAndScanningPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestingAndScanningPS to fetch.
     */
    orderBy?: TestingAndScanningPOrderByWithRelationInput | TestingAndScanningPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestingAndScanningPS.
     */
    cursor?: TestingAndScanningPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestingAndScanningPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestingAndScanningPS.
     */
    skip?: number
    distinct?: TestingAndScanningPScalarFieldEnum | TestingAndScanningPScalarFieldEnum[]
  }

  /**
   * TestingAndScanningP create
   */
  export type TestingAndScanningPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * The data needed to create a TestingAndScanningP.
     */
    data: XOR<TestingAndScanningPCreateInput, TestingAndScanningPUncheckedCreateInput>
  }

  /**
   * TestingAndScanningP createMany
   */
  export type TestingAndScanningPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestingAndScanningPS.
     */
    data: TestingAndScanningPCreateManyInput | TestingAndScanningPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestingAndScanningP update
   */
  export type TestingAndScanningPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * The data needed to update a TestingAndScanningP.
     */
    data: XOR<TestingAndScanningPUpdateInput, TestingAndScanningPUncheckedUpdateInput>
    /**
     * Choose, which TestingAndScanningP to update.
     */
    where: TestingAndScanningPWhereUniqueInput
  }

  /**
   * TestingAndScanningP updateMany
   */
  export type TestingAndScanningPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestingAndScanningPS.
     */
    data: XOR<TestingAndScanningPUpdateManyMutationInput, TestingAndScanningPUncheckedUpdateManyInput>
    /**
     * Filter which TestingAndScanningPS to update
     */
    where?: TestingAndScanningPWhereInput
    /**
     * Limit how many TestingAndScanningPS to update.
     */
    limit?: number
  }

  /**
   * TestingAndScanningP upsert
   */
  export type TestingAndScanningPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * The filter to search for the TestingAndScanningP to update in case it exists.
     */
    where: TestingAndScanningPWhereUniqueInput
    /**
     * In case the TestingAndScanningP found by the `where` argument doesn't exist, create a new TestingAndScanningP with this data.
     */
    create: XOR<TestingAndScanningPCreateInput, TestingAndScanningPUncheckedCreateInput>
    /**
     * In case the TestingAndScanningP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestingAndScanningPUpdateInput, TestingAndScanningPUncheckedUpdateInput>
  }

  /**
   * TestingAndScanningP delete
   */
  export type TestingAndScanningPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
    /**
     * Filter which TestingAndScanningP to delete.
     */
    where: TestingAndScanningPWhereUniqueInput
  }

  /**
   * TestingAndScanningP deleteMany
   */
  export type TestingAndScanningPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestingAndScanningPS to delete
     */
    where?: TestingAndScanningPWhereInput
    /**
     * Limit how many TestingAndScanningPS to delete.
     */
    limit?: number
  }

  /**
   * TestingAndScanningP without action
   */
  export type TestingAndScanningPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestingAndScanningP
     */
    select?: TestingAndScanningPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestingAndScanningP
     */
    omit?: TestingAndScanningPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestingAndScanningPInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    reason: string | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    patient_Id: number | null
    reason: string | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    reason: number
    status: number
    amount: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    reason?: true
    status?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    reason?: true
    status?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    patient_Id?: true
    reason?: true
    status?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    hospital_Id: number
    patient_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    reason?: boolean
    status?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    patient_Id?: boolean
    reason?: boolean
    status?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "patient_Id" | "reason" | "status" | "amount" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    Patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
      Patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      patient_Id: number
      reason: string
      status: $Enums.PaymentStatus
      amount: number
      transactionId: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly hospital_Id: FieldRef<"Payment", 'Int'>
    readonly patient_Id: FieldRef<"Payment", 'Int'>
    readonly reason: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly transactionId: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model RoomsAvailable
   */

  export type AggregateRoomsAvailable = {
    _count: RoomsAvailableCountAggregateOutputType | null
    _avg: RoomsAvailableAvgAggregateOutputType | null
    _sum: RoomsAvailableSumAggregateOutputType | null
    _min: RoomsAvailableMinAggregateOutputType | null
    _max: RoomsAvailableMaxAggregateOutputType | null
  }

  export type RoomsAvailableAvgAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    staffId: number | null
    capacity: number | null
    amount: number | null
  }

  export type RoomsAvailableSumAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    staffId: number | null
    capacity: number | null
    amount: number | null
  }

  export type RoomsAvailableMinAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    staffId: number | null
    roomNo: string | null
    capacity: number | null
    notes: string | null
    type: string | null
    amount: number | null
  }

  export type RoomsAvailableMaxAggregateOutputType = {
    id: number | null
    hospital_Id: number | null
    staffId: number | null
    roomNo: string | null
    capacity: number | null
    notes: string | null
    type: string | null
    amount: number | null
  }

  export type RoomsAvailableCountAggregateOutputType = {
    id: number
    hospital_Id: number
    staffId: number
    roomNo: number
    capacity: number
    notes: number
    type: number
    amount: number
    _all: number
  }


  export type RoomsAvailableAvgAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    capacity?: true
    amount?: true
  }

  export type RoomsAvailableSumAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    capacity?: true
    amount?: true
  }

  export type RoomsAvailableMinAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    roomNo?: true
    capacity?: true
    notes?: true
    type?: true
    amount?: true
  }

  export type RoomsAvailableMaxAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    roomNo?: true
    capacity?: true
    notes?: true
    type?: true
    amount?: true
  }

  export type RoomsAvailableCountAggregateInputType = {
    id?: true
    hospital_Id?: true
    staffId?: true
    roomNo?: true
    capacity?: true
    notes?: true
    type?: true
    amount?: true
    _all?: true
  }

  export type RoomsAvailableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomsAvailable to aggregate.
     */
    where?: RoomsAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomsAvailables to fetch.
     */
    orderBy?: RoomsAvailableOrderByWithRelationInput | RoomsAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomsAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomsAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomsAvailables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomsAvailables
    **/
    _count?: true | RoomsAvailableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomsAvailableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomsAvailableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomsAvailableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomsAvailableMaxAggregateInputType
  }

  export type GetRoomsAvailableAggregateType<T extends RoomsAvailableAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomsAvailable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomsAvailable[P]>
      : GetScalarType<T[P], AggregateRoomsAvailable[P]>
  }




  export type RoomsAvailableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomsAvailableWhereInput
    orderBy?: RoomsAvailableOrderByWithAggregationInput | RoomsAvailableOrderByWithAggregationInput[]
    by: RoomsAvailableScalarFieldEnum[] | RoomsAvailableScalarFieldEnum
    having?: RoomsAvailableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomsAvailableCountAggregateInputType | true
    _avg?: RoomsAvailableAvgAggregateInputType
    _sum?: RoomsAvailableSumAggregateInputType
    _min?: RoomsAvailableMinAggregateInputType
    _max?: RoomsAvailableMaxAggregateInputType
  }

  export type RoomsAvailableGroupByOutputType = {
    id: number
    hospital_Id: number
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
    _count: RoomsAvailableCountAggregateOutputType | null
    _avg: RoomsAvailableAvgAggregateOutputType | null
    _sum: RoomsAvailableSumAggregateOutputType | null
    _min: RoomsAvailableMinAggregateOutputType | null
    _max: RoomsAvailableMaxAggregateOutputType | null
  }

  type GetRoomsAvailableGroupByPayload<T extends RoomsAvailableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomsAvailableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomsAvailableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomsAvailableGroupByOutputType[P]>
            : GetScalarType<T[P], RoomsAvailableGroupByOutputType[P]>
        }
      >
    >


  export type RoomsAvailableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospital_Id?: boolean
    staffId?: boolean
    roomNo?: boolean
    capacity?: boolean
    notes?: boolean
    type?: boolean
    amount?: boolean
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomsAvailable"]>



  export type RoomsAvailableSelectScalar = {
    id?: boolean
    hospital_Id?: boolean
    staffId?: boolean
    roomNo?: boolean
    capacity?: boolean
    notes?: boolean
    type?: boolean
    amount?: boolean
  }

  export type RoomsAvailableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospital_Id" | "staffId" | "roomNo" | "capacity" | "notes" | "type" | "amount", ExtArgs["result"]["roomsAvailable"]>
  export type RoomsAvailableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }

  export type $RoomsAvailablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomsAvailable"
    objects: {
      Hospital: Prisma.$HospitalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hospital_Id: number
      staffId: number
      roomNo: string
      capacity: number
      notes: string
      type: string
      amount: number
    }, ExtArgs["result"]["roomsAvailable"]>
    composites: {}
  }

  type RoomsAvailableGetPayload<S extends boolean | null | undefined | RoomsAvailableDefaultArgs> = $Result.GetResult<Prisma.$RoomsAvailablePayload, S>

  type RoomsAvailableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomsAvailableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomsAvailableCountAggregateInputType | true
    }

  export interface RoomsAvailableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomsAvailable'], meta: { name: 'RoomsAvailable' } }
    /**
     * Find zero or one RoomsAvailable that matches the filter.
     * @param {RoomsAvailableFindUniqueArgs} args - Arguments to find a RoomsAvailable
     * @example
     * // Get one RoomsAvailable
     * const roomsAvailable = await prisma.roomsAvailable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomsAvailableFindUniqueArgs>(args: SelectSubset<T, RoomsAvailableFindUniqueArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomsAvailable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomsAvailableFindUniqueOrThrowArgs} args - Arguments to find a RoomsAvailable
     * @example
     * // Get one RoomsAvailable
     * const roomsAvailable = await prisma.roomsAvailable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomsAvailableFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomsAvailableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomsAvailable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableFindFirstArgs} args - Arguments to find a RoomsAvailable
     * @example
     * // Get one RoomsAvailable
     * const roomsAvailable = await prisma.roomsAvailable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomsAvailableFindFirstArgs>(args?: SelectSubset<T, RoomsAvailableFindFirstArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomsAvailable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableFindFirstOrThrowArgs} args - Arguments to find a RoomsAvailable
     * @example
     * // Get one RoomsAvailable
     * const roomsAvailable = await prisma.roomsAvailable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomsAvailableFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomsAvailableFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomsAvailables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomsAvailables
     * const roomsAvailables = await prisma.roomsAvailable.findMany()
     * 
     * // Get first 10 RoomsAvailables
     * const roomsAvailables = await prisma.roomsAvailable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomsAvailableWithIdOnly = await prisma.roomsAvailable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomsAvailableFindManyArgs>(args?: SelectSubset<T, RoomsAvailableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomsAvailable.
     * @param {RoomsAvailableCreateArgs} args - Arguments to create a RoomsAvailable.
     * @example
     * // Create one RoomsAvailable
     * const RoomsAvailable = await prisma.roomsAvailable.create({
     *   data: {
     *     // ... data to create a RoomsAvailable
     *   }
     * })
     * 
     */
    create<T extends RoomsAvailableCreateArgs>(args: SelectSubset<T, RoomsAvailableCreateArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomsAvailables.
     * @param {RoomsAvailableCreateManyArgs} args - Arguments to create many RoomsAvailables.
     * @example
     * // Create many RoomsAvailables
     * const roomsAvailable = await prisma.roomsAvailable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomsAvailableCreateManyArgs>(args?: SelectSubset<T, RoomsAvailableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomsAvailable.
     * @param {RoomsAvailableDeleteArgs} args - Arguments to delete one RoomsAvailable.
     * @example
     * // Delete one RoomsAvailable
     * const RoomsAvailable = await prisma.roomsAvailable.delete({
     *   where: {
     *     // ... filter to delete one RoomsAvailable
     *   }
     * })
     * 
     */
    delete<T extends RoomsAvailableDeleteArgs>(args: SelectSubset<T, RoomsAvailableDeleteArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomsAvailable.
     * @param {RoomsAvailableUpdateArgs} args - Arguments to update one RoomsAvailable.
     * @example
     * // Update one RoomsAvailable
     * const roomsAvailable = await prisma.roomsAvailable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomsAvailableUpdateArgs>(args: SelectSubset<T, RoomsAvailableUpdateArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomsAvailables.
     * @param {RoomsAvailableDeleteManyArgs} args - Arguments to filter RoomsAvailables to delete.
     * @example
     * // Delete a few RoomsAvailables
     * const { count } = await prisma.roomsAvailable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomsAvailableDeleteManyArgs>(args?: SelectSubset<T, RoomsAvailableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomsAvailables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomsAvailables
     * const roomsAvailable = await prisma.roomsAvailable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomsAvailableUpdateManyArgs>(args: SelectSubset<T, RoomsAvailableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomsAvailable.
     * @param {RoomsAvailableUpsertArgs} args - Arguments to update or create a RoomsAvailable.
     * @example
     * // Update or create a RoomsAvailable
     * const roomsAvailable = await prisma.roomsAvailable.upsert({
     *   create: {
     *     // ... data to create a RoomsAvailable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomsAvailable we want to update
     *   }
     * })
     */
    upsert<T extends RoomsAvailableUpsertArgs>(args: SelectSubset<T, RoomsAvailableUpsertArgs<ExtArgs>>): Prisma__RoomsAvailableClient<$Result.GetResult<Prisma.$RoomsAvailablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomsAvailables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableCountArgs} args - Arguments to filter RoomsAvailables to count.
     * @example
     * // Count the number of RoomsAvailables
     * const count = await prisma.roomsAvailable.count({
     *   where: {
     *     // ... the filter for the RoomsAvailables we want to count
     *   }
     * })
    **/
    count<T extends RoomsAvailableCountArgs>(
      args?: Subset<T, RoomsAvailableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomsAvailableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomsAvailable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomsAvailableAggregateArgs>(args: Subset<T, RoomsAvailableAggregateArgs>): Prisma.PrismaPromise<GetRoomsAvailableAggregateType<T>>

    /**
     * Group by RoomsAvailable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAvailableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomsAvailableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomsAvailableGroupByArgs['orderBy'] }
        : { orderBy?: RoomsAvailableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomsAvailableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomsAvailableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomsAvailable model
   */
  readonly fields: RoomsAvailableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomsAvailable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomsAvailableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomsAvailable model
   */
  interface RoomsAvailableFieldRefs {
    readonly id: FieldRef<"RoomsAvailable", 'Int'>
    readonly hospital_Id: FieldRef<"RoomsAvailable", 'Int'>
    readonly staffId: FieldRef<"RoomsAvailable", 'Int'>
    readonly roomNo: FieldRef<"RoomsAvailable", 'String'>
    readonly capacity: FieldRef<"RoomsAvailable", 'Int'>
    readonly notes: FieldRef<"RoomsAvailable", 'String'>
    readonly type: FieldRef<"RoomsAvailable", 'String'>
    readonly amount: FieldRef<"RoomsAvailable", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RoomsAvailable findUnique
   */
  export type RoomsAvailableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * Filter, which RoomsAvailable to fetch.
     */
    where: RoomsAvailableWhereUniqueInput
  }

  /**
   * RoomsAvailable findUniqueOrThrow
   */
  export type RoomsAvailableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * Filter, which RoomsAvailable to fetch.
     */
    where: RoomsAvailableWhereUniqueInput
  }

  /**
   * RoomsAvailable findFirst
   */
  export type RoomsAvailableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * Filter, which RoomsAvailable to fetch.
     */
    where?: RoomsAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomsAvailables to fetch.
     */
    orderBy?: RoomsAvailableOrderByWithRelationInput | RoomsAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomsAvailables.
     */
    cursor?: RoomsAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomsAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomsAvailables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomsAvailables.
     */
    distinct?: RoomsAvailableScalarFieldEnum | RoomsAvailableScalarFieldEnum[]
  }

  /**
   * RoomsAvailable findFirstOrThrow
   */
  export type RoomsAvailableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * Filter, which RoomsAvailable to fetch.
     */
    where?: RoomsAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomsAvailables to fetch.
     */
    orderBy?: RoomsAvailableOrderByWithRelationInput | RoomsAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomsAvailables.
     */
    cursor?: RoomsAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomsAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomsAvailables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomsAvailables.
     */
    distinct?: RoomsAvailableScalarFieldEnum | RoomsAvailableScalarFieldEnum[]
  }

  /**
   * RoomsAvailable findMany
   */
  export type RoomsAvailableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * Filter, which RoomsAvailables to fetch.
     */
    where?: RoomsAvailableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomsAvailables to fetch.
     */
    orderBy?: RoomsAvailableOrderByWithRelationInput | RoomsAvailableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomsAvailables.
     */
    cursor?: RoomsAvailableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomsAvailables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomsAvailables.
     */
    skip?: number
    distinct?: RoomsAvailableScalarFieldEnum | RoomsAvailableScalarFieldEnum[]
  }

  /**
   * RoomsAvailable create
   */
  export type RoomsAvailableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomsAvailable.
     */
    data: XOR<RoomsAvailableCreateInput, RoomsAvailableUncheckedCreateInput>
  }

  /**
   * RoomsAvailable createMany
   */
  export type RoomsAvailableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomsAvailables.
     */
    data: RoomsAvailableCreateManyInput | RoomsAvailableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomsAvailable update
   */
  export type RoomsAvailableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomsAvailable.
     */
    data: XOR<RoomsAvailableUpdateInput, RoomsAvailableUncheckedUpdateInput>
    /**
     * Choose, which RoomsAvailable to update.
     */
    where: RoomsAvailableWhereUniqueInput
  }

  /**
   * RoomsAvailable updateMany
   */
  export type RoomsAvailableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomsAvailables.
     */
    data: XOR<RoomsAvailableUpdateManyMutationInput, RoomsAvailableUncheckedUpdateManyInput>
    /**
     * Filter which RoomsAvailables to update
     */
    where?: RoomsAvailableWhereInput
    /**
     * Limit how many RoomsAvailables to update.
     */
    limit?: number
  }

  /**
   * RoomsAvailable upsert
   */
  export type RoomsAvailableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomsAvailable to update in case it exists.
     */
    where: RoomsAvailableWhereUniqueInput
    /**
     * In case the RoomsAvailable found by the `where` argument doesn't exist, create a new RoomsAvailable with this data.
     */
    create: XOR<RoomsAvailableCreateInput, RoomsAvailableUncheckedCreateInput>
    /**
     * In case the RoomsAvailable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomsAvailableUpdateInput, RoomsAvailableUncheckedUpdateInput>
  }

  /**
   * RoomsAvailable delete
   */
  export type RoomsAvailableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
    /**
     * Filter which RoomsAvailable to delete.
     */
    where: RoomsAvailableWhereUniqueInput
  }

  /**
   * RoomsAvailable deleteMany
   */
  export type RoomsAvailableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomsAvailables to delete
     */
    where?: RoomsAvailableWhereInput
    /**
     * Limit how many RoomsAvailables to delete.
     */
    limit?: number
  }

  /**
   * RoomsAvailable without action
   */
  export type RoomsAvailableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomsAvailable
     */
    select?: RoomsAvailableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomsAvailable
     */
    omit?: RoomsAvailableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomsAvailableInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const HospitalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    photo: 'photo',
    HospitalStatus: 'HospitalStatus',
    phone: 'phone',
    mail: 'mail'
  };

  export type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    user_Id: 'user_Id',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    user_Id: 'user_Id',
    destination: 'destination',
    phone: 'phone',
    email: 'email',
    address: 'address',
    photo: 'photo',
    name: 'name',
    status: 'status',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AdminStratorScalarFieldEnum: {
    id: 'id',
    user_Id: 'user_Id',
    name: 'name',
    status: 'status',
    destination: 'destination',
    phone: 'phone',
    email: 'email',
    photo: 'photo',
    address: 'address',
    gender: 'gender'
  };

  export type AdminStratorScalarFieldEnum = (typeof AdminStratorScalarFieldEnum)[keyof typeof AdminStratorScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    user_Id: 'user_Id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    photo: 'photo',
    status: 'status',
    address: 'address',
    dob: 'dob',
    gender: 'gender',
    bldGrp: 'bldGrp',
    currentProblem: 'currentProblem',
    medicalHistory: 'medicalHistory',
    height: 'height',
    weight: 'weight',
    bp: 'bp',
    sugar: 'sugar',
    custom: 'custom',
    tempCreatedAt: 'tempCreatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const ConsultationScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    patient_Id: 'patient_Id',
    doctor_Id: 'doctor_Id',
    date: 'date',
    purpose: 'purpose',
    temperature: 'temperature',
    symptoms: 'symptoms',
    notes: 'notes',
    diagnosis: 'diagnosis',
    treatment: 'treatment',
    medicineInjection: 'medicineInjection',
    scanningTesting: 'scanningTesting',
    status: 'status',
    access: 'access',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentStatus: 'paymentStatus'
  };

  export type ConsultationScalarFieldEnum = (typeof ConsultationScalarFieldEnum)[keyof typeof ConsultationScalarFieldEnum]


  export const TreatmentScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    staff_Id: 'staff_Id',
    patient_Id: 'patient_Id',
    doctor_Id: 'doctor_Id',
    treatmentName: 'treatmentName',
    startDate: 'startDate',
    endDate: 'endDate',
    progress: 'progress',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentStatus: 'paymentStatus'
  };

  export type TreatmentScalarFieldEnum = (typeof TreatmentScalarFieldEnum)[keyof typeof TreatmentScalarFieldEnum]


  export const MedicianScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    medicianName: 'medicianName',
    stock: 'stock',
    amount: 'amount',
    staffId: 'staffId'
  };

  export type MedicianScalarFieldEnum = (typeof MedicianScalarFieldEnum)[keyof typeof MedicianScalarFieldEnum]


  export const InjectionScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    injectionName: 'injectionName',
    stock: 'stock',
    amount: 'amount',
    staffId: 'staffId'
  };

  export type InjectionScalarFieldEnum = (typeof InjectionScalarFieldEnum)[keyof typeof InjectionScalarFieldEnum]


  export const TestingAndScanningHScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    type: 'type',
    status: 'status',
    roomNo: 'roomNo',
    staffId: 'staffId',
    amount: 'amount'
  };

  export type TestingAndScanningHScalarFieldEnum = (typeof TestingAndScanningHScalarFieldEnum)[keyof typeof TestingAndScanningHScalarFieldEnum]


  export const MedicineAndInjectionScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    patient_Id: 'patient_Id',
    doctor_Id: 'doctor_Id',
    staff_Id: 'staff_Id',
    medicine_Id: 'medicine_Id',
    frequencyMedicine: 'frequencyMedicine',
    injection_Id: 'injection_Id',
    frequencyInjection: 'frequencyInjection',
    status: 'status',
    notes: 'notes',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineAndInjectionScalarFieldEnum = (typeof MedicineAndInjectionScalarFieldEnum)[keyof typeof MedicineAndInjectionScalarFieldEnum]


  export const TestingAndScanningPScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    patient_Id: 'patient_Id',
    doctor_Id: 'doctor_Id',
    staff_Id: 'staff_Id',
    title: 'title',
    scheduleDate: 'scheduleDate',
    type: 'type',
    status: 'status',
    paymentStatus: 'paymentStatus',
    result: 'result'
  };

  export type TestingAndScanningPScalarFieldEnum = (typeof TestingAndScanningPScalarFieldEnum)[keyof typeof TestingAndScanningPScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    patient_Id: 'patient_Id',
    reason: 'reason',
    status: 'status',
    amount: 'amount',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RoomsAvailableScalarFieldEnum: {
    id: 'id',
    hospital_Id: 'hospital_Id',
    staffId: 'staffId',
    roomNo: 'roomNo',
    capacity: 'capacity',
    notes: 'notes',
    type: 'type',
    amount: 'amount'
  };

  export type RoomsAvailableScalarFieldEnum = (typeof RoomsAvailableScalarFieldEnum)[keyof typeof RoomsAvailableScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const HospitalOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    photo: 'photo',
    phone: 'phone',
    mail: 'mail'
  };

  export type HospitalOrderByRelevanceFieldEnum = (typeof HospitalOrderByRelevanceFieldEnum)[keyof typeof HospitalOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    password: 'password',
    role: 'role'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AdminOrderByRelevanceFieldEnum: {
    destination: 'destination',
    phone: 'phone',
    email: 'email',
    address: 'address',
    photo: 'photo',
    name: 'name',
    status: 'status',
    gender: 'gender'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const AdminStratorOrderByRelevanceFieldEnum: {
    name: 'name',
    status: 'status',
    destination: 'destination',
    phone: 'phone',
    email: 'email',
    photo: 'photo',
    address: 'address',
    gender: 'gender'
  };

  export type AdminStratorOrderByRelevanceFieldEnum = (typeof AdminStratorOrderByRelevanceFieldEnum)[keyof typeof AdminStratorOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const PatientOrderByRelevanceFieldEnum: {
    name: 'name',
    photo: 'photo',
    status: 'status',
    gender: 'gender',
    bldGrp: 'bldGrp',
    currentProblem: 'currentProblem',
    medicalHistory: 'medicalHistory',
    bp: 'bp',
    sugar: 'sugar'
  };

  export type PatientOrderByRelevanceFieldEnum = (typeof PatientOrderByRelevanceFieldEnum)[keyof typeof PatientOrderByRelevanceFieldEnum]


  export const ConsultationOrderByRelevanceFieldEnum: {
    purpose: 'purpose',
    symptoms: 'symptoms',
    diagnosis: 'diagnosis',
    status: 'status'
  };

  export type ConsultationOrderByRelevanceFieldEnum = (typeof ConsultationOrderByRelevanceFieldEnum)[keyof typeof ConsultationOrderByRelevanceFieldEnum]


  export const TreatmentOrderByRelevanceFieldEnum: {
    progress: 'progress',
    status: 'status'
  };

  export type TreatmentOrderByRelevanceFieldEnum = (typeof TreatmentOrderByRelevanceFieldEnum)[keyof typeof TreatmentOrderByRelevanceFieldEnum]


  export const MedicianOrderByRelevanceFieldEnum: {
    medicianName: 'medicianName'
  };

  export type MedicianOrderByRelevanceFieldEnum = (typeof MedicianOrderByRelevanceFieldEnum)[keyof typeof MedicianOrderByRelevanceFieldEnum]


  export const InjectionOrderByRelevanceFieldEnum: {
    injectionName: 'injectionName'
  };

  export type InjectionOrderByRelevanceFieldEnum = (typeof InjectionOrderByRelevanceFieldEnum)[keyof typeof InjectionOrderByRelevanceFieldEnum]


  export const TestingAndScanningHOrderByRelevanceFieldEnum: {
    type: 'type',
    status: 'status',
    roomNo: 'roomNo'
  };

  export type TestingAndScanningHOrderByRelevanceFieldEnum = (typeof TestingAndScanningHOrderByRelevanceFieldEnum)[keyof typeof TestingAndScanningHOrderByRelevanceFieldEnum]


  export const MedicineAndInjectionOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type MedicineAndInjectionOrderByRelevanceFieldEnum = (typeof MedicineAndInjectionOrderByRelevanceFieldEnum)[keyof typeof MedicineAndInjectionOrderByRelevanceFieldEnum]


  export const TestingAndScanningPOrderByRelevanceFieldEnum: {
    title: 'title',
    type: 'type',
    status: 'status',
    result: 'result'
  };

  export type TestingAndScanningPOrderByRelevanceFieldEnum = (typeof TestingAndScanningPOrderByRelevanceFieldEnum)[keyof typeof TestingAndScanningPOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const RoomsAvailableOrderByRelevanceFieldEnum: {
    roomNo: 'roomNo',
    notes: 'notes',
    type: 'type'
  };

  export type RoomsAvailableOrderByRelevanceFieldEnum = (typeof RoomsAvailableOrderByRelevanceFieldEnum)[keyof typeof RoomsAvailableOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'HospitalStatus'
   */
  export type EnumHospitalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HospitalStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    
  /**
   * Deep Input Types
   */


  export type HospitalWhereInput = {
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    id?: IntFilter<"Hospital"> | number
    name?: StringFilter<"Hospital"> | string
    address?: StringFilter<"Hospital"> | string
    photo?: StringFilter<"Hospital"> | string
    HospitalStatus?: EnumHospitalStatusFilter<"Hospital"> | $Enums.HospitalStatus
    phone?: StringFilter<"Hospital"> | string
    mail?: StringFilter<"Hospital"> | string
    Users?: UserListRelationFilter
    Admins?: AdminListRelationFilter
    Patients?: PatientListRelationFilter
    Consultation?: ConsultationListRelationFilter
    Treatments?: TreatmentListRelationFilter
    Medicians?: MedicianListRelationFilter
    Injections?: InjectionListRelationFilter
    TestingAndScannings?: TestingAndScanningPListRelationFilter
    TestingAndScanningHs?: TestingAndScanningHListRelationFilter
    RoomsAvailables?: RoomsAvailableListRelationFilter
    Payments?: PaymentListRelationFilter
    MedicineAndInjections?: MedicineAndInjectionListRelationFilter
  }

  export type HospitalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    HospitalStatus?: SortOrder
    phone?: SortOrder
    mail?: SortOrder
    Users?: UserOrderByRelationAggregateInput
    Admins?: AdminOrderByRelationAggregateInput
    Patients?: PatientOrderByRelationAggregateInput
    Consultation?: ConsultationOrderByRelationAggregateInput
    Treatments?: TreatmentOrderByRelationAggregateInput
    Medicians?: MedicianOrderByRelationAggregateInput
    Injections?: InjectionOrderByRelationAggregateInput
    TestingAndScannings?: TestingAndScanningPOrderByRelationAggregateInput
    TestingAndScanningHs?: TestingAndScanningHOrderByRelationAggregateInput
    RoomsAvailables?: RoomsAvailableOrderByRelationAggregateInput
    Payments?: PaymentOrderByRelationAggregateInput
    MedicineAndInjections?: MedicineAndInjectionOrderByRelationAggregateInput
    _relevance?: HospitalOrderByRelevanceInput
  }

  export type HospitalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    name?: StringFilter<"Hospital"> | string
    address?: StringFilter<"Hospital"> | string
    photo?: StringFilter<"Hospital"> | string
    HospitalStatus?: EnumHospitalStatusFilter<"Hospital"> | $Enums.HospitalStatus
    phone?: StringFilter<"Hospital"> | string
    mail?: StringFilter<"Hospital"> | string
    Users?: UserListRelationFilter
    Admins?: AdminListRelationFilter
    Patients?: PatientListRelationFilter
    Consultation?: ConsultationListRelationFilter
    Treatments?: TreatmentListRelationFilter
    Medicians?: MedicianListRelationFilter
    Injections?: InjectionListRelationFilter
    TestingAndScannings?: TestingAndScanningPListRelationFilter
    TestingAndScanningHs?: TestingAndScanningHListRelationFilter
    RoomsAvailables?: RoomsAvailableListRelationFilter
    Payments?: PaymentListRelationFilter
    MedicineAndInjections?: MedicineAndInjectionListRelationFilter
  }, "id">

  export type HospitalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    HospitalStatus?: SortOrder
    phone?: SortOrder
    mail?: SortOrder
    _count?: HospitalCountOrderByAggregateInput
    _avg?: HospitalAvgOrderByAggregateInput
    _max?: HospitalMaxOrderByAggregateInput
    _min?: HospitalMinOrderByAggregateInput
    _sum?: HospitalSumOrderByAggregateInput
  }

  export type HospitalScalarWhereWithAggregatesInput = {
    AND?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    OR?: HospitalScalarWhereWithAggregatesInput[]
    NOT?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hospital"> | number
    name?: StringWithAggregatesFilter<"Hospital"> | string
    address?: StringWithAggregatesFilter<"Hospital"> | string
    photo?: StringWithAggregatesFilter<"Hospital"> | string
    HospitalStatus?: EnumHospitalStatusWithAggregatesFilter<"Hospital"> | $Enums.HospitalStatus
    phone?: StringWithAggregatesFilter<"Hospital"> | string
    mail?: StringWithAggregatesFilter<"Hospital"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    hospital_Id?: IntFilter<"User"> | number
    user_Id?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    AdminStrator?: AdminStratorListRelationFilter
    Admin?: AdminListRelationFilter
    Patient?: PatientListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    password?: SortOrder
    role?: SortOrder
    AdminStrator?: AdminStratorOrderByRelationAggregateInput
    Admin?: AdminOrderByRelationAggregateInput
    Patient?: PatientOrderByRelationAggregateInput
    Hospital?: HospitalOrderByWithRelationInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    hospital_Id?: IntFilter<"User"> | number
    user_Id?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    AdminStrator?: AdminStratorListRelationFilter
    Admin?: AdminListRelationFilter
    Patient?: PatientListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    hospital_Id?: IntWithAggregatesFilter<"User"> | number
    user_Id?: IntWithAggregatesFilter<"User"> | number
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    hospital_Id?: IntFilter<"Admin"> | number
    user_Id?: IntFilter<"Admin"> | number
    destination?: StringFilter<"Admin"> | string
    phone?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    address?: StringFilter<"Admin"> | string
    photo?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    status?: StringFilter<"Admin"> | string
    gender?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    Consultation?: ConsultationListRelationFilter
    Doctor?: TreatmentListRelationFilter
    Staff?: TreatmentListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    status?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Consultation?: ConsultationOrderByRelationAggregateInput
    Doctor?: TreatmentOrderByRelationAggregateInput
    Staff?: TreatmentOrderByRelationAggregateInput
    Hospital?: HospitalOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    hospital_Id?: IntFilter<"Admin"> | number
    user_Id?: IntFilter<"Admin"> | number
    destination?: StringFilter<"Admin"> | string
    phone?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    address?: StringFilter<"Admin"> | string
    photo?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    status?: StringFilter<"Admin"> | string
    gender?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    Consultation?: ConsultationListRelationFilter
    Doctor?: TreatmentListRelationFilter
    Staff?: TreatmentListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    status?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    hospital_Id?: IntWithAggregatesFilter<"Admin"> | number
    user_Id?: IntWithAggregatesFilter<"Admin"> | number
    destination?: StringWithAggregatesFilter<"Admin"> | string
    phone?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    address?: StringWithAggregatesFilter<"Admin"> | string
    photo?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    status?: StringWithAggregatesFilter<"Admin"> | string
    gender?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type AdminStratorWhereInput = {
    AND?: AdminStratorWhereInput | AdminStratorWhereInput[]
    OR?: AdminStratorWhereInput[]
    NOT?: AdminStratorWhereInput | AdminStratorWhereInput[]
    id?: IntFilter<"AdminStrator"> | number
    user_Id?: IntFilter<"AdminStrator"> | number
    name?: StringFilter<"AdminStrator"> | string
    status?: StringFilter<"AdminStrator"> | string
    destination?: StringFilter<"AdminStrator"> | string
    phone?: StringFilter<"AdminStrator"> | string
    email?: StringFilter<"AdminStrator"> | string
    photo?: StringFilter<"AdminStrator"> | string
    address?: StringFilter<"AdminStrator"> | string
    gender?: StringFilter<"AdminStrator"> | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminStratorOrderByWithRelationInput = {
    id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: AdminStratorOrderByRelevanceInput
  }

  export type AdminStratorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminStratorWhereInput | AdminStratorWhereInput[]
    OR?: AdminStratorWhereInput[]
    NOT?: AdminStratorWhereInput | AdminStratorWhereInput[]
    user_Id?: IntFilter<"AdminStrator"> | number
    name?: StringFilter<"AdminStrator"> | string
    status?: StringFilter<"AdminStrator"> | string
    destination?: StringFilter<"AdminStrator"> | string
    phone?: StringFilter<"AdminStrator"> | string
    email?: StringFilter<"AdminStrator"> | string
    photo?: StringFilter<"AdminStrator"> | string
    address?: StringFilter<"AdminStrator"> | string
    gender?: StringFilter<"AdminStrator"> | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminStratorOrderByWithAggregationInput = {
    id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    _count?: AdminStratorCountOrderByAggregateInput
    _avg?: AdminStratorAvgOrderByAggregateInput
    _max?: AdminStratorMaxOrderByAggregateInput
    _min?: AdminStratorMinOrderByAggregateInput
    _sum?: AdminStratorSumOrderByAggregateInput
  }

  export type AdminStratorScalarWhereWithAggregatesInput = {
    AND?: AdminStratorScalarWhereWithAggregatesInput | AdminStratorScalarWhereWithAggregatesInput[]
    OR?: AdminStratorScalarWhereWithAggregatesInput[]
    NOT?: AdminStratorScalarWhereWithAggregatesInput | AdminStratorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminStrator"> | number
    user_Id?: IntWithAggregatesFilter<"AdminStrator"> | number
    name?: StringWithAggregatesFilter<"AdminStrator"> | string
    status?: StringWithAggregatesFilter<"AdminStrator"> | string
    destination?: StringWithAggregatesFilter<"AdminStrator"> | string
    phone?: StringWithAggregatesFilter<"AdminStrator"> | string
    email?: StringWithAggregatesFilter<"AdminStrator"> | string
    photo?: StringWithAggregatesFilter<"AdminStrator"> | string
    address?: StringWithAggregatesFilter<"AdminStrator"> | string
    gender?: StringWithAggregatesFilter<"AdminStrator"> | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    hospital_Id?: IntFilter<"Patient"> | number
    user_Id?: IntFilter<"Patient"> | number
    name?: StringFilter<"Patient"> | string
    phone?: JsonFilter<"Patient">
    email?: JsonFilter<"Patient">
    photo?: StringFilter<"Patient"> | string
    status?: StringFilter<"Patient"> | string
    address?: JsonNullableFilter<"Patient">
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringFilter<"Patient"> | string
    bldGrp?: StringFilter<"Patient"> | string
    currentProblem?: StringFilter<"Patient"> | string
    medicalHistory?: StringFilter<"Patient"> | string
    height?: FloatFilter<"Patient"> | number
    weight?: FloatFilter<"Patient"> | number
    bp?: StringFilter<"Patient"> | string
    sugar?: StringFilter<"Patient"> | string
    custom?: JsonFilter<"Patient">
    tempCreatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    Consultation?: ConsultationListRelationFilter
    Treatment?: TreatmentListRelationFilter
    MedicineAndInjection?: MedicineAndInjectionListRelationFilter
    TestingAndScanning?: TestingAndScanningPListRelationFilter
    Payments?: PaymentListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    address?: SortOrderInput | SortOrder
    dob?: SortOrder
    gender?: SortOrder
    bldGrp?: SortOrder
    currentProblem?: SortOrder
    medicalHistory?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    bp?: SortOrder
    sugar?: SortOrder
    custom?: SortOrder
    tempCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Consultation?: ConsultationOrderByRelationAggregateInput
    Treatment?: TreatmentOrderByRelationAggregateInput
    MedicineAndInjection?: MedicineAndInjectionOrderByRelationAggregateInput
    TestingAndScanning?: TestingAndScanningPOrderByRelationAggregateInput
    Payments?: PaymentOrderByRelationAggregateInput
    Hospital?: HospitalOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: PatientOrderByRelevanceInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    hospital_Id?: IntFilter<"Patient"> | number
    user_Id?: IntFilter<"Patient"> | number
    name?: StringFilter<"Patient"> | string
    phone?: JsonFilter<"Patient">
    email?: JsonFilter<"Patient">
    photo?: StringFilter<"Patient"> | string
    status?: StringFilter<"Patient"> | string
    address?: JsonNullableFilter<"Patient">
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringFilter<"Patient"> | string
    bldGrp?: StringFilter<"Patient"> | string
    currentProblem?: StringFilter<"Patient"> | string
    medicalHistory?: StringFilter<"Patient"> | string
    height?: FloatFilter<"Patient"> | number
    weight?: FloatFilter<"Patient"> | number
    bp?: StringFilter<"Patient"> | string
    sugar?: StringFilter<"Patient"> | string
    custom?: JsonFilter<"Patient">
    tempCreatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    Consultation?: ConsultationListRelationFilter
    Treatment?: TreatmentListRelationFilter
    MedicineAndInjection?: MedicineAndInjectionListRelationFilter
    TestingAndScanning?: TestingAndScanningPListRelationFilter
    Payments?: PaymentListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    address?: SortOrderInput | SortOrder
    dob?: SortOrder
    gender?: SortOrder
    bldGrp?: SortOrder
    currentProblem?: SortOrder
    medicalHistory?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    bp?: SortOrder
    sugar?: SortOrder
    custom?: SortOrder
    tempCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    hospital_Id?: IntWithAggregatesFilter<"Patient"> | number
    user_Id?: IntWithAggregatesFilter<"Patient"> | number
    name?: StringWithAggregatesFilter<"Patient"> | string
    phone?: JsonWithAggregatesFilter<"Patient">
    email?: JsonWithAggregatesFilter<"Patient">
    photo?: StringWithAggregatesFilter<"Patient"> | string
    status?: StringWithAggregatesFilter<"Patient"> | string
    address?: JsonNullableWithAggregatesFilter<"Patient">
    dob?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    gender?: StringWithAggregatesFilter<"Patient"> | string
    bldGrp?: StringWithAggregatesFilter<"Patient"> | string
    currentProblem?: StringWithAggregatesFilter<"Patient"> | string
    medicalHistory?: StringWithAggregatesFilter<"Patient"> | string
    height?: FloatWithAggregatesFilter<"Patient"> | number
    weight?: FloatWithAggregatesFilter<"Patient"> | number
    bp?: StringWithAggregatesFilter<"Patient"> | string
    sugar?: StringWithAggregatesFilter<"Patient"> | string
    custom?: JsonWithAggregatesFilter<"Patient">
    tempCreatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type ConsultationWhereInput = {
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    id?: IntFilter<"Consultation"> | number
    hospital_Id?: IntFilter<"Consultation"> | number
    patient_Id?: IntFilter<"Consultation"> | number
    doctor_Id?: IntFilter<"Consultation"> | number
    date?: DateTimeFilter<"Consultation"> | Date | string
    purpose?: StringFilter<"Consultation"> | string
    temperature?: FloatFilter<"Consultation"> | number
    symptoms?: StringFilter<"Consultation"> | string
    notes?: JsonFilter<"Consultation">
    diagnosis?: StringFilter<"Consultation"> | string
    treatment?: BoolFilter<"Consultation"> | boolean
    medicineInjection?: BoolFilter<"Consultation"> | boolean
    scanningTesting?: BoolFilter<"Consultation"> | boolean
    status?: StringFilter<"Consultation"> | string
    access?: JsonFilter<"Consultation">
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    paymentStatus?: BoolFilter<"Consultation"> | boolean
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    Doctor?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type ConsultationOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    date?: SortOrder
    purpose?: SortOrder
    temperature?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medicineInjection?: SortOrder
    scanningTesting?: SortOrder
    status?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    Patient?: PatientOrderByWithRelationInput
    Doctor?: AdminOrderByWithRelationInput
    _relevance?: ConsultationOrderByRelevanceInput
  }

  export type ConsultationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    hospital_Id?: IntFilter<"Consultation"> | number
    patient_Id?: IntFilter<"Consultation"> | number
    doctor_Id?: IntFilter<"Consultation"> | number
    date?: DateTimeFilter<"Consultation"> | Date | string
    purpose?: StringFilter<"Consultation"> | string
    temperature?: FloatFilter<"Consultation"> | number
    symptoms?: StringFilter<"Consultation"> | string
    notes?: JsonFilter<"Consultation">
    diagnosis?: StringFilter<"Consultation"> | string
    treatment?: BoolFilter<"Consultation"> | boolean
    medicineInjection?: BoolFilter<"Consultation"> | boolean
    scanningTesting?: BoolFilter<"Consultation"> | boolean
    status?: StringFilter<"Consultation"> | string
    access?: JsonFilter<"Consultation">
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    paymentStatus?: BoolFilter<"Consultation"> | boolean
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    Doctor?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type ConsultationOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    date?: SortOrder
    purpose?: SortOrder
    temperature?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medicineInjection?: SortOrder
    scanningTesting?: SortOrder
    status?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
    _count?: ConsultationCountOrderByAggregateInput
    _avg?: ConsultationAvgOrderByAggregateInput
    _max?: ConsultationMaxOrderByAggregateInput
    _min?: ConsultationMinOrderByAggregateInput
    _sum?: ConsultationSumOrderByAggregateInput
  }

  export type ConsultationScalarWhereWithAggregatesInput = {
    AND?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    OR?: ConsultationScalarWhereWithAggregatesInput[]
    NOT?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Consultation"> | number
    hospital_Id?: IntWithAggregatesFilter<"Consultation"> | number
    patient_Id?: IntWithAggregatesFilter<"Consultation"> | number
    doctor_Id?: IntWithAggregatesFilter<"Consultation"> | number
    date?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    purpose?: StringWithAggregatesFilter<"Consultation"> | string
    temperature?: FloatWithAggregatesFilter<"Consultation"> | number
    symptoms?: StringWithAggregatesFilter<"Consultation"> | string
    notes?: JsonWithAggregatesFilter<"Consultation">
    diagnosis?: StringWithAggregatesFilter<"Consultation"> | string
    treatment?: BoolWithAggregatesFilter<"Consultation"> | boolean
    medicineInjection?: BoolWithAggregatesFilter<"Consultation"> | boolean
    scanningTesting?: BoolWithAggregatesFilter<"Consultation"> | boolean
    status?: StringWithAggregatesFilter<"Consultation"> | string
    access?: JsonWithAggregatesFilter<"Consultation">
    createdAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    paymentStatus?: BoolWithAggregatesFilter<"Consultation"> | boolean
  }

  export type TreatmentWhereInput = {
    AND?: TreatmentWhereInput | TreatmentWhereInput[]
    OR?: TreatmentWhereInput[]
    NOT?: TreatmentWhereInput | TreatmentWhereInput[]
    id?: IntFilter<"Treatment"> | number
    hospital_Id?: IntFilter<"Treatment"> | number
    staff_Id?: JsonFilter<"Treatment">
    patient_Id?: IntFilter<"Treatment"> | number
    doctor_Id?: JsonFilter<"Treatment">
    treatmentName?: JsonFilter<"Treatment">
    startDate?: DateTimeFilter<"Treatment"> | Date | string
    endDate?: DateTimeFilter<"Treatment"> | Date | string
    progress?: StringFilter<"Treatment"> | string
    status?: StringFilter<"Treatment"> | string
    createdAt?: DateTimeFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeFilter<"Treatment"> | Date | string
    paymentStatus?: BoolFilter<"Treatment"> | boolean
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    Doctor?: AdminListRelationFilter
    Staff?: AdminListRelationFilter
  }

  export type TreatmentOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staff_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    treatmentName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    Patient?: PatientOrderByWithRelationInput
    Doctor?: AdminOrderByRelationAggregateInput
    Staff?: AdminOrderByRelationAggregateInput
    _relevance?: TreatmentOrderByRelevanceInput
  }

  export type TreatmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TreatmentWhereInput | TreatmentWhereInput[]
    OR?: TreatmentWhereInput[]
    NOT?: TreatmentWhereInput | TreatmentWhereInput[]
    hospital_Id?: IntFilter<"Treatment"> | number
    staff_Id?: JsonFilter<"Treatment">
    patient_Id?: IntFilter<"Treatment"> | number
    doctor_Id?: JsonFilter<"Treatment">
    treatmentName?: JsonFilter<"Treatment">
    startDate?: DateTimeFilter<"Treatment"> | Date | string
    endDate?: DateTimeFilter<"Treatment"> | Date | string
    progress?: StringFilter<"Treatment"> | string
    status?: StringFilter<"Treatment"> | string
    createdAt?: DateTimeFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeFilter<"Treatment"> | Date | string
    paymentStatus?: BoolFilter<"Treatment"> | boolean
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    Doctor?: AdminListRelationFilter
    Staff?: AdminListRelationFilter
  }, "id">

  export type TreatmentOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staff_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    treatmentName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
    _count?: TreatmentCountOrderByAggregateInput
    _avg?: TreatmentAvgOrderByAggregateInput
    _max?: TreatmentMaxOrderByAggregateInput
    _min?: TreatmentMinOrderByAggregateInput
    _sum?: TreatmentSumOrderByAggregateInput
  }

  export type TreatmentScalarWhereWithAggregatesInput = {
    AND?: TreatmentScalarWhereWithAggregatesInput | TreatmentScalarWhereWithAggregatesInput[]
    OR?: TreatmentScalarWhereWithAggregatesInput[]
    NOT?: TreatmentScalarWhereWithAggregatesInput | TreatmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Treatment"> | number
    hospital_Id?: IntWithAggregatesFilter<"Treatment"> | number
    staff_Id?: JsonWithAggregatesFilter<"Treatment">
    patient_Id?: IntWithAggregatesFilter<"Treatment"> | number
    doctor_Id?: JsonWithAggregatesFilter<"Treatment">
    treatmentName?: JsonWithAggregatesFilter<"Treatment">
    startDate?: DateTimeWithAggregatesFilter<"Treatment"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Treatment"> | Date | string
    progress?: StringWithAggregatesFilter<"Treatment"> | string
    status?: StringWithAggregatesFilter<"Treatment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Treatment"> | Date | string
    paymentStatus?: BoolWithAggregatesFilter<"Treatment"> | boolean
  }

  export type MedicianWhereInput = {
    AND?: MedicianWhereInput | MedicianWhereInput[]
    OR?: MedicianWhereInput[]
    NOT?: MedicianWhereInput | MedicianWhereInput[]
    id?: IntFilter<"Medician"> | number
    hospital_Id?: IntFilter<"Medician"> | number
    medicianName?: StringFilter<"Medician"> | string
    stock?: IntFilter<"Medician"> | number
    amount?: FloatFilter<"Medician"> | number
    staffId?: JsonFilter<"Medician">
    MedicineAndInjection?: MedicineAndInjectionListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }

  export type MedicianOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    medicianName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
    staffId?: SortOrder
    MedicineAndInjection?: MedicineAndInjectionOrderByRelationAggregateInput
    Hospital?: HospitalOrderByWithRelationInput
    _relevance?: MedicianOrderByRelevanceInput
  }

  export type MedicianWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicianWhereInput | MedicianWhereInput[]
    OR?: MedicianWhereInput[]
    NOT?: MedicianWhereInput | MedicianWhereInput[]
    hospital_Id?: IntFilter<"Medician"> | number
    medicianName?: StringFilter<"Medician"> | string
    stock?: IntFilter<"Medician"> | number
    amount?: FloatFilter<"Medician"> | number
    staffId?: JsonFilter<"Medician">
    MedicineAndInjection?: MedicineAndInjectionListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }, "id">

  export type MedicianOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    medicianName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
    staffId?: SortOrder
    _count?: MedicianCountOrderByAggregateInput
    _avg?: MedicianAvgOrderByAggregateInput
    _max?: MedicianMaxOrderByAggregateInput
    _min?: MedicianMinOrderByAggregateInput
    _sum?: MedicianSumOrderByAggregateInput
  }

  export type MedicianScalarWhereWithAggregatesInput = {
    AND?: MedicianScalarWhereWithAggregatesInput | MedicianScalarWhereWithAggregatesInput[]
    OR?: MedicianScalarWhereWithAggregatesInput[]
    NOT?: MedicianScalarWhereWithAggregatesInput | MedicianScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Medician"> | number
    hospital_Id?: IntWithAggregatesFilter<"Medician"> | number
    medicianName?: StringWithAggregatesFilter<"Medician"> | string
    stock?: IntWithAggregatesFilter<"Medician"> | number
    amount?: FloatWithAggregatesFilter<"Medician"> | number
    staffId?: JsonWithAggregatesFilter<"Medician">
  }

  export type InjectionWhereInput = {
    AND?: InjectionWhereInput | InjectionWhereInput[]
    OR?: InjectionWhereInput[]
    NOT?: InjectionWhereInput | InjectionWhereInput[]
    id?: IntFilter<"Injection"> | number
    hospital_Id?: IntFilter<"Injection"> | number
    injectionName?: StringFilter<"Injection"> | string
    stock?: IntFilter<"Injection"> | number
    amount?: FloatFilter<"Injection"> | number
    staffId?: JsonFilter<"Injection">
    MedicineAndInjection?: MedicineAndInjectionListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }

  export type InjectionOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    injectionName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
    staffId?: SortOrder
    MedicineAndInjection?: MedicineAndInjectionOrderByRelationAggregateInput
    Hospital?: HospitalOrderByWithRelationInput
    _relevance?: InjectionOrderByRelevanceInput
  }

  export type InjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InjectionWhereInput | InjectionWhereInput[]
    OR?: InjectionWhereInput[]
    NOT?: InjectionWhereInput | InjectionWhereInput[]
    hospital_Id?: IntFilter<"Injection"> | number
    injectionName?: StringFilter<"Injection"> | string
    stock?: IntFilter<"Injection"> | number
    amount?: FloatFilter<"Injection"> | number
    staffId?: JsonFilter<"Injection">
    MedicineAndInjection?: MedicineAndInjectionListRelationFilter
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }, "id">

  export type InjectionOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    injectionName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
    staffId?: SortOrder
    _count?: InjectionCountOrderByAggregateInput
    _avg?: InjectionAvgOrderByAggregateInput
    _max?: InjectionMaxOrderByAggregateInput
    _min?: InjectionMinOrderByAggregateInput
    _sum?: InjectionSumOrderByAggregateInput
  }

  export type InjectionScalarWhereWithAggregatesInput = {
    AND?: InjectionScalarWhereWithAggregatesInput | InjectionScalarWhereWithAggregatesInput[]
    OR?: InjectionScalarWhereWithAggregatesInput[]
    NOT?: InjectionScalarWhereWithAggregatesInput | InjectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Injection"> | number
    hospital_Id?: IntWithAggregatesFilter<"Injection"> | number
    injectionName?: StringWithAggregatesFilter<"Injection"> | string
    stock?: IntWithAggregatesFilter<"Injection"> | number
    amount?: FloatWithAggregatesFilter<"Injection"> | number
    staffId?: JsonWithAggregatesFilter<"Injection">
  }

  export type TestingAndScanningHWhereInput = {
    AND?: TestingAndScanningHWhereInput | TestingAndScanningHWhereInput[]
    OR?: TestingAndScanningHWhereInput[]
    NOT?: TestingAndScanningHWhereInput | TestingAndScanningHWhereInput[]
    id?: IntFilter<"TestingAndScanningH"> | number
    hospital_Id?: IntFilter<"TestingAndScanningH"> | number
    type?: StringFilter<"TestingAndScanningH"> | string
    status?: StringFilter<"TestingAndScanningH"> | string
    roomNo?: StringFilter<"TestingAndScanningH"> | string
    staffId?: IntFilter<"TestingAndScanningH"> | number
    amount?: FloatFilter<"TestingAndScanningH"> | number
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }

  export type TestingAndScanningHOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    roomNo?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    _relevance?: TestingAndScanningHOrderByRelevanceInput
  }

  export type TestingAndScanningHWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestingAndScanningHWhereInput | TestingAndScanningHWhereInput[]
    OR?: TestingAndScanningHWhereInput[]
    NOT?: TestingAndScanningHWhereInput | TestingAndScanningHWhereInput[]
    hospital_Id?: IntFilter<"TestingAndScanningH"> | number
    type?: StringFilter<"TestingAndScanningH"> | string
    status?: StringFilter<"TestingAndScanningH"> | string
    roomNo?: StringFilter<"TestingAndScanningH"> | string
    staffId?: IntFilter<"TestingAndScanningH"> | number
    amount?: FloatFilter<"TestingAndScanningH"> | number
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }, "id">

  export type TestingAndScanningHOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    roomNo?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
    _count?: TestingAndScanningHCountOrderByAggregateInput
    _avg?: TestingAndScanningHAvgOrderByAggregateInput
    _max?: TestingAndScanningHMaxOrderByAggregateInput
    _min?: TestingAndScanningHMinOrderByAggregateInput
    _sum?: TestingAndScanningHSumOrderByAggregateInput
  }

  export type TestingAndScanningHScalarWhereWithAggregatesInput = {
    AND?: TestingAndScanningHScalarWhereWithAggregatesInput | TestingAndScanningHScalarWhereWithAggregatesInput[]
    OR?: TestingAndScanningHScalarWhereWithAggregatesInput[]
    NOT?: TestingAndScanningHScalarWhereWithAggregatesInput | TestingAndScanningHScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestingAndScanningH"> | number
    hospital_Id?: IntWithAggregatesFilter<"TestingAndScanningH"> | number
    type?: StringWithAggregatesFilter<"TestingAndScanningH"> | string
    status?: StringWithAggregatesFilter<"TestingAndScanningH"> | string
    roomNo?: StringWithAggregatesFilter<"TestingAndScanningH"> | string
    staffId?: IntWithAggregatesFilter<"TestingAndScanningH"> | number
    amount?: FloatWithAggregatesFilter<"TestingAndScanningH"> | number
  }

  export type MedicineAndInjectionWhereInput = {
    AND?: MedicineAndInjectionWhereInput | MedicineAndInjectionWhereInput[]
    OR?: MedicineAndInjectionWhereInput[]
    NOT?: MedicineAndInjectionWhereInput | MedicineAndInjectionWhereInput[]
    id?: IntFilter<"MedicineAndInjection"> | number
    hospital_Id?: IntFilter<"MedicineAndInjection"> | number
    patient_Id?: IntFilter<"MedicineAndInjection"> | number
    doctor_Id?: JsonFilter<"MedicineAndInjection">
    staff_Id?: JsonFilter<"MedicineAndInjection">
    medicine_Id?: JsonFilter<"MedicineAndInjection">
    frequencyMedicine?: JsonFilter<"MedicineAndInjection">
    injection_Id?: JsonFilter<"MedicineAndInjection">
    frequencyInjection?: JsonFilter<"MedicineAndInjection">
    status?: StringFilter<"MedicineAndInjection"> | string
    notes?: JsonFilter<"MedicineAndInjection">
    paymentStatus?: BoolFilter<"MedicineAndInjection"> | boolean
    createdAt?: DateTimeFilter<"MedicineAndInjection"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineAndInjection"> | Date | string
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    Medician?: MedicianListRelationFilter
    Injection?: InjectionListRelationFilter
  }

  export type MedicineAndInjectionOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    staff_Id?: SortOrder
    medicine_Id?: SortOrder
    frequencyMedicine?: SortOrder
    injection_Id?: SortOrder
    frequencyInjection?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    Patient?: PatientOrderByWithRelationInput
    Medician?: MedicianOrderByRelationAggregateInput
    Injection?: InjectionOrderByRelationAggregateInput
    _relevance?: MedicineAndInjectionOrderByRelevanceInput
  }

  export type MedicineAndInjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicineAndInjectionWhereInput | MedicineAndInjectionWhereInput[]
    OR?: MedicineAndInjectionWhereInput[]
    NOT?: MedicineAndInjectionWhereInput | MedicineAndInjectionWhereInput[]
    hospital_Id?: IntFilter<"MedicineAndInjection"> | number
    patient_Id?: IntFilter<"MedicineAndInjection"> | number
    doctor_Id?: JsonFilter<"MedicineAndInjection">
    staff_Id?: JsonFilter<"MedicineAndInjection">
    medicine_Id?: JsonFilter<"MedicineAndInjection">
    frequencyMedicine?: JsonFilter<"MedicineAndInjection">
    injection_Id?: JsonFilter<"MedicineAndInjection">
    frequencyInjection?: JsonFilter<"MedicineAndInjection">
    status?: StringFilter<"MedicineAndInjection"> | string
    notes?: JsonFilter<"MedicineAndInjection">
    paymentStatus?: BoolFilter<"MedicineAndInjection"> | boolean
    createdAt?: DateTimeFilter<"MedicineAndInjection"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineAndInjection"> | Date | string
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    Medician?: MedicianListRelationFilter
    Injection?: InjectionListRelationFilter
  }, "id">

  export type MedicineAndInjectionOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    staff_Id?: SortOrder
    medicine_Id?: SortOrder
    frequencyMedicine?: SortOrder
    injection_Id?: SortOrder
    frequencyInjection?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineAndInjectionCountOrderByAggregateInput
    _avg?: MedicineAndInjectionAvgOrderByAggregateInput
    _max?: MedicineAndInjectionMaxOrderByAggregateInput
    _min?: MedicineAndInjectionMinOrderByAggregateInput
    _sum?: MedicineAndInjectionSumOrderByAggregateInput
  }

  export type MedicineAndInjectionScalarWhereWithAggregatesInput = {
    AND?: MedicineAndInjectionScalarWhereWithAggregatesInput | MedicineAndInjectionScalarWhereWithAggregatesInput[]
    OR?: MedicineAndInjectionScalarWhereWithAggregatesInput[]
    NOT?: MedicineAndInjectionScalarWhereWithAggregatesInput | MedicineAndInjectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicineAndInjection"> | number
    hospital_Id?: IntWithAggregatesFilter<"MedicineAndInjection"> | number
    patient_Id?: IntWithAggregatesFilter<"MedicineAndInjection"> | number
    doctor_Id?: JsonWithAggregatesFilter<"MedicineAndInjection">
    staff_Id?: JsonWithAggregatesFilter<"MedicineAndInjection">
    medicine_Id?: JsonWithAggregatesFilter<"MedicineAndInjection">
    frequencyMedicine?: JsonWithAggregatesFilter<"MedicineAndInjection">
    injection_Id?: JsonWithAggregatesFilter<"MedicineAndInjection">
    frequencyInjection?: JsonWithAggregatesFilter<"MedicineAndInjection">
    status?: StringWithAggregatesFilter<"MedicineAndInjection"> | string
    notes?: JsonWithAggregatesFilter<"MedicineAndInjection">
    paymentStatus?: BoolWithAggregatesFilter<"MedicineAndInjection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MedicineAndInjection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineAndInjection"> | Date | string
  }

  export type TestingAndScanningPWhereInput = {
    AND?: TestingAndScanningPWhereInput | TestingAndScanningPWhereInput[]
    OR?: TestingAndScanningPWhereInput[]
    NOT?: TestingAndScanningPWhereInput | TestingAndScanningPWhereInput[]
    id?: IntFilter<"TestingAndScanningP"> | number
    hospital_Id?: IntFilter<"TestingAndScanningP"> | number
    patient_Id?: IntFilter<"TestingAndScanningP"> | number
    doctor_Id?: JsonFilter<"TestingAndScanningP">
    staff_Id?: JsonFilter<"TestingAndScanningP">
    title?: StringFilter<"TestingAndScanningP"> | string
    scheduleDate?: DateTimeFilter<"TestingAndScanningP"> | Date | string
    type?: StringFilter<"TestingAndScanningP"> | string
    status?: StringFilter<"TestingAndScanningP"> | string
    paymentStatus?: BoolFilter<"TestingAndScanningP"> | boolean
    result?: StringFilter<"TestingAndScanningP"> | string
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type TestingAndScanningPOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    staff_Id?: SortOrder
    title?: SortOrder
    scheduleDate?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    result?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    Patient?: PatientOrderByWithRelationInput
    _relevance?: TestingAndScanningPOrderByRelevanceInput
  }

  export type TestingAndScanningPWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestingAndScanningPWhereInput | TestingAndScanningPWhereInput[]
    OR?: TestingAndScanningPWhereInput[]
    NOT?: TestingAndScanningPWhereInput | TestingAndScanningPWhereInput[]
    hospital_Id?: IntFilter<"TestingAndScanningP"> | number
    patient_Id?: IntFilter<"TestingAndScanningP"> | number
    doctor_Id?: JsonFilter<"TestingAndScanningP">
    staff_Id?: JsonFilter<"TestingAndScanningP">
    title?: StringFilter<"TestingAndScanningP"> | string
    scheduleDate?: DateTimeFilter<"TestingAndScanningP"> | Date | string
    type?: StringFilter<"TestingAndScanningP"> | string
    status?: StringFilter<"TestingAndScanningP"> | string
    paymentStatus?: BoolFilter<"TestingAndScanningP"> | boolean
    result?: StringFilter<"TestingAndScanningP"> | string
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type TestingAndScanningPOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    staff_Id?: SortOrder
    title?: SortOrder
    scheduleDate?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    result?: SortOrder
    _count?: TestingAndScanningPCountOrderByAggregateInput
    _avg?: TestingAndScanningPAvgOrderByAggregateInput
    _max?: TestingAndScanningPMaxOrderByAggregateInput
    _min?: TestingAndScanningPMinOrderByAggregateInput
    _sum?: TestingAndScanningPSumOrderByAggregateInput
  }

  export type TestingAndScanningPScalarWhereWithAggregatesInput = {
    AND?: TestingAndScanningPScalarWhereWithAggregatesInput | TestingAndScanningPScalarWhereWithAggregatesInput[]
    OR?: TestingAndScanningPScalarWhereWithAggregatesInput[]
    NOT?: TestingAndScanningPScalarWhereWithAggregatesInput | TestingAndScanningPScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestingAndScanningP"> | number
    hospital_Id?: IntWithAggregatesFilter<"TestingAndScanningP"> | number
    patient_Id?: IntWithAggregatesFilter<"TestingAndScanningP"> | number
    doctor_Id?: JsonWithAggregatesFilter<"TestingAndScanningP">
    staff_Id?: JsonWithAggregatesFilter<"TestingAndScanningP">
    title?: StringWithAggregatesFilter<"TestingAndScanningP"> | string
    scheduleDate?: DateTimeWithAggregatesFilter<"TestingAndScanningP"> | Date | string
    type?: StringWithAggregatesFilter<"TestingAndScanningP"> | string
    status?: StringWithAggregatesFilter<"TestingAndScanningP"> | string
    paymentStatus?: BoolWithAggregatesFilter<"TestingAndScanningP"> | boolean
    result?: StringWithAggregatesFilter<"TestingAndScanningP"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    hospital_Id?: IntFilter<"Payment"> | number
    patient_Id?: IntFilter<"Payment"> | number
    reason?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    transactionId?: JsonFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    Patient?: PatientOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    hospital_Id?: IntFilter<"Payment"> | number
    patient_Id?: IntFilter<"Payment"> | number
    reason?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    transactionId?: JsonFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    Patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    hospital_Id?: IntWithAggregatesFilter<"Payment"> | number
    patient_Id?: IntWithAggregatesFilter<"Payment"> | number
    reason?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    transactionId?: JsonWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RoomsAvailableWhereInput = {
    AND?: RoomsAvailableWhereInput | RoomsAvailableWhereInput[]
    OR?: RoomsAvailableWhereInput[]
    NOT?: RoomsAvailableWhereInput | RoomsAvailableWhereInput[]
    id?: IntFilter<"RoomsAvailable"> | number
    hospital_Id?: IntFilter<"RoomsAvailable"> | number
    staffId?: IntFilter<"RoomsAvailable"> | number
    roomNo?: StringFilter<"RoomsAvailable"> | string
    capacity?: IntFilter<"RoomsAvailable"> | number
    notes?: StringFilter<"RoomsAvailable"> | string
    type?: StringFilter<"RoomsAvailable"> | string
    amount?: FloatFilter<"RoomsAvailable"> | number
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }

  export type RoomsAvailableOrderByWithRelationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    roomNo?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    Hospital?: HospitalOrderByWithRelationInput
    _relevance?: RoomsAvailableOrderByRelevanceInput
  }

  export type RoomsAvailableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomsAvailableWhereInput | RoomsAvailableWhereInput[]
    OR?: RoomsAvailableWhereInput[]
    NOT?: RoomsAvailableWhereInput | RoomsAvailableWhereInput[]
    hospital_Id?: IntFilter<"RoomsAvailable"> | number
    staffId?: IntFilter<"RoomsAvailable"> | number
    roomNo?: StringFilter<"RoomsAvailable"> | string
    capacity?: IntFilter<"RoomsAvailable"> | number
    notes?: StringFilter<"RoomsAvailable"> | string
    type?: StringFilter<"RoomsAvailable"> | string
    amount?: FloatFilter<"RoomsAvailable"> | number
    Hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
  }, "id">

  export type RoomsAvailableOrderByWithAggregationInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    roomNo?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    _count?: RoomsAvailableCountOrderByAggregateInput
    _avg?: RoomsAvailableAvgOrderByAggregateInput
    _max?: RoomsAvailableMaxOrderByAggregateInput
    _min?: RoomsAvailableMinOrderByAggregateInput
    _sum?: RoomsAvailableSumOrderByAggregateInput
  }

  export type RoomsAvailableScalarWhereWithAggregatesInput = {
    AND?: RoomsAvailableScalarWhereWithAggregatesInput | RoomsAvailableScalarWhereWithAggregatesInput[]
    OR?: RoomsAvailableScalarWhereWithAggregatesInput[]
    NOT?: RoomsAvailableScalarWhereWithAggregatesInput | RoomsAvailableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomsAvailable"> | number
    hospital_Id?: IntWithAggregatesFilter<"RoomsAvailable"> | number
    staffId?: IntWithAggregatesFilter<"RoomsAvailable"> | number
    roomNo?: StringWithAggregatesFilter<"RoomsAvailable"> | string
    capacity?: IntWithAggregatesFilter<"RoomsAvailable"> | number
    notes?: StringWithAggregatesFilter<"RoomsAvailable"> | string
    type?: StringWithAggregatesFilter<"RoomsAvailable"> | string
    amount?: FloatWithAggregatesFilter<"RoomsAvailable"> | number
  }

  export type HospitalCreateInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateManyInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
  }

  export type HospitalUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type HospitalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Patient?: PatientCreateNestedManyWithoutUserInput
    Hospital: HospitalCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Patient?: PatientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Patient?: PatientUpdateManyWithoutUserNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    password: string
    role: string
  }

  export type UserUpdateManyMutationInput = {
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateInput = {
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentCreateNestedManyWithoutStaffInput
    Hospital: HospitalCreateNestedOneWithoutAdminsInput
    User: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentUncheckedCreateNestedManyWithoutStaffInput
  }

  export type AdminUpdateInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUpdateManyWithoutStaffNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutAdminsNestedInput
    User?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminStratorCreateInput = {
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
    User: UserCreateNestedOneWithoutAdminStratorInput
  }

  export type AdminStratorUncheckedCreateInput = {
    id?: number
    user_Id: number
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
  }

  export type AdminStratorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutAdminStratorNestedInput
  }

  export type AdminStratorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
  }

  export type AdminStratorCreateManyInput = {
    id?: number
    user_Id: number
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
  }

  export type AdminStratorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
  }

  export type AdminStratorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
  }

  export type PatientCreateInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationCreateInput = {
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutConsultationInput
    Patient: PatientCreateNestedOneWithoutConsultationInput
    Doctor: AdminCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type ConsultationUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutConsultationNestedInput
    Patient?: PatientUpdateOneRequiredWithoutConsultationNestedInput
    Doctor?: AdminUpdateOneRequiredWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationCreateManyInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type ConsultationUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreatmentCreateInput = {
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutTreatmentsInput
    Patient: PatientCreateNestedOneWithoutTreatmentInput
    Doctor?: AdminCreateNestedManyWithoutDoctorInput
    Staff?: AdminCreateNestedManyWithoutStaffInput
  }

  export type TreatmentUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    staff_Id: JsonNullValueInput | InputJsonValue
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Doctor?: AdminUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: AdminUncheckedCreateNestedManyWithoutStaffInput
  }

  export type TreatmentUpdateInput = {
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutTreatmentsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutTreatmentNestedInput
    Doctor?: AdminUpdateManyWithoutDoctorNestedInput
    Staff?: AdminUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Doctor?: AdminUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: AdminUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentCreateManyInput = {
    id?: number
    hospital_Id: number
    staff_Id: JsonNullValueInput | InputJsonValue
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type TreatmentUpdateManyMutationInput = {
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreatmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicianCreateInput = {
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutMedicianInput
    Hospital: HospitalCreateNestedOneWithoutMediciansInput
  }

  export type MedicianUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutMedicianInput
  }

  export type MedicianUpdateInput = {
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutMedicianNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutMediciansNestedInput
  }

  export type MedicianUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutMedicianNestedInput
  }

  export type MedicianCreateManyInput = {
    id?: number
    hospital_Id: number
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
  }

  export type MedicianUpdateManyMutationInput = {
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type MedicianUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type InjectionCreateInput = {
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutInjectionInput
    Hospital: HospitalCreateNestedOneWithoutInjectionsInput
  }

  export type InjectionUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutInjectionInput
  }

  export type InjectionUpdateInput = {
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutInjectionNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutInjectionsNestedInput
  }

  export type InjectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutInjectionNestedInput
  }

  export type InjectionCreateManyInput = {
    id?: number
    hospital_Id: number
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
  }

  export type InjectionUpdateManyMutationInput = {
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type InjectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type TestingAndScanningHCreateInput = {
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
    Hospital: HospitalCreateNestedOneWithoutTestingAndScanningHsInput
  }

  export type TestingAndScanningHUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
  }

  export type TestingAndScanningHUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    Hospital?: HospitalUpdateOneRequiredWithoutTestingAndScanningHsNestedInput
  }

  export type TestingAndScanningHUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TestingAndScanningHCreateManyInput = {
    id?: number
    hospital_Id: number
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
  }

  export type TestingAndScanningHUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TestingAndScanningHUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type MedicineAndInjectionCreateInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital: HospitalCreateNestedOneWithoutMedicineAndInjectionsInput
    Patient: PatientCreateNestedOneWithoutMedicineAndInjectionInput
    Medician?: MedicianCreateNestedManyWithoutMedicineAndInjectionInput
    Injection?: InjectionCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Medician?: MedicianUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
    Injection?: InjectionUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionUpdateInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneRequiredWithoutMedicineAndInjectionsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutMedicineAndInjectionNestedInput
    Medician?: MedicianUpdateManyWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Medician?: MedicianUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionCreateManyInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineAndInjectionUpdateManyMutationInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineAndInjectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestingAndScanningPCreateInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
    Hospital: HospitalCreateNestedOneWithoutTestingAndScanningsInput
    Patient: PatientCreateNestedOneWithoutTestingAndScanningInput
  }

  export type TestingAndScanningPUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
  }

  export type TestingAndScanningPUpdateInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
    Hospital?: HospitalUpdateOneRequiredWithoutTestingAndScanningsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutTestingAndScanningNestedInput
  }

  export type TestingAndScanningPUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type TestingAndScanningPCreateManyInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
  }

  export type TestingAndScanningPUpdateManyMutationInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type TestingAndScanningPUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital: HospitalCreateNestedOneWithoutPaymentsInput
    Patient: PatientCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneRequiredWithoutPaymentsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomsAvailableCreateInput = {
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
    Hospital: HospitalCreateNestedOneWithoutRoomsAvailablesInput
  }

  export type RoomsAvailableUncheckedCreateInput = {
    id?: number
    hospital_Id: number
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
  }

  export type RoomsAvailableUpdateInput = {
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    Hospital?: HospitalUpdateOneRequiredWithoutRoomsAvailablesNestedInput
  }

  export type RoomsAvailableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RoomsAvailableCreateManyInput = {
    id?: number
    hospital_Id: number
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
  }

  export type RoomsAvailableUpdateManyMutationInput = {
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RoomsAvailableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumHospitalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HospitalStatus | EnumHospitalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HospitalStatus[]
    notIn?: $Enums.HospitalStatus[]
    not?: NestedEnumHospitalStatusFilter<$PrismaModel> | $Enums.HospitalStatus
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type ConsultationListRelationFilter = {
    every?: ConsultationWhereInput
    some?: ConsultationWhereInput
    none?: ConsultationWhereInput
  }

  export type TreatmentListRelationFilter = {
    every?: TreatmentWhereInput
    some?: TreatmentWhereInput
    none?: TreatmentWhereInput
  }

  export type MedicianListRelationFilter = {
    every?: MedicianWhereInput
    some?: MedicianWhereInput
    none?: MedicianWhereInput
  }

  export type InjectionListRelationFilter = {
    every?: InjectionWhereInput
    some?: InjectionWhereInput
    none?: InjectionWhereInput
  }

  export type TestingAndScanningPListRelationFilter = {
    every?: TestingAndScanningPWhereInput
    some?: TestingAndScanningPWhereInput
    none?: TestingAndScanningPWhereInput
  }

  export type TestingAndScanningHListRelationFilter = {
    every?: TestingAndScanningHWhereInput
    some?: TestingAndScanningHWhereInput
    none?: TestingAndScanningHWhereInput
  }

  export type RoomsAvailableListRelationFilter = {
    every?: RoomsAvailableWhereInput
    some?: RoomsAvailableWhereInput
    none?: RoomsAvailableWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type MedicineAndInjectionListRelationFilter = {
    every?: MedicineAndInjectionWhereInput
    some?: MedicineAndInjectionWhereInput
    none?: MedicineAndInjectionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreatmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InjectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestingAndScanningPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestingAndScanningHOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomsAvailableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineAndInjectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HospitalOrderByRelevanceInput = {
    fields: HospitalOrderByRelevanceFieldEnum | HospitalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HospitalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    HospitalStatus?: SortOrder
    phone?: SortOrder
    mail?: SortOrder
  }

  export type HospitalAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    HospitalStatus?: SortOrder
    phone?: SortOrder
    mail?: SortOrder
  }

  export type HospitalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    HospitalStatus?: SortOrder
    phone?: SortOrder
    mail?: SortOrder
  }

  export type HospitalSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumHospitalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HospitalStatus | EnumHospitalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HospitalStatus[]
    notIn?: $Enums.HospitalStatus[]
    not?: NestedEnumHospitalStatusWithAggregatesFilter<$PrismaModel> | $Enums.HospitalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHospitalStatusFilter<$PrismaModel>
    _max?: NestedEnumHospitalStatusFilter<$PrismaModel>
  }

  export type AdminStratorListRelationFilter = {
    every?: AdminStratorWhereInput
    some?: AdminStratorWhereInput
    none?: AdminStratorWhereInput
  }

  export type HospitalScalarRelationFilter = {
    is?: HospitalWhereInput
    isNot?: HospitalWhereInput
  }

  export type AdminStratorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    status?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    status?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    name?: SortOrder
    status?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AdminStratorOrderByRelevanceInput = {
    fields: AdminStratorOrderByRelevanceFieldEnum | AdminStratorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminStratorCountOrderByAggregateInput = {
    id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    gender?: SortOrder
  }

  export type AdminStratorAvgOrderByAggregateInput = {
    id?: SortOrder
    user_Id?: SortOrder
  }

  export type AdminStratorMaxOrderByAggregateInput = {
    id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    gender?: SortOrder
  }

  export type AdminStratorMinOrderByAggregateInput = {
    id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    destination?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    address?: SortOrder
    gender?: SortOrder
  }

  export type AdminStratorSumOrderByAggregateInput = {
    id?: SortOrder
    user_Id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PatientOrderByRelevanceInput = {
    fields: PatientOrderByRelevanceFieldEnum | PatientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    address?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    bldGrp?: SortOrder
    currentProblem?: SortOrder
    medicalHistory?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    bp?: SortOrder
    sugar?: SortOrder
    custom?: SortOrder
    tempCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    bldGrp?: SortOrder
    currentProblem?: SortOrder
    medicalHistory?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    bp?: SortOrder
    sugar?: SortOrder
    tempCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    bldGrp?: SortOrder
    currentProblem?: SortOrder
    medicalHistory?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    bp?: SortOrder
    sugar?: SortOrder
    tempCreatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    user_Id?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type ConsultationOrderByRelevanceInput = {
    fields: ConsultationOrderByRelevanceFieldEnum | ConsultationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConsultationCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    date?: SortOrder
    purpose?: SortOrder
    temperature?: SortOrder
    symptoms?: SortOrder
    notes?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medicineInjection?: SortOrder
    scanningTesting?: SortOrder
    status?: SortOrder
    access?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ConsultationAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    temperature?: SortOrder
  }

  export type ConsultationMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    date?: SortOrder
    purpose?: SortOrder
    temperature?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medicineInjection?: SortOrder
    scanningTesting?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ConsultationMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    date?: SortOrder
    purpose?: SortOrder
    temperature?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    treatment?: SortOrder
    medicineInjection?: SortOrder
    scanningTesting?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type ConsultationSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    temperature?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TreatmentOrderByRelevanceInput = {
    fields: TreatmentOrderByRelevanceFieldEnum | TreatmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TreatmentCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staff_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    treatmentName?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type TreatmentAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
  }

  export type TreatmentMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type TreatmentMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentStatus?: SortOrder
  }

  export type TreatmentSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
  }

  export type MedicianOrderByRelevanceInput = {
    fields: MedicianOrderByRelevanceFieldEnum | MedicianOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MedicianCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    medicianName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
    staffId?: SortOrder
  }

  export type MedicianAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type MedicianMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    medicianName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type MedicianMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    medicianName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type MedicianSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type InjectionOrderByRelevanceInput = {
    fields: InjectionOrderByRelevanceFieldEnum | InjectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InjectionCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    injectionName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
    staffId?: SortOrder
  }

  export type InjectionAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type InjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    injectionName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type InjectionMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    injectionName?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type InjectionSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    stock?: SortOrder
    amount?: SortOrder
  }

  export type TestingAndScanningHOrderByRelevanceInput = {
    fields: TestingAndScanningHOrderByRelevanceFieldEnum | TestingAndScanningHOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestingAndScanningHCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    roomNo?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
  }

  export type TestingAndScanningHAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
  }

  export type TestingAndScanningHMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    roomNo?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
  }

  export type TestingAndScanningHMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    roomNo?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
  }

  export type TestingAndScanningHSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    amount?: SortOrder
  }

  export type MedicineAndInjectionOrderByRelevanceInput = {
    fields: MedicineAndInjectionOrderByRelevanceFieldEnum | MedicineAndInjectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MedicineAndInjectionCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    staff_Id?: SortOrder
    medicine_Id?: SortOrder
    frequencyMedicine?: SortOrder
    injection_Id?: SortOrder
    frequencyInjection?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineAndInjectionAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
  }

  export type MedicineAndInjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineAndInjectionMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineAndInjectionSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
  }

  export type TestingAndScanningPOrderByRelevanceInput = {
    fields: TestingAndScanningPOrderByRelevanceFieldEnum | TestingAndScanningPOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestingAndScanningPCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    doctor_Id?: SortOrder
    staff_Id?: SortOrder
    title?: SortOrder
    scheduleDate?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    result?: SortOrder
  }

  export type TestingAndScanningPAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
  }

  export type TestingAndScanningPMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    title?: SortOrder
    scheduleDate?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    result?: SortOrder
  }

  export type TestingAndScanningPMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    title?: SortOrder
    scheduleDate?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    result?: SortOrder
  }

  export type TestingAndScanningPSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    patient_Id?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type RoomsAvailableOrderByRelevanceInput = {
    fields: RoomsAvailableOrderByRelevanceFieldEnum | RoomsAvailableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoomsAvailableCountOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    roomNo?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    amount?: SortOrder
  }

  export type RoomsAvailableAvgOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    capacity?: SortOrder
    amount?: SortOrder
  }

  export type RoomsAvailableMaxOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    roomNo?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    amount?: SortOrder
  }

  export type RoomsAvailableMinOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    roomNo?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    amount?: SortOrder
  }

  export type RoomsAvailableSumOrderByAggregateInput = {
    id?: SortOrder
    hospital_Id?: SortOrder
    staffId?: SortOrder
    capacity?: SortOrder
    amount?: SortOrder
  }

  export type UserCreateNestedManyWithoutHospitalInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput> | UserCreateWithoutHospitalInput[] | UserUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput | UserCreateOrConnectWithoutHospitalInput[]
    createMany?: UserCreateManyHospitalInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutHospitalInput = {
    create?: XOR<AdminCreateWithoutHospitalInput, AdminUncheckedCreateWithoutHospitalInput> | AdminCreateWithoutHospitalInput[] | AdminUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutHospitalInput | AdminCreateOrConnectWithoutHospitalInput[]
    createMany?: AdminCreateManyHospitalInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutHospitalInput = {
    create?: XOR<PatientCreateWithoutHospitalInput, PatientUncheckedCreateWithoutHospitalInput> | PatientCreateWithoutHospitalInput[] | PatientUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutHospitalInput | PatientCreateOrConnectWithoutHospitalInput[]
    createMany?: PatientCreateManyHospitalInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type ConsultationCreateNestedManyWithoutHospitalInput = {
    create?: XOR<ConsultationCreateWithoutHospitalInput, ConsultationUncheckedCreateWithoutHospitalInput> | ConsultationCreateWithoutHospitalInput[] | ConsultationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutHospitalInput | ConsultationCreateOrConnectWithoutHospitalInput[]
    createMany?: ConsultationCreateManyHospitalInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutHospitalInput = {
    create?: XOR<TreatmentCreateWithoutHospitalInput, TreatmentUncheckedCreateWithoutHospitalInput> | TreatmentCreateWithoutHospitalInput[] | TreatmentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutHospitalInput | TreatmentCreateOrConnectWithoutHospitalInput[]
    createMany?: TreatmentCreateManyHospitalInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type MedicianCreateNestedManyWithoutHospitalInput = {
    create?: XOR<MedicianCreateWithoutHospitalInput, MedicianUncheckedCreateWithoutHospitalInput> | MedicianCreateWithoutHospitalInput[] | MedicianUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutHospitalInput | MedicianCreateOrConnectWithoutHospitalInput[]
    createMany?: MedicianCreateManyHospitalInputEnvelope
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
  }

  export type InjectionCreateNestedManyWithoutHospitalInput = {
    create?: XOR<InjectionCreateWithoutHospitalInput, InjectionUncheckedCreateWithoutHospitalInput> | InjectionCreateWithoutHospitalInput[] | InjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutHospitalInput | InjectionCreateOrConnectWithoutHospitalInput[]
    createMany?: InjectionCreateManyHospitalInputEnvelope
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
  }

  export type TestingAndScanningPCreateNestedManyWithoutHospitalInput = {
    create?: XOR<TestingAndScanningPCreateWithoutHospitalInput, TestingAndScanningPUncheckedCreateWithoutHospitalInput> | TestingAndScanningPCreateWithoutHospitalInput[] | TestingAndScanningPUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutHospitalInput | TestingAndScanningPCreateOrConnectWithoutHospitalInput[]
    createMany?: TestingAndScanningPCreateManyHospitalInputEnvelope
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
  }

  export type TestingAndScanningHCreateNestedManyWithoutHospitalInput = {
    create?: XOR<TestingAndScanningHCreateWithoutHospitalInput, TestingAndScanningHUncheckedCreateWithoutHospitalInput> | TestingAndScanningHCreateWithoutHospitalInput[] | TestingAndScanningHUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningHCreateOrConnectWithoutHospitalInput | TestingAndScanningHCreateOrConnectWithoutHospitalInput[]
    createMany?: TestingAndScanningHCreateManyHospitalInputEnvelope
    connect?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
  }

  export type RoomsAvailableCreateNestedManyWithoutHospitalInput = {
    create?: XOR<RoomsAvailableCreateWithoutHospitalInput, RoomsAvailableUncheckedCreateWithoutHospitalInput> | RoomsAvailableCreateWithoutHospitalInput[] | RoomsAvailableUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: RoomsAvailableCreateOrConnectWithoutHospitalInput | RoomsAvailableCreateOrConnectWithoutHospitalInput[]
    createMany?: RoomsAvailableCreateManyHospitalInputEnvelope
    connect?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutHospitalInput = {
    create?: XOR<PaymentCreateWithoutHospitalInput, PaymentUncheckedCreateWithoutHospitalInput> | PaymentCreateWithoutHospitalInput[] | PaymentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutHospitalInput | PaymentCreateOrConnectWithoutHospitalInput[]
    createMany?: PaymentCreateManyHospitalInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MedicineAndInjectionCreateNestedManyWithoutHospitalInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutHospitalInput, MedicineAndInjectionUncheckedCreateWithoutHospitalInput> | MedicineAndInjectionCreateWithoutHospitalInput[] | MedicineAndInjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutHospitalInput | MedicineAndInjectionCreateOrConnectWithoutHospitalInput[]
    createMany?: MedicineAndInjectionCreateManyHospitalInputEnvelope
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput> | UserCreateWithoutHospitalInput[] | UserUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput | UserCreateOrConnectWithoutHospitalInput[]
    createMany?: UserCreateManyHospitalInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<AdminCreateWithoutHospitalInput, AdminUncheckedCreateWithoutHospitalInput> | AdminCreateWithoutHospitalInput[] | AdminUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutHospitalInput | AdminCreateOrConnectWithoutHospitalInput[]
    createMany?: AdminCreateManyHospitalInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<PatientCreateWithoutHospitalInput, PatientUncheckedCreateWithoutHospitalInput> | PatientCreateWithoutHospitalInput[] | PatientUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutHospitalInput | PatientCreateOrConnectWithoutHospitalInput[]
    createMany?: PatientCreateManyHospitalInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<ConsultationCreateWithoutHospitalInput, ConsultationUncheckedCreateWithoutHospitalInput> | ConsultationCreateWithoutHospitalInput[] | ConsultationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutHospitalInput | ConsultationCreateOrConnectWithoutHospitalInput[]
    createMany?: ConsultationCreateManyHospitalInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<TreatmentCreateWithoutHospitalInput, TreatmentUncheckedCreateWithoutHospitalInput> | TreatmentCreateWithoutHospitalInput[] | TreatmentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutHospitalInput | TreatmentCreateOrConnectWithoutHospitalInput[]
    createMany?: TreatmentCreateManyHospitalInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type MedicianUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<MedicianCreateWithoutHospitalInput, MedicianUncheckedCreateWithoutHospitalInput> | MedicianCreateWithoutHospitalInput[] | MedicianUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutHospitalInput | MedicianCreateOrConnectWithoutHospitalInput[]
    createMany?: MedicianCreateManyHospitalInputEnvelope
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
  }

  export type InjectionUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<InjectionCreateWithoutHospitalInput, InjectionUncheckedCreateWithoutHospitalInput> | InjectionCreateWithoutHospitalInput[] | InjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutHospitalInput | InjectionCreateOrConnectWithoutHospitalInput[]
    createMany?: InjectionCreateManyHospitalInputEnvelope
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
  }

  export type TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<TestingAndScanningPCreateWithoutHospitalInput, TestingAndScanningPUncheckedCreateWithoutHospitalInput> | TestingAndScanningPCreateWithoutHospitalInput[] | TestingAndScanningPUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutHospitalInput | TestingAndScanningPCreateOrConnectWithoutHospitalInput[]
    createMany?: TestingAndScanningPCreateManyHospitalInputEnvelope
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
  }

  export type TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<TestingAndScanningHCreateWithoutHospitalInput, TestingAndScanningHUncheckedCreateWithoutHospitalInput> | TestingAndScanningHCreateWithoutHospitalInput[] | TestingAndScanningHUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningHCreateOrConnectWithoutHospitalInput | TestingAndScanningHCreateOrConnectWithoutHospitalInput[]
    createMany?: TestingAndScanningHCreateManyHospitalInputEnvelope
    connect?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
  }

  export type RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<RoomsAvailableCreateWithoutHospitalInput, RoomsAvailableUncheckedCreateWithoutHospitalInput> | RoomsAvailableCreateWithoutHospitalInput[] | RoomsAvailableUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: RoomsAvailableCreateOrConnectWithoutHospitalInput | RoomsAvailableCreateOrConnectWithoutHospitalInput[]
    createMany?: RoomsAvailableCreateManyHospitalInputEnvelope
    connect?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<PaymentCreateWithoutHospitalInput, PaymentUncheckedCreateWithoutHospitalInput> | PaymentCreateWithoutHospitalInput[] | PaymentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutHospitalInput | PaymentCreateOrConnectWithoutHospitalInput[]
    createMany?: PaymentCreateManyHospitalInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutHospitalInput, MedicineAndInjectionUncheckedCreateWithoutHospitalInput> | MedicineAndInjectionCreateWithoutHospitalInput[] | MedicineAndInjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutHospitalInput | MedicineAndInjectionCreateOrConnectWithoutHospitalInput[]
    createMany?: MedicineAndInjectionCreateManyHospitalInputEnvelope
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumHospitalStatusFieldUpdateOperationsInput = {
    set?: $Enums.HospitalStatus
  }

  export type UserUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput> | UserCreateWithoutHospitalInput[] | UserUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput | UserCreateOrConnectWithoutHospitalInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHospitalInput | UserUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: UserCreateManyHospitalInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHospitalInput | UserUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHospitalInput | UserUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<AdminCreateWithoutHospitalInput, AdminUncheckedCreateWithoutHospitalInput> | AdminCreateWithoutHospitalInput[] | AdminUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutHospitalInput | AdminCreateOrConnectWithoutHospitalInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutHospitalInput | AdminUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: AdminCreateManyHospitalInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutHospitalInput | AdminUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutHospitalInput | AdminUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<PatientCreateWithoutHospitalInput, PatientUncheckedCreateWithoutHospitalInput> | PatientCreateWithoutHospitalInput[] | PatientUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutHospitalInput | PatientCreateOrConnectWithoutHospitalInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutHospitalInput | PatientUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: PatientCreateManyHospitalInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutHospitalInput | PatientUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutHospitalInput | PatientUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ConsultationUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<ConsultationCreateWithoutHospitalInput, ConsultationUncheckedCreateWithoutHospitalInput> | ConsultationCreateWithoutHospitalInput[] | ConsultationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutHospitalInput | ConsultationCreateOrConnectWithoutHospitalInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutHospitalInput | ConsultationUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: ConsultationCreateManyHospitalInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutHospitalInput | ConsultationUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutHospitalInput | ConsultationUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<TreatmentCreateWithoutHospitalInput, TreatmentUncheckedCreateWithoutHospitalInput> | TreatmentCreateWithoutHospitalInput[] | TreatmentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutHospitalInput | TreatmentCreateOrConnectWithoutHospitalInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutHospitalInput | TreatmentUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: TreatmentCreateManyHospitalInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutHospitalInput | TreatmentUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutHospitalInput | TreatmentUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type MedicianUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<MedicianCreateWithoutHospitalInput, MedicianUncheckedCreateWithoutHospitalInput> | MedicianCreateWithoutHospitalInput[] | MedicianUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutHospitalInput | MedicianCreateOrConnectWithoutHospitalInput[]
    upsert?: MedicianUpsertWithWhereUniqueWithoutHospitalInput | MedicianUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: MedicianCreateManyHospitalInputEnvelope
    set?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    disconnect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    delete?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    update?: MedicianUpdateWithWhereUniqueWithoutHospitalInput | MedicianUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: MedicianUpdateManyWithWhereWithoutHospitalInput | MedicianUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: MedicianScalarWhereInput | MedicianScalarWhereInput[]
  }

  export type InjectionUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<InjectionCreateWithoutHospitalInput, InjectionUncheckedCreateWithoutHospitalInput> | InjectionCreateWithoutHospitalInput[] | InjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutHospitalInput | InjectionCreateOrConnectWithoutHospitalInput[]
    upsert?: InjectionUpsertWithWhereUniqueWithoutHospitalInput | InjectionUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: InjectionCreateManyHospitalInputEnvelope
    set?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    disconnect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    delete?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    update?: InjectionUpdateWithWhereUniqueWithoutHospitalInput | InjectionUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: InjectionUpdateManyWithWhereWithoutHospitalInput | InjectionUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: InjectionScalarWhereInput | InjectionScalarWhereInput[]
  }

  export type TestingAndScanningPUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<TestingAndScanningPCreateWithoutHospitalInput, TestingAndScanningPUncheckedCreateWithoutHospitalInput> | TestingAndScanningPCreateWithoutHospitalInput[] | TestingAndScanningPUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutHospitalInput | TestingAndScanningPCreateOrConnectWithoutHospitalInput[]
    upsert?: TestingAndScanningPUpsertWithWhereUniqueWithoutHospitalInput | TestingAndScanningPUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: TestingAndScanningPCreateManyHospitalInputEnvelope
    set?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    disconnect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    delete?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    update?: TestingAndScanningPUpdateWithWhereUniqueWithoutHospitalInput | TestingAndScanningPUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: TestingAndScanningPUpdateManyWithWhereWithoutHospitalInput | TestingAndScanningPUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: TestingAndScanningPScalarWhereInput | TestingAndScanningPScalarWhereInput[]
  }

  export type TestingAndScanningHUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<TestingAndScanningHCreateWithoutHospitalInput, TestingAndScanningHUncheckedCreateWithoutHospitalInput> | TestingAndScanningHCreateWithoutHospitalInput[] | TestingAndScanningHUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningHCreateOrConnectWithoutHospitalInput | TestingAndScanningHCreateOrConnectWithoutHospitalInput[]
    upsert?: TestingAndScanningHUpsertWithWhereUniqueWithoutHospitalInput | TestingAndScanningHUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: TestingAndScanningHCreateManyHospitalInputEnvelope
    set?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    disconnect?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    delete?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    connect?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    update?: TestingAndScanningHUpdateWithWhereUniqueWithoutHospitalInput | TestingAndScanningHUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: TestingAndScanningHUpdateManyWithWhereWithoutHospitalInput | TestingAndScanningHUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: TestingAndScanningHScalarWhereInput | TestingAndScanningHScalarWhereInput[]
  }

  export type RoomsAvailableUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<RoomsAvailableCreateWithoutHospitalInput, RoomsAvailableUncheckedCreateWithoutHospitalInput> | RoomsAvailableCreateWithoutHospitalInput[] | RoomsAvailableUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: RoomsAvailableCreateOrConnectWithoutHospitalInput | RoomsAvailableCreateOrConnectWithoutHospitalInput[]
    upsert?: RoomsAvailableUpsertWithWhereUniqueWithoutHospitalInput | RoomsAvailableUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: RoomsAvailableCreateManyHospitalInputEnvelope
    set?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    disconnect?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    delete?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    connect?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    update?: RoomsAvailableUpdateWithWhereUniqueWithoutHospitalInput | RoomsAvailableUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: RoomsAvailableUpdateManyWithWhereWithoutHospitalInput | RoomsAvailableUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: RoomsAvailableScalarWhereInput | RoomsAvailableScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<PaymentCreateWithoutHospitalInput, PaymentUncheckedCreateWithoutHospitalInput> | PaymentCreateWithoutHospitalInput[] | PaymentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutHospitalInput | PaymentCreateOrConnectWithoutHospitalInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutHospitalInput | PaymentUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: PaymentCreateManyHospitalInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutHospitalInput | PaymentUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutHospitalInput | PaymentUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MedicineAndInjectionUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutHospitalInput, MedicineAndInjectionUncheckedCreateWithoutHospitalInput> | MedicineAndInjectionCreateWithoutHospitalInput[] | MedicineAndInjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutHospitalInput | MedicineAndInjectionCreateOrConnectWithoutHospitalInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutHospitalInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: MedicineAndInjectionCreateManyHospitalInputEnvelope
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutHospitalInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutHospitalInput | MedicineAndInjectionUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput> | UserCreateWithoutHospitalInput[] | UserUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHospitalInput | UserCreateOrConnectWithoutHospitalInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHospitalInput | UserUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: UserCreateManyHospitalInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHospitalInput | UserUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHospitalInput | UserUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<AdminCreateWithoutHospitalInput, AdminUncheckedCreateWithoutHospitalInput> | AdminCreateWithoutHospitalInput[] | AdminUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutHospitalInput | AdminCreateOrConnectWithoutHospitalInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutHospitalInput | AdminUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: AdminCreateManyHospitalInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutHospitalInput | AdminUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutHospitalInput | AdminUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<PatientCreateWithoutHospitalInput, PatientUncheckedCreateWithoutHospitalInput> | PatientCreateWithoutHospitalInput[] | PatientUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutHospitalInput | PatientCreateOrConnectWithoutHospitalInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutHospitalInput | PatientUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: PatientCreateManyHospitalInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutHospitalInput | PatientUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutHospitalInput | PatientUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ConsultationUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<ConsultationCreateWithoutHospitalInput, ConsultationUncheckedCreateWithoutHospitalInput> | ConsultationCreateWithoutHospitalInput[] | ConsultationUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutHospitalInput | ConsultationCreateOrConnectWithoutHospitalInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutHospitalInput | ConsultationUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: ConsultationCreateManyHospitalInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutHospitalInput | ConsultationUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutHospitalInput | ConsultationUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<TreatmentCreateWithoutHospitalInput, TreatmentUncheckedCreateWithoutHospitalInput> | TreatmentCreateWithoutHospitalInput[] | TreatmentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutHospitalInput | TreatmentCreateOrConnectWithoutHospitalInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutHospitalInput | TreatmentUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: TreatmentCreateManyHospitalInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutHospitalInput | TreatmentUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutHospitalInput | TreatmentUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type MedicianUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<MedicianCreateWithoutHospitalInput, MedicianUncheckedCreateWithoutHospitalInput> | MedicianCreateWithoutHospitalInput[] | MedicianUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutHospitalInput | MedicianCreateOrConnectWithoutHospitalInput[]
    upsert?: MedicianUpsertWithWhereUniqueWithoutHospitalInput | MedicianUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: MedicianCreateManyHospitalInputEnvelope
    set?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    disconnect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    delete?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    update?: MedicianUpdateWithWhereUniqueWithoutHospitalInput | MedicianUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: MedicianUpdateManyWithWhereWithoutHospitalInput | MedicianUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: MedicianScalarWhereInput | MedicianScalarWhereInput[]
  }

  export type InjectionUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<InjectionCreateWithoutHospitalInput, InjectionUncheckedCreateWithoutHospitalInput> | InjectionCreateWithoutHospitalInput[] | InjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutHospitalInput | InjectionCreateOrConnectWithoutHospitalInput[]
    upsert?: InjectionUpsertWithWhereUniqueWithoutHospitalInput | InjectionUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: InjectionCreateManyHospitalInputEnvelope
    set?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    disconnect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    delete?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    update?: InjectionUpdateWithWhereUniqueWithoutHospitalInput | InjectionUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: InjectionUpdateManyWithWhereWithoutHospitalInput | InjectionUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: InjectionScalarWhereInput | InjectionScalarWhereInput[]
  }

  export type TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<TestingAndScanningPCreateWithoutHospitalInput, TestingAndScanningPUncheckedCreateWithoutHospitalInput> | TestingAndScanningPCreateWithoutHospitalInput[] | TestingAndScanningPUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutHospitalInput | TestingAndScanningPCreateOrConnectWithoutHospitalInput[]
    upsert?: TestingAndScanningPUpsertWithWhereUniqueWithoutHospitalInput | TestingAndScanningPUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: TestingAndScanningPCreateManyHospitalInputEnvelope
    set?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    disconnect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    delete?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    update?: TestingAndScanningPUpdateWithWhereUniqueWithoutHospitalInput | TestingAndScanningPUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: TestingAndScanningPUpdateManyWithWhereWithoutHospitalInput | TestingAndScanningPUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: TestingAndScanningPScalarWhereInput | TestingAndScanningPScalarWhereInput[]
  }

  export type TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<TestingAndScanningHCreateWithoutHospitalInput, TestingAndScanningHUncheckedCreateWithoutHospitalInput> | TestingAndScanningHCreateWithoutHospitalInput[] | TestingAndScanningHUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: TestingAndScanningHCreateOrConnectWithoutHospitalInput | TestingAndScanningHCreateOrConnectWithoutHospitalInput[]
    upsert?: TestingAndScanningHUpsertWithWhereUniqueWithoutHospitalInput | TestingAndScanningHUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: TestingAndScanningHCreateManyHospitalInputEnvelope
    set?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    disconnect?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    delete?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    connect?: TestingAndScanningHWhereUniqueInput | TestingAndScanningHWhereUniqueInput[]
    update?: TestingAndScanningHUpdateWithWhereUniqueWithoutHospitalInput | TestingAndScanningHUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: TestingAndScanningHUpdateManyWithWhereWithoutHospitalInput | TestingAndScanningHUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: TestingAndScanningHScalarWhereInput | TestingAndScanningHScalarWhereInput[]
  }

  export type RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<RoomsAvailableCreateWithoutHospitalInput, RoomsAvailableUncheckedCreateWithoutHospitalInput> | RoomsAvailableCreateWithoutHospitalInput[] | RoomsAvailableUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: RoomsAvailableCreateOrConnectWithoutHospitalInput | RoomsAvailableCreateOrConnectWithoutHospitalInput[]
    upsert?: RoomsAvailableUpsertWithWhereUniqueWithoutHospitalInput | RoomsAvailableUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: RoomsAvailableCreateManyHospitalInputEnvelope
    set?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    disconnect?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    delete?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    connect?: RoomsAvailableWhereUniqueInput | RoomsAvailableWhereUniqueInput[]
    update?: RoomsAvailableUpdateWithWhereUniqueWithoutHospitalInput | RoomsAvailableUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: RoomsAvailableUpdateManyWithWhereWithoutHospitalInput | RoomsAvailableUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: RoomsAvailableScalarWhereInput | RoomsAvailableScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<PaymentCreateWithoutHospitalInput, PaymentUncheckedCreateWithoutHospitalInput> | PaymentCreateWithoutHospitalInput[] | PaymentUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutHospitalInput | PaymentCreateOrConnectWithoutHospitalInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutHospitalInput | PaymentUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: PaymentCreateManyHospitalInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutHospitalInput | PaymentUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutHospitalInput | PaymentUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutHospitalInput, MedicineAndInjectionUncheckedCreateWithoutHospitalInput> | MedicineAndInjectionCreateWithoutHospitalInput[] | MedicineAndInjectionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutHospitalInput | MedicineAndInjectionCreateOrConnectWithoutHospitalInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutHospitalInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: MedicineAndInjectionCreateManyHospitalInputEnvelope
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutHospitalInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutHospitalInput | MedicineAndInjectionUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type AdminStratorCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminStratorCreateWithoutUserInput, AdminStratorUncheckedCreateWithoutUserInput> | AdminStratorCreateWithoutUserInput[] | AdminStratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminStratorCreateOrConnectWithoutUserInput | AdminStratorCreateOrConnectWithoutUserInput[]
    createMany?: AdminStratorCreateManyUserInputEnvelope
    connect?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type HospitalCreateNestedOneWithoutUsersInput = {
    create?: XOR<HospitalCreateWithoutUsersInput, HospitalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutUsersInput
    connect?: HospitalWhereUniqueInput
  }

  export type AdminStratorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminStratorCreateWithoutUserInput, AdminStratorUncheckedCreateWithoutUserInput> | AdminStratorCreateWithoutUserInput[] | AdminStratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminStratorCreateOrConnectWithoutUserInput | AdminStratorCreateOrConnectWithoutUserInput[]
    createMany?: AdminStratorCreateManyUserInputEnvelope
    connect?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type AdminStratorUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminStratorCreateWithoutUserInput, AdminStratorUncheckedCreateWithoutUserInput> | AdminStratorCreateWithoutUserInput[] | AdminStratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminStratorCreateOrConnectWithoutUserInput | AdminStratorCreateOrConnectWithoutUserInput[]
    upsert?: AdminStratorUpsertWithWhereUniqueWithoutUserInput | AdminStratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminStratorCreateManyUserInputEnvelope
    set?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    disconnect?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    delete?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    connect?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    update?: AdminStratorUpdateWithWhereUniqueWithoutUserInput | AdminStratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminStratorUpdateManyWithWhereWithoutUserInput | AdminStratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminStratorScalarWhereInput | AdminStratorScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutUserInput | AdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutUserInput | AdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutUserInput | AdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutUserInput | PatientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutUserInput | PatientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutUserInput | PatientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type HospitalUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<HospitalCreateWithoutUsersInput, HospitalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutUsersInput
    upsert?: HospitalUpsertWithoutUsersInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutUsersInput, HospitalUpdateWithoutUsersInput>, HospitalUncheckedUpdateWithoutUsersInput>
  }

  export type AdminStratorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminStratorCreateWithoutUserInput, AdminStratorUncheckedCreateWithoutUserInput> | AdminStratorCreateWithoutUserInput[] | AdminStratorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminStratorCreateOrConnectWithoutUserInput | AdminStratorCreateOrConnectWithoutUserInput[]
    upsert?: AdminStratorUpsertWithWhereUniqueWithoutUserInput | AdminStratorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminStratorCreateManyUserInputEnvelope
    set?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    disconnect?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    delete?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    connect?: AdminStratorWhereUniqueInput | AdminStratorWhereUniqueInput[]
    update?: AdminStratorUpdateWithWhereUniqueWithoutUserInput | AdminStratorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminStratorUpdateManyWithWhereWithoutUserInput | AdminStratorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminStratorScalarWhereInput | AdminStratorScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutUserInput | AdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutUserInput | AdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutUserInput | AdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput> | PatientCreateWithoutUserInput[] | PatientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput | PatientCreateOrConnectWithoutUserInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutUserInput | PatientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PatientCreateManyUserInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutUserInput | PatientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutUserInput | PatientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ConsultationCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ConsultationCreateWithoutDoctorInput, ConsultationUncheckedCreateWithoutDoctorInput> | ConsultationCreateWithoutDoctorInput[] | ConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutDoctorInput | ConsultationCreateOrConnectWithoutDoctorInput[]
    createMany?: ConsultationCreateManyDoctorInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutStaffInput = {
    create?: XOR<TreatmentCreateWithoutStaffInput, TreatmentUncheckedCreateWithoutStaffInput> | TreatmentCreateWithoutStaffInput[] | TreatmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutStaffInput | TreatmentCreateOrConnectWithoutStaffInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type HospitalCreateNestedOneWithoutAdminsInput = {
    create?: XOR<HospitalCreateWithoutAdminsInput, HospitalUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutAdminsInput
    connect?: HospitalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type ConsultationUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ConsultationCreateWithoutDoctorInput, ConsultationUncheckedCreateWithoutDoctorInput> | ConsultationCreateWithoutDoctorInput[] | ConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutDoctorInput | ConsultationCreateOrConnectWithoutDoctorInput[]
    createMany?: ConsultationCreateManyDoctorInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<TreatmentCreateWithoutStaffInput, TreatmentUncheckedCreateWithoutStaffInput> | TreatmentCreateWithoutStaffInput[] | TreatmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutStaffInput | TreatmentCreateOrConnectWithoutStaffInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ConsultationUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ConsultationCreateWithoutDoctorInput, ConsultationUncheckedCreateWithoutDoctorInput> | ConsultationCreateWithoutDoctorInput[] | ConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutDoctorInput | ConsultationCreateOrConnectWithoutDoctorInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutDoctorInput | ConsultationUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ConsultationCreateManyDoctorInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutDoctorInput | ConsultationUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutDoctorInput | ConsultationUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutDoctorInput | TreatmentUpsertWithWhereUniqueWithoutDoctorInput[]
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutDoctorInput | TreatmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutDoctorInput | TreatmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutStaffNestedInput = {
    create?: XOR<TreatmentCreateWithoutStaffInput, TreatmentUncheckedCreateWithoutStaffInput> | TreatmentCreateWithoutStaffInput[] | TreatmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutStaffInput | TreatmentCreateOrConnectWithoutStaffInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutStaffInput | TreatmentUpsertWithWhereUniqueWithoutStaffInput[]
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutStaffInput | TreatmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutStaffInput | TreatmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type HospitalUpdateOneRequiredWithoutAdminsNestedInput = {
    create?: XOR<HospitalCreateWithoutAdminsInput, HospitalUncheckedCreateWithoutAdminsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutAdminsInput
    upsert?: HospitalUpsertWithoutAdminsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutAdminsInput, HospitalUpdateWithoutAdminsInput>, HospitalUncheckedUpdateWithoutAdminsInput>
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type ConsultationUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ConsultationCreateWithoutDoctorInput, ConsultationUncheckedCreateWithoutDoctorInput> | ConsultationCreateWithoutDoctorInput[] | ConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutDoctorInput | ConsultationCreateOrConnectWithoutDoctorInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutDoctorInput | ConsultationUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ConsultationCreateManyDoctorInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutDoctorInput | ConsultationUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutDoctorInput | ConsultationUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput> | TreatmentCreateWithoutDoctorInput[] | TreatmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutDoctorInput | TreatmentCreateOrConnectWithoutDoctorInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutDoctorInput | TreatmentUpsertWithWhereUniqueWithoutDoctorInput[]
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutDoctorInput | TreatmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutDoctorInput | TreatmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<TreatmentCreateWithoutStaffInput, TreatmentUncheckedCreateWithoutStaffInput> | TreatmentCreateWithoutStaffInput[] | TreatmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutStaffInput | TreatmentCreateOrConnectWithoutStaffInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutStaffInput | TreatmentUpsertWithWhereUniqueWithoutStaffInput[]
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutStaffInput | TreatmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutStaffInput | TreatmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminStratorInput = {
    create?: XOR<UserCreateWithoutAdminStratorInput, UserUncheckedCreateWithoutAdminStratorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminStratorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminStratorNestedInput = {
    create?: XOR<UserCreateWithoutAdminStratorInput, UserUncheckedCreateWithoutAdminStratorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminStratorInput
    upsert?: UserUpsertWithoutAdminStratorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminStratorInput, UserUpdateWithoutAdminStratorInput>, UserUncheckedUpdateWithoutAdminStratorInput>
  }

  export type ConsultationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type TreatmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<TreatmentCreateWithoutPatientInput, TreatmentUncheckedCreateWithoutPatientInput> | TreatmentCreateWithoutPatientInput[] | TreatmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPatientInput | TreatmentCreateOrConnectWithoutPatientInput[]
    createMany?: TreatmentCreateManyPatientInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type MedicineAndInjectionCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutPatientInput, MedicineAndInjectionUncheckedCreateWithoutPatientInput> | MedicineAndInjectionCreateWithoutPatientInput[] | MedicineAndInjectionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutPatientInput | MedicineAndInjectionCreateOrConnectWithoutPatientInput[]
    createMany?: MedicineAndInjectionCreateManyPatientInputEnvelope
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type TestingAndScanningPCreateNestedManyWithoutPatientInput = {
    create?: XOR<TestingAndScanningPCreateWithoutPatientInput, TestingAndScanningPUncheckedCreateWithoutPatientInput> | TestingAndScanningPCreateWithoutPatientInput[] | TestingAndScanningPUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutPatientInput | TestingAndScanningPCreateOrConnectWithoutPatientInput[]
    createMany?: TestingAndScanningPCreateManyPatientInputEnvelope
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type HospitalCreateNestedOneWithoutPatientsInput = {
    create?: XOR<HospitalCreateWithoutPatientsInput, HospitalUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutPatientsInput
    connect?: HospitalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPatientInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    connect?: UserWhereUniqueInput
  }

  export type ConsultationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type TreatmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TreatmentCreateWithoutPatientInput, TreatmentUncheckedCreateWithoutPatientInput> | TreatmentCreateWithoutPatientInput[] | TreatmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPatientInput | TreatmentCreateOrConnectWithoutPatientInput[]
    createMany?: TreatmentCreateManyPatientInputEnvelope
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
  }

  export type MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutPatientInput, MedicineAndInjectionUncheckedCreateWithoutPatientInput> | MedicineAndInjectionCreateWithoutPatientInput[] | MedicineAndInjectionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutPatientInput | MedicineAndInjectionCreateOrConnectWithoutPatientInput[]
    createMany?: MedicineAndInjectionCreateManyPatientInputEnvelope
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TestingAndScanningPCreateWithoutPatientInput, TestingAndScanningPUncheckedCreateWithoutPatientInput> | TestingAndScanningPCreateWithoutPatientInput[] | TestingAndScanningPUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutPatientInput | TestingAndScanningPCreateOrConnectWithoutPatientInput[]
    createMany?: TestingAndScanningPCreateManyPatientInputEnvelope
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConsultationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type TreatmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TreatmentCreateWithoutPatientInput, TreatmentUncheckedCreateWithoutPatientInput> | TreatmentCreateWithoutPatientInput[] | TreatmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPatientInput | TreatmentCreateOrConnectWithoutPatientInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutPatientInput | TreatmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TreatmentCreateManyPatientInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutPatientInput | TreatmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutPatientInput | TreatmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type MedicineAndInjectionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutPatientInput, MedicineAndInjectionUncheckedCreateWithoutPatientInput> | MedicineAndInjectionCreateWithoutPatientInput[] | MedicineAndInjectionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutPatientInput | MedicineAndInjectionCreateOrConnectWithoutPatientInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutPatientInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicineAndInjectionCreateManyPatientInputEnvelope
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutPatientInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutPatientInput | MedicineAndInjectionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type TestingAndScanningPUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TestingAndScanningPCreateWithoutPatientInput, TestingAndScanningPUncheckedCreateWithoutPatientInput> | TestingAndScanningPCreateWithoutPatientInput[] | TestingAndScanningPUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutPatientInput | TestingAndScanningPCreateOrConnectWithoutPatientInput[]
    upsert?: TestingAndScanningPUpsertWithWhereUniqueWithoutPatientInput | TestingAndScanningPUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TestingAndScanningPCreateManyPatientInputEnvelope
    set?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    disconnect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    delete?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    update?: TestingAndScanningPUpdateWithWhereUniqueWithoutPatientInput | TestingAndScanningPUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TestingAndScanningPUpdateManyWithWhereWithoutPatientInput | TestingAndScanningPUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TestingAndScanningPScalarWhereInput | TestingAndScanningPScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type HospitalUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<HospitalCreateWithoutPatientsInput, HospitalUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutPatientsInput
    upsert?: HospitalUpsertWithoutPatientsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutPatientsInput, HospitalUpdateWithoutPatientsInput>, HospitalUncheckedUpdateWithoutPatientsInput>
  }

  export type UserUpdateOneRequiredWithoutPatientNestedInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    upsert?: UserUpsertWithoutPatientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientInput, UserUpdateWithoutPatientInput>, UserUncheckedUpdateWithoutPatientInput>
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type TreatmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TreatmentCreateWithoutPatientInput, TreatmentUncheckedCreateWithoutPatientInput> | TreatmentCreateWithoutPatientInput[] | TreatmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentCreateOrConnectWithoutPatientInput | TreatmentCreateOrConnectWithoutPatientInput[]
    upsert?: TreatmentUpsertWithWhereUniqueWithoutPatientInput | TreatmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TreatmentCreateManyPatientInputEnvelope
    set?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    disconnect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    delete?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    connect?: TreatmentWhereUniqueInput | TreatmentWhereUniqueInput[]
    update?: TreatmentUpdateWithWhereUniqueWithoutPatientInput | TreatmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TreatmentUpdateManyWithWhereWithoutPatientInput | TreatmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutPatientInput, MedicineAndInjectionUncheckedCreateWithoutPatientInput> | MedicineAndInjectionCreateWithoutPatientInput[] | MedicineAndInjectionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutPatientInput | MedicineAndInjectionCreateOrConnectWithoutPatientInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutPatientInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicineAndInjectionCreateManyPatientInputEnvelope
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutPatientInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutPatientInput | MedicineAndInjectionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TestingAndScanningPCreateWithoutPatientInput, TestingAndScanningPUncheckedCreateWithoutPatientInput> | TestingAndScanningPCreateWithoutPatientInput[] | TestingAndScanningPUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TestingAndScanningPCreateOrConnectWithoutPatientInput | TestingAndScanningPCreateOrConnectWithoutPatientInput[]
    upsert?: TestingAndScanningPUpsertWithWhereUniqueWithoutPatientInput | TestingAndScanningPUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TestingAndScanningPCreateManyPatientInputEnvelope
    set?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    disconnect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    delete?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    connect?: TestingAndScanningPWhereUniqueInput | TestingAndScanningPWhereUniqueInput[]
    update?: TestingAndScanningPUpdateWithWhereUniqueWithoutPatientInput | TestingAndScanningPUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TestingAndScanningPUpdateManyWithWhereWithoutPatientInput | TestingAndScanningPUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TestingAndScanningPScalarWhereInput | TestingAndScanningPScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput> | PaymentCreateWithoutPatientInput[] | PaymentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPatientInput | PaymentCreateOrConnectWithoutPatientInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPatientInput | PaymentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PaymentCreateManyPatientInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPatientInput | PaymentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPatientInput | PaymentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type HospitalCreateNestedOneWithoutConsultationInput = {
    create?: XOR<HospitalCreateWithoutConsultationInput, HospitalUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutConsultationInput
    connect?: HospitalWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutConsultationInput = {
    create?: XOR<PatientCreateWithoutConsultationInput, PatientUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationInput
    connect?: PatientWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutConsultationInput = {
    create?: XOR<AdminCreateWithoutConsultationInput, AdminUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: AdminCreateOrConnectWithoutConsultationInput
    connect?: AdminWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type HospitalUpdateOneRequiredWithoutConsultationNestedInput = {
    create?: XOR<HospitalCreateWithoutConsultationInput, HospitalUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutConsultationInput
    upsert?: HospitalUpsertWithoutConsultationInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutConsultationInput, HospitalUpdateWithoutConsultationInput>, HospitalUncheckedUpdateWithoutConsultationInput>
  }

  export type PatientUpdateOneRequiredWithoutConsultationNestedInput = {
    create?: XOR<PatientCreateWithoutConsultationInput, PatientUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationInput
    upsert?: PatientUpsertWithoutConsultationInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsultationInput, PatientUpdateWithoutConsultationInput>, PatientUncheckedUpdateWithoutConsultationInput>
  }

  export type AdminUpdateOneRequiredWithoutConsultationNestedInput = {
    create?: XOR<AdminCreateWithoutConsultationInput, AdminUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: AdminCreateOrConnectWithoutConsultationInput
    upsert?: AdminUpsertWithoutConsultationInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutConsultationInput, AdminUpdateWithoutConsultationInput>, AdminUncheckedUpdateWithoutConsultationInput>
  }

  export type HospitalCreateNestedOneWithoutTreatmentsInput = {
    create?: XOR<HospitalCreateWithoutTreatmentsInput, HospitalUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutTreatmentsInput
    connect?: HospitalWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutTreatmentInput = {
    create?: XOR<PatientCreateWithoutTreatmentInput, PatientUncheckedCreateWithoutTreatmentInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTreatmentInput
    connect?: PatientWhereUniqueInput
  }

  export type AdminCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AdminCreateWithoutDoctorInput, AdminUncheckedCreateWithoutDoctorInput> | AdminCreateWithoutDoctorInput[] | AdminUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutDoctorInput | AdminCreateOrConnectWithoutDoctorInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutStaffInput = {
    create?: XOR<AdminCreateWithoutStaffInput, AdminUncheckedCreateWithoutStaffInput> | AdminCreateWithoutStaffInput[] | AdminUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutStaffInput | AdminCreateOrConnectWithoutStaffInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AdminCreateWithoutDoctorInput, AdminUncheckedCreateWithoutDoctorInput> | AdminCreateWithoutDoctorInput[] | AdminUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutDoctorInput | AdminCreateOrConnectWithoutDoctorInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<AdminCreateWithoutStaffInput, AdminUncheckedCreateWithoutStaffInput> | AdminCreateWithoutStaffInput[] | AdminUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutStaffInput | AdminCreateOrConnectWithoutStaffInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type HospitalUpdateOneRequiredWithoutTreatmentsNestedInput = {
    create?: XOR<HospitalCreateWithoutTreatmentsInput, HospitalUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutTreatmentsInput
    upsert?: HospitalUpsertWithoutTreatmentsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutTreatmentsInput, HospitalUpdateWithoutTreatmentsInput>, HospitalUncheckedUpdateWithoutTreatmentsInput>
  }

  export type PatientUpdateOneRequiredWithoutTreatmentNestedInput = {
    create?: XOR<PatientCreateWithoutTreatmentInput, PatientUncheckedCreateWithoutTreatmentInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTreatmentInput
    upsert?: PatientUpsertWithoutTreatmentInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTreatmentInput, PatientUpdateWithoutTreatmentInput>, PatientUncheckedUpdateWithoutTreatmentInput>
  }

  export type AdminUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AdminCreateWithoutDoctorInput, AdminUncheckedCreateWithoutDoctorInput> | AdminCreateWithoutDoctorInput[] | AdminUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutDoctorInput | AdminCreateOrConnectWithoutDoctorInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutDoctorInput | AdminUpsertWithWhereUniqueWithoutDoctorInput[]
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutDoctorInput | AdminUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutDoctorInput | AdminUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AdminCreateWithoutStaffInput, AdminUncheckedCreateWithoutStaffInput> | AdminCreateWithoutStaffInput[] | AdminUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutStaffInput | AdminCreateOrConnectWithoutStaffInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutStaffInput | AdminUpsertWithWhereUniqueWithoutStaffInput[]
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutStaffInput | AdminUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutStaffInput | AdminUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AdminCreateWithoutDoctorInput, AdminUncheckedCreateWithoutDoctorInput> | AdminCreateWithoutDoctorInput[] | AdminUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutDoctorInput | AdminCreateOrConnectWithoutDoctorInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutDoctorInput | AdminUpsertWithWhereUniqueWithoutDoctorInput[]
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutDoctorInput | AdminUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutDoctorInput | AdminUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AdminCreateWithoutStaffInput, AdminUncheckedCreateWithoutStaffInput> | AdminCreateWithoutStaffInput[] | AdminUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutStaffInput | AdminCreateOrConnectWithoutStaffInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutStaffInput | AdminUpsertWithWhereUniqueWithoutStaffInput[]
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutStaffInput | AdminUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutStaffInput | AdminUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type MedicineAndInjectionCreateNestedManyWithoutMedicianInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutMedicianInput, MedicineAndInjectionUncheckedCreateWithoutMedicianInput> | MedicineAndInjectionCreateWithoutMedicianInput[] | MedicineAndInjectionUncheckedCreateWithoutMedicianInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutMedicianInput | MedicineAndInjectionCreateOrConnectWithoutMedicianInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type HospitalCreateNestedOneWithoutMediciansInput = {
    create?: XOR<HospitalCreateWithoutMediciansInput, HospitalUncheckedCreateWithoutMediciansInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutMediciansInput
    connect?: HospitalWhereUniqueInput
  }

  export type MedicineAndInjectionUncheckedCreateNestedManyWithoutMedicianInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutMedicianInput, MedicineAndInjectionUncheckedCreateWithoutMedicianInput> | MedicineAndInjectionCreateWithoutMedicianInput[] | MedicineAndInjectionUncheckedCreateWithoutMedicianInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutMedicianInput | MedicineAndInjectionCreateOrConnectWithoutMedicianInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type MedicineAndInjectionUpdateManyWithoutMedicianNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutMedicianInput, MedicineAndInjectionUncheckedCreateWithoutMedicianInput> | MedicineAndInjectionCreateWithoutMedicianInput[] | MedicineAndInjectionUncheckedCreateWithoutMedicianInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutMedicianInput | MedicineAndInjectionCreateOrConnectWithoutMedicianInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutMedicianInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutMedicianInput[]
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutMedicianInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutMedicianInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutMedicianInput | MedicineAndInjectionUpdateManyWithWhereWithoutMedicianInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type HospitalUpdateOneRequiredWithoutMediciansNestedInput = {
    create?: XOR<HospitalCreateWithoutMediciansInput, HospitalUncheckedCreateWithoutMediciansInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutMediciansInput
    upsert?: HospitalUpsertWithoutMediciansInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutMediciansInput, HospitalUpdateWithoutMediciansInput>, HospitalUncheckedUpdateWithoutMediciansInput>
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutMedicianNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutMedicianInput, MedicineAndInjectionUncheckedCreateWithoutMedicianInput> | MedicineAndInjectionCreateWithoutMedicianInput[] | MedicineAndInjectionUncheckedCreateWithoutMedicianInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutMedicianInput | MedicineAndInjectionCreateOrConnectWithoutMedicianInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutMedicianInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutMedicianInput[]
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutMedicianInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutMedicianInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutMedicianInput | MedicineAndInjectionUpdateManyWithWhereWithoutMedicianInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type MedicineAndInjectionCreateNestedManyWithoutInjectionInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutInjectionInput, MedicineAndInjectionUncheckedCreateWithoutInjectionInput> | MedicineAndInjectionCreateWithoutInjectionInput[] | MedicineAndInjectionUncheckedCreateWithoutInjectionInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutInjectionInput | MedicineAndInjectionCreateOrConnectWithoutInjectionInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type HospitalCreateNestedOneWithoutInjectionsInput = {
    create?: XOR<HospitalCreateWithoutInjectionsInput, HospitalUncheckedCreateWithoutInjectionsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutInjectionsInput
    connect?: HospitalWhereUniqueInput
  }

  export type MedicineAndInjectionUncheckedCreateNestedManyWithoutInjectionInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutInjectionInput, MedicineAndInjectionUncheckedCreateWithoutInjectionInput> | MedicineAndInjectionCreateWithoutInjectionInput[] | MedicineAndInjectionUncheckedCreateWithoutInjectionInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutInjectionInput | MedicineAndInjectionCreateOrConnectWithoutInjectionInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
  }

  export type MedicineAndInjectionUpdateManyWithoutInjectionNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutInjectionInput, MedicineAndInjectionUncheckedCreateWithoutInjectionInput> | MedicineAndInjectionCreateWithoutInjectionInput[] | MedicineAndInjectionUncheckedCreateWithoutInjectionInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutInjectionInput | MedicineAndInjectionCreateOrConnectWithoutInjectionInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutInjectionInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutInjectionInput[]
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutInjectionInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutInjectionInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutInjectionInput | MedicineAndInjectionUpdateManyWithWhereWithoutInjectionInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type HospitalUpdateOneRequiredWithoutInjectionsNestedInput = {
    create?: XOR<HospitalCreateWithoutInjectionsInput, HospitalUncheckedCreateWithoutInjectionsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutInjectionsInput
    upsert?: HospitalUpsertWithoutInjectionsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutInjectionsInput, HospitalUpdateWithoutInjectionsInput>, HospitalUncheckedUpdateWithoutInjectionsInput>
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutInjectionNestedInput = {
    create?: XOR<MedicineAndInjectionCreateWithoutInjectionInput, MedicineAndInjectionUncheckedCreateWithoutInjectionInput> | MedicineAndInjectionCreateWithoutInjectionInput[] | MedicineAndInjectionUncheckedCreateWithoutInjectionInput[]
    connectOrCreate?: MedicineAndInjectionCreateOrConnectWithoutInjectionInput | MedicineAndInjectionCreateOrConnectWithoutInjectionInput[]
    upsert?: MedicineAndInjectionUpsertWithWhereUniqueWithoutInjectionInput | MedicineAndInjectionUpsertWithWhereUniqueWithoutInjectionInput[]
    set?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    disconnect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    delete?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    connect?: MedicineAndInjectionWhereUniqueInput | MedicineAndInjectionWhereUniqueInput[]
    update?: MedicineAndInjectionUpdateWithWhereUniqueWithoutInjectionInput | MedicineAndInjectionUpdateWithWhereUniqueWithoutInjectionInput[]
    updateMany?: MedicineAndInjectionUpdateManyWithWhereWithoutInjectionInput | MedicineAndInjectionUpdateManyWithWhereWithoutInjectionInput[]
    deleteMany?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
  }

  export type HospitalCreateNestedOneWithoutTestingAndScanningHsInput = {
    create?: XOR<HospitalCreateWithoutTestingAndScanningHsInput, HospitalUncheckedCreateWithoutTestingAndScanningHsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutTestingAndScanningHsInput
    connect?: HospitalWhereUniqueInput
  }

  export type HospitalUpdateOneRequiredWithoutTestingAndScanningHsNestedInput = {
    create?: XOR<HospitalCreateWithoutTestingAndScanningHsInput, HospitalUncheckedCreateWithoutTestingAndScanningHsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutTestingAndScanningHsInput
    upsert?: HospitalUpsertWithoutTestingAndScanningHsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutTestingAndScanningHsInput, HospitalUpdateWithoutTestingAndScanningHsInput>, HospitalUncheckedUpdateWithoutTestingAndScanningHsInput>
  }

  export type HospitalCreateNestedOneWithoutMedicineAndInjectionsInput = {
    create?: XOR<HospitalCreateWithoutMedicineAndInjectionsInput, HospitalUncheckedCreateWithoutMedicineAndInjectionsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutMedicineAndInjectionsInput
    connect?: HospitalWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutMedicineAndInjectionInput = {
    create?: XOR<PatientCreateWithoutMedicineAndInjectionInput, PatientUncheckedCreateWithoutMedicineAndInjectionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicineAndInjectionInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicianCreateNestedManyWithoutMedicineAndInjectionInput = {
    create?: XOR<MedicianCreateWithoutMedicineAndInjectionInput, MedicianUncheckedCreateWithoutMedicineAndInjectionInput> | MedicianCreateWithoutMedicineAndInjectionInput[] | MedicianUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutMedicineAndInjectionInput | MedicianCreateOrConnectWithoutMedicineAndInjectionInput[]
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
  }

  export type InjectionCreateNestedManyWithoutMedicineAndInjectionInput = {
    create?: XOR<InjectionCreateWithoutMedicineAndInjectionInput, InjectionUncheckedCreateWithoutMedicineAndInjectionInput> | InjectionCreateWithoutMedicineAndInjectionInput[] | InjectionUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutMedicineAndInjectionInput | InjectionCreateOrConnectWithoutMedicineAndInjectionInput[]
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
  }

  export type MedicianUncheckedCreateNestedManyWithoutMedicineAndInjectionInput = {
    create?: XOR<MedicianCreateWithoutMedicineAndInjectionInput, MedicianUncheckedCreateWithoutMedicineAndInjectionInput> | MedicianCreateWithoutMedicineAndInjectionInput[] | MedicianUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutMedicineAndInjectionInput | MedicianCreateOrConnectWithoutMedicineAndInjectionInput[]
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
  }

  export type InjectionUncheckedCreateNestedManyWithoutMedicineAndInjectionInput = {
    create?: XOR<InjectionCreateWithoutMedicineAndInjectionInput, InjectionUncheckedCreateWithoutMedicineAndInjectionInput> | InjectionCreateWithoutMedicineAndInjectionInput[] | InjectionUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutMedicineAndInjectionInput | InjectionCreateOrConnectWithoutMedicineAndInjectionInput[]
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
  }

  export type HospitalUpdateOneRequiredWithoutMedicineAndInjectionsNestedInput = {
    create?: XOR<HospitalCreateWithoutMedicineAndInjectionsInput, HospitalUncheckedCreateWithoutMedicineAndInjectionsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutMedicineAndInjectionsInput
    upsert?: HospitalUpsertWithoutMedicineAndInjectionsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutMedicineAndInjectionsInput, HospitalUpdateWithoutMedicineAndInjectionsInput>, HospitalUncheckedUpdateWithoutMedicineAndInjectionsInput>
  }

  export type PatientUpdateOneRequiredWithoutMedicineAndInjectionNestedInput = {
    create?: XOR<PatientCreateWithoutMedicineAndInjectionInput, PatientUncheckedCreateWithoutMedicineAndInjectionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicineAndInjectionInput
    upsert?: PatientUpsertWithoutMedicineAndInjectionInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicineAndInjectionInput, PatientUpdateWithoutMedicineAndInjectionInput>, PatientUncheckedUpdateWithoutMedicineAndInjectionInput>
  }

  export type MedicianUpdateManyWithoutMedicineAndInjectionNestedInput = {
    create?: XOR<MedicianCreateWithoutMedicineAndInjectionInput, MedicianUncheckedCreateWithoutMedicineAndInjectionInput> | MedicianCreateWithoutMedicineAndInjectionInput[] | MedicianUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutMedicineAndInjectionInput | MedicianCreateOrConnectWithoutMedicineAndInjectionInput[]
    upsert?: MedicianUpsertWithWhereUniqueWithoutMedicineAndInjectionInput | MedicianUpsertWithWhereUniqueWithoutMedicineAndInjectionInput[]
    set?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    disconnect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    delete?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    update?: MedicianUpdateWithWhereUniqueWithoutMedicineAndInjectionInput | MedicianUpdateWithWhereUniqueWithoutMedicineAndInjectionInput[]
    updateMany?: MedicianUpdateManyWithWhereWithoutMedicineAndInjectionInput | MedicianUpdateManyWithWhereWithoutMedicineAndInjectionInput[]
    deleteMany?: MedicianScalarWhereInput | MedicianScalarWhereInput[]
  }

  export type InjectionUpdateManyWithoutMedicineAndInjectionNestedInput = {
    create?: XOR<InjectionCreateWithoutMedicineAndInjectionInput, InjectionUncheckedCreateWithoutMedicineAndInjectionInput> | InjectionCreateWithoutMedicineAndInjectionInput[] | InjectionUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutMedicineAndInjectionInput | InjectionCreateOrConnectWithoutMedicineAndInjectionInput[]
    upsert?: InjectionUpsertWithWhereUniqueWithoutMedicineAndInjectionInput | InjectionUpsertWithWhereUniqueWithoutMedicineAndInjectionInput[]
    set?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    disconnect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    delete?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    update?: InjectionUpdateWithWhereUniqueWithoutMedicineAndInjectionInput | InjectionUpdateWithWhereUniqueWithoutMedicineAndInjectionInput[]
    updateMany?: InjectionUpdateManyWithWhereWithoutMedicineAndInjectionInput | InjectionUpdateManyWithWhereWithoutMedicineAndInjectionInput[]
    deleteMany?: InjectionScalarWhereInput | InjectionScalarWhereInput[]
  }

  export type MedicianUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput = {
    create?: XOR<MedicianCreateWithoutMedicineAndInjectionInput, MedicianUncheckedCreateWithoutMedicineAndInjectionInput> | MedicianCreateWithoutMedicineAndInjectionInput[] | MedicianUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: MedicianCreateOrConnectWithoutMedicineAndInjectionInput | MedicianCreateOrConnectWithoutMedicineAndInjectionInput[]
    upsert?: MedicianUpsertWithWhereUniqueWithoutMedicineAndInjectionInput | MedicianUpsertWithWhereUniqueWithoutMedicineAndInjectionInput[]
    set?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    disconnect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    delete?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    connect?: MedicianWhereUniqueInput | MedicianWhereUniqueInput[]
    update?: MedicianUpdateWithWhereUniqueWithoutMedicineAndInjectionInput | MedicianUpdateWithWhereUniqueWithoutMedicineAndInjectionInput[]
    updateMany?: MedicianUpdateManyWithWhereWithoutMedicineAndInjectionInput | MedicianUpdateManyWithWhereWithoutMedicineAndInjectionInput[]
    deleteMany?: MedicianScalarWhereInput | MedicianScalarWhereInput[]
  }

  export type InjectionUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput = {
    create?: XOR<InjectionCreateWithoutMedicineAndInjectionInput, InjectionUncheckedCreateWithoutMedicineAndInjectionInput> | InjectionCreateWithoutMedicineAndInjectionInput[] | InjectionUncheckedCreateWithoutMedicineAndInjectionInput[]
    connectOrCreate?: InjectionCreateOrConnectWithoutMedicineAndInjectionInput | InjectionCreateOrConnectWithoutMedicineAndInjectionInput[]
    upsert?: InjectionUpsertWithWhereUniqueWithoutMedicineAndInjectionInput | InjectionUpsertWithWhereUniqueWithoutMedicineAndInjectionInput[]
    set?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    disconnect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    delete?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    connect?: InjectionWhereUniqueInput | InjectionWhereUniqueInput[]
    update?: InjectionUpdateWithWhereUniqueWithoutMedicineAndInjectionInput | InjectionUpdateWithWhereUniqueWithoutMedicineAndInjectionInput[]
    updateMany?: InjectionUpdateManyWithWhereWithoutMedicineAndInjectionInput | InjectionUpdateManyWithWhereWithoutMedicineAndInjectionInput[]
    deleteMany?: InjectionScalarWhereInput | InjectionScalarWhereInput[]
  }

  export type HospitalCreateNestedOneWithoutTestingAndScanningsInput = {
    create?: XOR<HospitalCreateWithoutTestingAndScanningsInput, HospitalUncheckedCreateWithoutTestingAndScanningsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutTestingAndScanningsInput
    connect?: HospitalWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutTestingAndScanningInput = {
    create?: XOR<PatientCreateWithoutTestingAndScanningInput, PatientUncheckedCreateWithoutTestingAndScanningInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTestingAndScanningInput
    connect?: PatientWhereUniqueInput
  }

  export type HospitalUpdateOneRequiredWithoutTestingAndScanningsNestedInput = {
    create?: XOR<HospitalCreateWithoutTestingAndScanningsInput, HospitalUncheckedCreateWithoutTestingAndScanningsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutTestingAndScanningsInput
    upsert?: HospitalUpsertWithoutTestingAndScanningsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutTestingAndScanningsInput, HospitalUpdateWithoutTestingAndScanningsInput>, HospitalUncheckedUpdateWithoutTestingAndScanningsInput>
  }

  export type PatientUpdateOneRequiredWithoutTestingAndScanningNestedInput = {
    create?: XOR<PatientCreateWithoutTestingAndScanningInput, PatientUncheckedCreateWithoutTestingAndScanningInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTestingAndScanningInput
    upsert?: PatientUpsertWithoutTestingAndScanningInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTestingAndScanningInput, PatientUpdateWithoutTestingAndScanningInput>, PatientUncheckedUpdateWithoutTestingAndScanningInput>
  }

  export type HospitalCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<HospitalCreateWithoutPaymentsInput, HospitalUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutPaymentsInput
    connect?: HospitalWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaymentsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type HospitalUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<HospitalCreateWithoutPaymentsInput, HospitalUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutPaymentsInput
    upsert?: HospitalUpsertWithoutPaymentsInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutPaymentsInput, HospitalUpdateWithoutPaymentsInput>, HospitalUncheckedUpdateWithoutPaymentsInput>
  }

  export type PatientUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPaymentsInput
    upsert?: PatientUpsertWithoutPaymentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPaymentsInput, PatientUpdateWithoutPaymentsInput>, PatientUncheckedUpdateWithoutPaymentsInput>
  }

  export type HospitalCreateNestedOneWithoutRoomsAvailablesInput = {
    create?: XOR<HospitalCreateWithoutRoomsAvailablesInput, HospitalUncheckedCreateWithoutRoomsAvailablesInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutRoomsAvailablesInput
    connect?: HospitalWhereUniqueInput
  }

  export type HospitalUpdateOneRequiredWithoutRoomsAvailablesNestedInput = {
    create?: XOR<HospitalCreateWithoutRoomsAvailablesInput, HospitalUncheckedCreateWithoutRoomsAvailablesInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutRoomsAvailablesInput
    upsert?: HospitalUpsertWithoutRoomsAvailablesInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutRoomsAvailablesInput, HospitalUpdateWithoutRoomsAvailablesInput>, HospitalUncheckedUpdateWithoutRoomsAvailablesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumHospitalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HospitalStatus | EnumHospitalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HospitalStatus[]
    notIn?: $Enums.HospitalStatus[]
    not?: NestedEnumHospitalStatusFilter<$PrismaModel> | $Enums.HospitalStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumHospitalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HospitalStatus | EnumHospitalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HospitalStatus[]
    notIn?: $Enums.HospitalStatus[]
    not?: NestedEnumHospitalStatusWithAggregatesFilter<$PrismaModel> | $Enums.HospitalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHospitalStatusFilter<$PrismaModel>
    _max?: NestedEnumHospitalStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutHospitalInput = {
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Patient?: PatientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHospitalInput = {
    id?: number
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Patient?: PatientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHospitalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
  }

  export type UserCreateManyHospitalInputEnvelope = {
    data: UserCreateManyHospitalInput | UserCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutHospitalInput = {
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentCreateNestedManyWithoutStaffInput
    User: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutHospitalInput = {
    id?: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentUncheckedCreateNestedManyWithoutStaffInput
  }

  export type AdminCreateOrConnectWithoutHospitalInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutHospitalInput, AdminUncheckedCreateWithoutHospitalInput>
  }

  export type AdminCreateManyHospitalInputEnvelope = {
    data: AdminCreateManyHospitalInput | AdminCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutHospitalInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutHospitalInput = {
    id?: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutHospitalInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutHospitalInput, PatientUncheckedCreateWithoutHospitalInput>
  }

  export type PatientCreateManyHospitalInputEnvelope = {
    data: PatientCreateManyHospitalInput | PatientCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationCreateWithoutHospitalInput = {
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Patient: PatientCreateNestedOneWithoutConsultationInput
    Doctor: AdminCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutHospitalInput = {
    id?: number
    patient_Id: number
    doctor_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type ConsultationCreateOrConnectWithoutHospitalInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutHospitalInput, ConsultationUncheckedCreateWithoutHospitalInput>
  }

  export type ConsultationCreateManyHospitalInputEnvelope = {
    data: ConsultationCreateManyHospitalInput | ConsultationCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentCreateWithoutHospitalInput = {
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Patient: PatientCreateNestedOneWithoutTreatmentInput
    Doctor?: AdminCreateNestedManyWithoutDoctorInput
    Staff?: AdminCreateNestedManyWithoutStaffInput
  }

  export type TreatmentUncheckedCreateWithoutHospitalInput = {
    id?: number
    staff_Id: JsonNullValueInput | InputJsonValue
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Doctor?: AdminUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: AdminUncheckedCreateNestedManyWithoutStaffInput
  }

  export type TreatmentCreateOrConnectWithoutHospitalInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutHospitalInput, TreatmentUncheckedCreateWithoutHospitalInput>
  }

  export type TreatmentCreateManyHospitalInputEnvelope = {
    data: TreatmentCreateManyHospitalInput | TreatmentCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type MedicianCreateWithoutHospitalInput = {
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutMedicianInput
  }

  export type MedicianUncheckedCreateWithoutHospitalInput = {
    id?: number
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutMedicianInput
  }

  export type MedicianCreateOrConnectWithoutHospitalInput = {
    where: MedicianWhereUniqueInput
    create: XOR<MedicianCreateWithoutHospitalInput, MedicianUncheckedCreateWithoutHospitalInput>
  }

  export type MedicianCreateManyHospitalInputEnvelope = {
    data: MedicianCreateManyHospitalInput | MedicianCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type InjectionCreateWithoutHospitalInput = {
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutInjectionInput
  }

  export type InjectionUncheckedCreateWithoutHospitalInput = {
    id?: number
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutInjectionInput
  }

  export type InjectionCreateOrConnectWithoutHospitalInput = {
    where: InjectionWhereUniqueInput
    create: XOR<InjectionCreateWithoutHospitalInput, InjectionUncheckedCreateWithoutHospitalInput>
  }

  export type InjectionCreateManyHospitalInputEnvelope = {
    data: InjectionCreateManyHospitalInput | InjectionCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type TestingAndScanningPCreateWithoutHospitalInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
    Patient: PatientCreateNestedOneWithoutTestingAndScanningInput
  }

  export type TestingAndScanningPUncheckedCreateWithoutHospitalInput = {
    id?: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
  }

  export type TestingAndScanningPCreateOrConnectWithoutHospitalInput = {
    where: TestingAndScanningPWhereUniqueInput
    create: XOR<TestingAndScanningPCreateWithoutHospitalInput, TestingAndScanningPUncheckedCreateWithoutHospitalInput>
  }

  export type TestingAndScanningPCreateManyHospitalInputEnvelope = {
    data: TestingAndScanningPCreateManyHospitalInput | TestingAndScanningPCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type TestingAndScanningHCreateWithoutHospitalInput = {
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
  }

  export type TestingAndScanningHUncheckedCreateWithoutHospitalInput = {
    id?: number
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
  }

  export type TestingAndScanningHCreateOrConnectWithoutHospitalInput = {
    where: TestingAndScanningHWhereUniqueInput
    create: XOR<TestingAndScanningHCreateWithoutHospitalInput, TestingAndScanningHUncheckedCreateWithoutHospitalInput>
  }

  export type TestingAndScanningHCreateManyHospitalInputEnvelope = {
    data: TestingAndScanningHCreateManyHospitalInput | TestingAndScanningHCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type RoomsAvailableCreateWithoutHospitalInput = {
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
  }

  export type RoomsAvailableUncheckedCreateWithoutHospitalInput = {
    id?: number
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
  }

  export type RoomsAvailableCreateOrConnectWithoutHospitalInput = {
    where: RoomsAvailableWhereUniqueInput
    create: XOR<RoomsAvailableCreateWithoutHospitalInput, RoomsAvailableUncheckedCreateWithoutHospitalInput>
  }

  export type RoomsAvailableCreateManyHospitalInputEnvelope = {
    data: RoomsAvailableCreateManyHospitalInput | RoomsAvailableCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutHospitalInput = {
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Patient: PatientCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutHospitalInput = {
    id?: number
    patient_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutHospitalInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutHospitalInput, PaymentUncheckedCreateWithoutHospitalInput>
  }

  export type PaymentCreateManyHospitalInputEnvelope = {
    data: PaymentCreateManyHospitalInput | PaymentCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type MedicineAndInjectionCreateWithoutHospitalInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Patient: PatientCreateNestedOneWithoutMedicineAndInjectionInput
    Medician?: MedicianCreateNestedManyWithoutMedicineAndInjectionInput
    Injection?: InjectionCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionUncheckedCreateWithoutHospitalInput = {
    id?: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Medician?: MedicianUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
    Injection?: InjectionUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionCreateOrConnectWithoutHospitalInput = {
    where: MedicineAndInjectionWhereUniqueInput
    create: XOR<MedicineAndInjectionCreateWithoutHospitalInput, MedicineAndInjectionUncheckedCreateWithoutHospitalInput>
  }

  export type MedicineAndInjectionCreateManyHospitalInputEnvelope = {
    data: MedicineAndInjectionCreateManyHospitalInput | MedicineAndInjectionCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutHospitalInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>
    create: XOR<UserCreateWithoutHospitalInput, UserUncheckedCreateWithoutHospitalInput>
  }

  export type UserUpdateWithWhereUniqueWithoutHospitalInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutHospitalInput, UserUncheckedUpdateWithoutHospitalInput>
  }

  export type UserUpdateManyWithWhereWithoutHospitalInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutHospitalInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    hospital_Id?: IntFilter<"User"> | number
    user_Id?: IntFilter<"User"> | number
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
  }

  export type AdminUpsertWithWhereUniqueWithoutHospitalInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutHospitalInput, AdminUncheckedUpdateWithoutHospitalInput>
    create: XOR<AdminCreateWithoutHospitalInput, AdminUncheckedCreateWithoutHospitalInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutHospitalInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutHospitalInput, AdminUncheckedUpdateWithoutHospitalInput>
  }

  export type AdminUpdateManyWithWhereWithoutHospitalInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutHospitalInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: IntFilter<"Admin"> | number
    hospital_Id?: IntFilter<"Admin"> | number
    user_Id?: IntFilter<"Admin"> | number
    destination?: StringFilter<"Admin"> | string
    phone?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    address?: StringFilter<"Admin"> | string
    photo?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    status?: StringFilter<"Admin"> | string
    gender?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutHospitalInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutHospitalInput, PatientUncheckedUpdateWithoutHospitalInput>
    create: XOR<PatientCreateWithoutHospitalInput, PatientUncheckedCreateWithoutHospitalInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutHospitalInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutHospitalInput, PatientUncheckedUpdateWithoutHospitalInput>
  }

  export type PatientUpdateManyWithWhereWithoutHospitalInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutHospitalInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: IntFilter<"Patient"> | number
    hospital_Id?: IntFilter<"Patient"> | number
    user_Id?: IntFilter<"Patient"> | number
    name?: StringFilter<"Patient"> | string
    phone?: JsonFilter<"Patient">
    email?: JsonFilter<"Patient">
    photo?: StringFilter<"Patient"> | string
    status?: StringFilter<"Patient"> | string
    address?: JsonNullableFilter<"Patient">
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringFilter<"Patient"> | string
    bldGrp?: StringFilter<"Patient"> | string
    currentProblem?: StringFilter<"Patient"> | string
    medicalHistory?: StringFilter<"Patient"> | string
    height?: FloatFilter<"Patient"> | number
    weight?: FloatFilter<"Patient"> | number
    bp?: StringFilter<"Patient"> | string
    sugar?: StringFilter<"Patient"> | string
    custom?: JsonFilter<"Patient">
    tempCreatedAt?: DateTimeFilter<"Patient"> | Date | string
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type ConsultationUpsertWithWhereUniqueWithoutHospitalInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutHospitalInput, ConsultationUncheckedUpdateWithoutHospitalInput>
    create: XOR<ConsultationCreateWithoutHospitalInput, ConsultationUncheckedCreateWithoutHospitalInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutHospitalInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutHospitalInput, ConsultationUncheckedUpdateWithoutHospitalInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutHospitalInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutHospitalInput>
  }

  export type ConsultationScalarWhereInput = {
    AND?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    OR?: ConsultationScalarWhereInput[]
    NOT?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    id?: IntFilter<"Consultation"> | number
    hospital_Id?: IntFilter<"Consultation"> | number
    patient_Id?: IntFilter<"Consultation"> | number
    doctor_Id?: IntFilter<"Consultation"> | number
    date?: DateTimeFilter<"Consultation"> | Date | string
    purpose?: StringFilter<"Consultation"> | string
    temperature?: FloatFilter<"Consultation"> | number
    symptoms?: StringFilter<"Consultation"> | string
    notes?: JsonFilter<"Consultation">
    diagnosis?: StringFilter<"Consultation"> | string
    treatment?: BoolFilter<"Consultation"> | boolean
    medicineInjection?: BoolFilter<"Consultation"> | boolean
    scanningTesting?: BoolFilter<"Consultation"> | boolean
    status?: StringFilter<"Consultation"> | string
    access?: JsonFilter<"Consultation">
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    paymentStatus?: BoolFilter<"Consultation"> | boolean
  }

  export type TreatmentUpsertWithWhereUniqueWithoutHospitalInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutHospitalInput, TreatmentUncheckedUpdateWithoutHospitalInput>
    create: XOR<TreatmentCreateWithoutHospitalInput, TreatmentUncheckedCreateWithoutHospitalInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutHospitalInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutHospitalInput, TreatmentUncheckedUpdateWithoutHospitalInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutHospitalInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutHospitalInput>
  }

  export type TreatmentScalarWhereInput = {
    AND?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
    OR?: TreatmentScalarWhereInput[]
    NOT?: TreatmentScalarWhereInput | TreatmentScalarWhereInput[]
    id?: IntFilter<"Treatment"> | number
    hospital_Id?: IntFilter<"Treatment"> | number
    staff_Id?: JsonFilter<"Treatment">
    patient_Id?: IntFilter<"Treatment"> | number
    doctor_Id?: JsonFilter<"Treatment">
    treatmentName?: JsonFilter<"Treatment">
    startDate?: DateTimeFilter<"Treatment"> | Date | string
    endDate?: DateTimeFilter<"Treatment"> | Date | string
    progress?: StringFilter<"Treatment"> | string
    status?: StringFilter<"Treatment"> | string
    createdAt?: DateTimeFilter<"Treatment"> | Date | string
    updatedAt?: DateTimeFilter<"Treatment"> | Date | string
    paymentStatus?: BoolFilter<"Treatment"> | boolean
  }

  export type MedicianUpsertWithWhereUniqueWithoutHospitalInput = {
    where: MedicianWhereUniqueInput
    update: XOR<MedicianUpdateWithoutHospitalInput, MedicianUncheckedUpdateWithoutHospitalInput>
    create: XOR<MedicianCreateWithoutHospitalInput, MedicianUncheckedCreateWithoutHospitalInput>
  }

  export type MedicianUpdateWithWhereUniqueWithoutHospitalInput = {
    where: MedicianWhereUniqueInput
    data: XOR<MedicianUpdateWithoutHospitalInput, MedicianUncheckedUpdateWithoutHospitalInput>
  }

  export type MedicianUpdateManyWithWhereWithoutHospitalInput = {
    where: MedicianScalarWhereInput
    data: XOR<MedicianUpdateManyMutationInput, MedicianUncheckedUpdateManyWithoutHospitalInput>
  }

  export type MedicianScalarWhereInput = {
    AND?: MedicianScalarWhereInput | MedicianScalarWhereInput[]
    OR?: MedicianScalarWhereInput[]
    NOT?: MedicianScalarWhereInput | MedicianScalarWhereInput[]
    id?: IntFilter<"Medician"> | number
    hospital_Id?: IntFilter<"Medician"> | number
    medicianName?: StringFilter<"Medician"> | string
    stock?: IntFilter<"Medician"> | number
    amount?: FloatFilter<"Medician"> | number
    staffId?: JsonFilter<"Medician">
  }

  export type InjectionUpsertWithWhereUniqueWithoutHospitalInput = {
    where: InjectionWhereUniqueInput
    update: XOR<InjectionUpdateWithoutHospitalInput, InjectionUncheckedUpdateWithoutHospitalInput>
    create: XOR<InjectionCreateWithoutHospitalInput, InjectionUncheckedCreateWithoutHospitalInput>
  }

  export type InjectionUpdateWithWhereUniqueWithoutHospitalInput = {
    where: InjectionWhereUniqueInput
    data: XOR<InjectionUpdateWithoutHospitalInput, InjectionUncheckedUpdateWithoutHospitalInput>
  }

  export type InjectionUpdateManyWithWhereWithoutHospitalInput = {
    where: InjectionScalarWhereInput
    data: XOR<InjectionUpdateManyMutationInput, InjectionUncheckedUpdateManyWithoutHospitalInput>
  }

  export type InjectionScalarWhereInput = {
    AND?: InjectionScalarWhereInput | InjectionScalarWhereInput[]
    OR?: InjectionScalarWhereInput[]
    NOT?: InjectionScalarWhereInput | InjectionScalarWhereInput[]
    id?: IntFilter<"Injection"> | number
    hospital_Id?: IntFilter<"Injection"> | number
    injectionName?: StringFilter<"Injection"> | string
    stock?: IntFilter<"Injection"> | number
    amount?: FloatFilter<"Injection"> | number
    staffId?: JsonFilter<"Injection">
  }

  export type TestingAndScanningPUpsertWithWhereUniqueWithoutHospitalInput = {
    where: TestingAndScanningPWhereUniqueInput
    update: XOR<TestingAndScanningPUpdateWithoutHospitalInput, TestingAndScanningPUncheckedUpdateWithoutHospitalInput>
    create: XOR<TestingAndScanningPCreateWithoutHospitalInput, TestingAndScanningPUncheckedCreateWithoutHospitalInput>
  }

  export type TestingAndScanningPUpdateWithWhereUniqueWithoutHospitalInput = {
    where: TestingAndScanningPWhereUniqueInput
    data: XOR<TestingAndScanningPUpdateWithoutHospitalInput, TestingAndScanningPUncheckedUpdateWithoutHospitalInput>
  }

  export type TestingAndScanningPUpdateManyWithWhereWithoutHospitalInput = {
    where: TestingAndScanningPScalarWhereInput
    data: XOR<TestingAndScanningPUpdateManyMutationInput, TestingAndScanningPUncheckedUpdateManyWithoutHospitalInput>
  }

  export type TestingAndScanningPScalarWhereInput = {
    AND?: TestingAndScanningPScalarWhereInput | TestingAndScanningPScalarWhereInput[]
    OR?: TestingAndScanningPScalarWhereInput[]
    NOT?: TestingAndScanningPScalarWhereInput | TestingAndScanningPScalarWhereInput[]
    id?: IntFilter<"TestingAndScanningP"> | number
    hospital_Id?: IntFilter<"TestingAndScanningP"> | number
    patient_Id?: IntFilter<"TestingAndScanningP"> | number
    doctor_Id?: JsonFilter<"TestingAndScanningP">
    staff_Id?: JsonFilter<"TestingAndScanningP">
    title?: StringFilter<"TestingAndScanningP"> | string
    scheduleDate?: DateTimeFilter<"TestingAndScanningP"> | Date | string
    type?: StringFilter<"TestingAndScanningP"> | string
    status?: StringFilter<"TestingAndScanningP"> | string
    paymentStatus?: BoolFilter<"TestingAndScanningP"> | boolean
    result?: StringFilter<"TestingAndScanningP"> | string
  }

  export type TestingAndScanningHUpsertWithWhereUniqueWithoutHospitalInput = {
    where: TestingAndScanningHWhereUniqueInput
    update: XOR<TestingAndScanningHUpdateWithoutHospitalInput, TestingAndScanningHUncheckedUpdateWithoutHospitalInput>
    create: XOR<TestingAndScanningHCreateWithoutHospitalInput, TestingAndScanningHUncheckedCreateWithoutHospitalInput>
  }

  export type TestingAndScanningHUpdateWithWhereUniqueWithoutHospitalInput = {
    where: TestingAndScanningHWhereUniqueInput
    data: XOR<TestingAndScanningHUpdateWithoutHospitalInput, TestingAndScanningHUncheckedUpdateWithoutHospitalInput>
  }

  export type TestingAndScanningHUpdateManyWithWhereWithoutHospitalInput = {
    where: TestingAndScanningHScalarWhereInput
    data: XOR<TestingAndScanningHUpdateManyMutationInput, TestingAndScanningHUncheckedUpdateManyWithoutHospitalInput>
  }

  export type TestingAndScanningHScalarWhereInput = {
    AND?: TestingAndScanningHScalarWhereInput | TestingAndScanningHScalarWhereInput[]
    OR?: TestingAndScanningHScalarWhereInput[]
    NOT?: TestingAndScanningHScalarWhereInput | TestingAndScanningHScalarWhereInput[]
    id?: IntFilter<"TestingAndScanningH"> | number
    hospital_Id?: IntFilter<"TestingAndScanningH"> | number
    type?: StringFilter<"TestingAndScanningH"> | string
    status?: StringFilter<"TestingAndScanningH"> | string
    roomNo?: StringFilter<"TestingAndScanningH"> | string
    staffId?: IntFilter<"TestingAndScanningH"> | number
    amount?: FloatFilter<"TestingAndScanningH"> | number
  }

  export type RoomsAvailableUpsertWithWhereUniqueWithoutHospitalInput = {
    where: RoomsAvailableWhereUniqueInput
    update: XOR<RoomsAvailableUpdateWithoutHospitalInput, RoomsAvailableUncheckedUpdateWithoutHospitalInput>
    create: XOR<RoomsAvailableCreateWithoutHospitalInput, RoomsAvailableUncheckedCreateWithoutHospitalInput>
  }

  export type RoomsAvailableUpdateWithWhereUniqueWithoutHospitalInput = {
    where: RoomsAvailableWhereUniqueInput
    data: XOR<RoomsAvailableUpdateWithoutHospitalInput, RoomsAvailableUncheckedUpdateWithoutHospitalInput>
  }

  export type RoomsAvailableUpdateManyWithWhereWithoutHospitalInput = {
    where: RoomsAvailableScalarWhereInput
    data: XOR<RoomsAvailableUpdateManyMutationInput, RoomsAvailableUncheckedUpdateManyWithoutHospitalInput>
  }

  export type RoomsAvailableScalarWhereInput = {
    AND?: RoomsAvailableScalarWhereInput | RoomsAvailableScalarWhereInput[]
    OR?: RoomsAvailableScalarWhereInput[]
    NOT?: RoomsAvailableScalarWhereInput | RoomsAvailableScalarWhereInput[]
    id?: IntFilter<"RoomsAvailable"> | number
    hospital_Id?: IntFilter<"RoomsAvailable"> | number
    staffId?: IntFilter<"RoomsAvailable"> | number
    roomNo?: StringFilter<"RoomsAvailable"> | string
    capacity?: IntFilter<"RoomsAvailable"> | number
    notes?: StringFilter<"RoomsAvailable"> | string
    type?: StringFilter<"RoomsAvailable"> | string
    amount?: FloatFilter<"RoomsAvailable"> | number
  }

  export type PaymentUpsertWithWhereUniqueWithoutHospitalInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutHospitalInput, PaymentUncheckedUpdateWithoutHospitalInput>
    create: XOR<PaymentCreateWithoutHospitalInput, PaymentUncheckedCreateWithoutHospitalInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutHospitalInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutHospitalInput, PaymentUncheckedUpdateWithoutHospitalInput>
  }

  export type PaymentUpdateManyWithWhereWithoutHospitalInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutHospitalInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    hospital_Id?: IntFilter<"Payment"> | number
    patient_Id?: IntFilter<"Payment"> | number
    reason?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: FloatFilter<"Payment"> | number
    transactionId?: JsonFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type MedicineAndInjectionUpsertWithWhereUniqueWithoutHospitalInput = {
    where: MedicineAndInjectionWhereUniqueInput
    update: XOR<MedicineAndInjectionUpdateWithoutHospitalInput, MedicineAndInjectionUncheckedUpdateWithoutHospitalInput>
    create: XOR<MedicineAndInjectionCreateWithoutHospitalInput, MedicineAndInjectionUncheckedCreateWithoutHospitalInput>
  }

  export type MedicineAndInjectionUpdateWithWhereUniqueWithoutHospitalInput = {
    where: MedicineAndInjectionWhereUniqueInput
    data: XOR<MedicineAndInjectionUpdateWithoutHospitalInput, MedicineAndInjectionUncheckedUpdateWithoutHospitalInput>
  }

  export type MedicineAndInjectionUpdateManyWithWhereWithoutHospitalInput = {
    where: MedicineAndInjectionScalarWhereInput
    data: XOR<MedicineAndInjectionUpdateManyMutationInput, MedicineAndInjectionUncheckedUpdateManyWithoutHospitalInput>
  }

  export type MedicineAndInjectionScalarWhereInput = {
    AND?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
    OR?: MedicineAndInjectionScalarWhereInput[]
    NOT?: MedicineAndInjectionScalarWhereInput | MedicineAndInjectionScalarWhereInput[]
    id?: IntFilter<"MedicineAndInjection"> | number
    hospital_Id?: IntFilter<"MedicineAndInjection"> | number
    patient_Id?: IntFilter<"MedicineAndInjection"> | number
    doctor_Id?: JsonFilter<"MedicineAndInjection">
    staff_Id?: JsonFilter<"MedicineAndInjection">
    medicine_Id?: JsonFilter<"MedicineAndInjection">
    frequencyMedicine?: JsonFilter<"MedicineAndInjection">
    injection_Id?: JsonFilter<"MedicineAndInjection">
    frequencyInjection?: JsonFilter<"MedicineAndInjection">
    status?: StringFilter<"MedicineAndInjection"> | string
    notes?: JsonFilter<"MedicineAndInjection">
    paymentStatus?: BoolFilter<"MedicineAndInjection"> | boolean
    createdAt?: DateTimeFilter<"MedicineAndInjection"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineAndInjection"> | Date | string
  }

  export type AdminStratorCreateWithoutUserInput = {
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
  }

  export type AdminStratorUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
  }

  export type AdminStratorCreateOrConnectWithoutUserInput = {
    where: AdminStratorWhereUniqueInput
    create: XOR<AdminStratorCreateWithoutUserInput, AdminStratorUncheckedCreateWithoutUserInput>
  }

  export type AdminStratorCreateManyUserInputEnvelope = {
    data: AdminStratorCreateManyUserInput | AdminStratorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutUserInput = {
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentCreateNestedManyWithoutStaffInput
    Hospital: HospitalCreateNestedOneWithoutAdminsInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: number
    hospital_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentUncheckedCreateNestedManyWithoutStaffInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateManyUserInputEnvelope = {
    data: AdminCreateManyUserInput | AdminCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutUserInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutUserInput = {
    id?: number
    hospital_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUserInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PatientCreateManyUserInputEnvelope = {
    data: PatientCreateManyUserInput | PatientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HospitalCreateWithoutUsersInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutUsersInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutUsersInput, HospitalUncheckedCreateWithoutUsersInput>
  }

  export type AdminStratorUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminStratorWhereUniqueInput
    update: XOR<AdminStratorUpdateWithoutUserInput, AdminStratorUncheckedUpdateWithoutUserInput>
    create: XOR<AdminStratorCreateWithoutUserInput, AdminStratorUncheckedCreateWithoutUserInput>
  }

  export type AdminStratorUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminStratorWhereUniqueInput
    data: XOR<AdminStratorUpdateWithoutUserInput, AdminStratorUncheckedUpdateWithoutUserInput>
  }

  export type AdminStratorUpdateManyWithWhereWithoutUserInput = {
    where: AdminStratorScalarWhereInput
    data: XOR<AdminStratorUpdateManyMutationInput, AdminStratorUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminStratorScalarWhereInput = {
    AND?: AdminStratorScalarWhereInput | AdminStratorScalarWhereInput[]
    OR?: AdminStratorScalarWhereInput[]
    NOT?: AdminStratorScalarWhereInput | AdminStratorScalarWhereInput[]
    id?: IntFilter<"AdminStrator"> | number
    user_Id?: IntFilter<"AdminStrator"> | number
    name?: StringFilter<"AdminStrator"> | string
    status?: StringFilter<"AdminStrator"> | string
    destination?: StringFilter<"AdminStrator"> | string
    phone?: StringFilter<"AdminStrator"> | string
    email?: StringFilter<"AdminStrator"> | string
    photo?: StringFilter<"AdminStrator"> | string
    address?: StringFilter<"AdminStrator"> | string
    gender?: StringFilter<"AdminStrator"> | string
  }

  export type AdminUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateManyWithWhereWithoutUserInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutUserInput>
  }

  export type PatientUpsertWithWhereUniqueWithoutUserInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutUserInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateManyWithWhereWithoutUserInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutUserInput>
  }

  export type HospitalUpsertWithoutUsersInput = {
    update: XOR<HospitalUpdateWithoutUsersInput, HospitalUncheckedUpdateWithoutUsersInput>
    create: XOR<HospitalCreateWithoutUsersInput, HospitalUncheckedCreateWithoutUsersInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutUsersInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutUsersInput, HospitalUncheckedUpdateWithoutUsersInput>
  }

  export type HospitalUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type ConsultationCreateWithoutDoctorInput = {
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutConsultationInput
    Patient: PatientCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutDoctorInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type ConsultationCreateOrConnectWithoutDoctorInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutDoctorInput, ConsultationUncheckedCreateWithoutDoctorInput>
  }

  export type ConsultationCreateManyDoctorInputEnvelope = {
    data: ConsultationCreateManyDoctorInput | ConsultationCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentCreateWithoutDoctorInput = {
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutTreatmentsInput
    Patient: PatientCreateNestedOneWithoutTreatmentInput
    Staff?: AdminCreateNestedManyWithoutStaffInput
  }

  export type TreatmentUncheckedCreateWithoutDoctorInput = {
    id?: number
    hospital_Id: number
    staff_Id: JsonNullValueInput | InputJsonValue
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Staff?: AdminUncheckedCreateNestedManyWithoutStaffInput
  }

  export type TreatmentCreateOrConnectWithoutDoctorInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput>
  }

  export type TreatmentCreateWithoutStaffInput = {
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutTreatmentsInput
    Patient: PatientCreateNestedOneWithoutTreatmentInput
    Doctor?: AdminCreateNestedManyWithoutDoctorInput
  }

  export type TreatmentUncheckedCreateWithoutStaffInput = {
    id?: number
    hospital_Id: number
    staff_Id: JsonNullValueInput | InputJsonValue
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Doctor?: AdminUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type TreatmentCreateOrConnectWithoutStaffInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutStaffInput, TreatmentUncheckedCreateWithoutStaffInput>
  }

  export type HospitalCreateWithoutAdminsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutAdminsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutAdminsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutAdminsInput, HospitalUncheckedCreateWithoutAdminsInput>
  }

  export type UserCreateWithoutAdminInput = {
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorCreateNestedManyWithoutUserInput
    Patient?: PatientCreateNestedManyWithoutUserInput
    Hospital: HospitalCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorUncheckedCreateNestedManyWithoutUserInput
    Patient?: PatientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type ConsultationUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutDoctorInput, ConsultationUncheckedUpdateWithoutDoctorInput>
    create: XOR<ConsultationCreateWithoutDoctorInput, ConsultationUncheckedCreateWithoutDoctorInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutDoctorInput, ConsultationUncheckedUpdateWithoutDoctorInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutDoctorInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutDoctorInput>
  }

  export type TreatmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutDoctorInput, TreatmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<TreatmentCreateWithoutDoctorInput, TreatmentUncheckedCreateWithoutDoctorInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutDoctorInput, TreatmentUncheckedUpdateWithoutDoctorInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutDoctorInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type TreatmentUpsertWithWhereUniqueWithoutStaffInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutStaffInput, TreatmentUncheckedUpdateWithoutStaffInput>
    create: XOR<TreatmentCreateWithoutStaffInput, TreatmentUncheckedCreateWithoutStaffInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutStaffInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutStaffInput, TreatmentUncheckedUpdateWithoutStaffInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutStaffInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutStaffInput>
  }

  export type HospitalUpsertWithoutAdminsInput = {
    update: XOR<HospitalUpdateWithoutAdminsInput, HospitalUncheckedUpdateWithoutAdminsInput>
    create: XOR<HospitalCreateWithoutAdminsInput, HospitalUncheckedCreateWithoutAdminsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutAdminsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutAdminsInput, HospitalUncheckedUpdateWithoutAdminsInput>
  }

  export type HospitalUpdateWithoutAdminsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUpdateManyWithoutUserNestedInput
    Patient?: PatientUpdateManyWithoutUserNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUncheckedUpdateManyWithoutUserNestedInput
    Patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAdminStratorInput = {
    user_Id: number
    password: string
    role: string
    Admin?: AdminCreateNestedManyWithoutUserInput
    Patient?: PatientCreateNestedManyWithoutUserInput
    Hospital: HospitalCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdminStratorInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    password: string
    role: string
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Patient?: PatientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminStratorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminStratorInput, UserUncheckedCreateWithoutAdminStratorInput>
  }

  export type UserUpsertWithoutAdminStratorInput = {
    update: XOR<UserUpdateWithoutAdminStratorInput, UserUncheckedUpdateWithoutAdminStratorInput>
    create: XOR<UserCreateWithoutAdminStratorInput, UserUncheckedCreateWithoutAdminStratorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminStratorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminStratorInput, UserUncheckedUpdateWithoutAdminStratorInput>
  }

  export type UserUpdateWithoutAdminStratorInput = {
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Patient?: PatientUpdateManyWithoutUserNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminStratorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConsultationCreateWithoutPatientInput = {
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutConsultationInput
    Doctor: AdminCreateNestedOneWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutPatientInput = {
    id?: number
    hospital_Id: number
    doctor_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type ConsultationCreateOrConnectWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationCreateManyPatientInputEnvelope = {
    data: ConsultationCreateManyPatientInput | ConsultationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentCreateWithoutPatientInput = {
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Hospital: HospitalCreateNestedOneWithoutTreatmentsInput
    Doctor?: AdminCreateNestedManyWithoutDoctorInput
    Staff?: AdminCreateNestedManyWithoutStaffInput
  }

  export type TreatmentUncheckedCreateWithoutPatientInput = {
    id?: number
    hospital_Id: number
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
    Doctor?: AdminUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: AdminUncheckedCreateNestedManyWithoutStaffInput
  }

  export type TreatmentCreateOrConnectWithoutPatientInput = {
    where: TreatmentWhereUniqueInput
    create: XOR<TreatmentCreateWithoutPatientInput, TreatmentUncheckedCreateWithoutPatientInput>
  }

  export type TreatmentCreateManyPatientInputEnvelope = {
    data: TreatmentCreateManyPatientInput | TreatmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicineAndInjectionCreateWithoutPatientInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital: HospitalCreateNestedOneWithoutMedicineAndInjectionsInput
    Medician?: MedicianCreateNestedManyWithoutMedicineAndInjectionInput
    Injection?: InjectionCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionUncheckedCreateWithoutPatientInput = {
    id?: number
    hospital_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Medician?: MedicianUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
    Injection?: InjectionUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionCreateOrConnectWithoutPatientInput = {
    where: MedicineAndInjectionWhereUniqueInput
    create: XOR<MedicineAndInjectionCreateWithoutPatientInput, MedicineAndInjectionUncheckedCreateWithoutPatientInput>
  }

  export type MedicineAndInjectionCreateManyPatientInputEnvelope = {
    data: MedicineAndInjectionCreateManyPatientInput | MedicineAndInjectionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TestingAndScanningPCreateWithoutPatientInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
    Hospital: HospitalCreateNestedOneWithoutTestingAndScanningsInput
  }

  export type TestingAndScanningPUncheckedCreateWithoutPatientInput = {
    id?: number
    hospital_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
  }

  export type TestingAndScanningPCreateOrConnectWithoutPatientInput = {
    where: TestingAndScanningPWhereUniqueInput
    create: XOR<TestingAndScanningPCreateWithoutPatientInput, TestingAndScanningPUncheckedCreateWithoutPatientInput>
  }

  export type TestingAndScanningPCreateManyPatientInputEnvelope = {
    data: TestingAndScanningPCreateManyPatientInput | TestingAndScanningPCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPatientInput = {
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital: HospitalCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPatientInput = {
    id?: number
    hospital_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentCreateManyPatientInputEnvelope = {
    data: PaymentCreateManyPatientInput | PaymentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type HospitalCreateWithoutPatientsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutPatientsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutPatientsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutPatientsInput, HospitalUncheckedCreateWithoutPatientsInput>
  }

  export type UserCreateWithoutPatientInput = {
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Hospital: HospitalCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPatientInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    password: string
    role: string
    AdminStrator?: AdminStratorUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutPatientInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutPatientInput>
  }

  export type TreatmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: TreatmentWhereUniqueInput
    update: XOR<TreatmentUpdateWithoutPatientInput, TreatmentUncheckedUpdateWithoutPatientInput>
    create: XOR<TreatmentCreateWithoutPatientInput, TreatmentUncheckedCreateWithoutPatientInput>
  }

  export type TreatmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: TreatmentWhereUniqueInput
    data: XOR<TreatmentUpdateWithoutPatientInput, TreatmentUncheckedUpdateWithoutPatientInput>
  }

  export type TreatmentUpdateManyWithWhereWithoutPatientInput = {
    where: TreatmentScalarWhereInput
    data: XOR<TreatmentUpdateManyMutationInput, TreatmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicineAndInjectionUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicineAndInjectionWhereUniqueInput
    update: XOR<MedicineAndInjectionUpdateWithoutPatientInput, MedicineAndInjectionUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicineAndInjectionCreateWithoutPatientInput, MedicineAndInjectionUncheckedCreateWithoutPatientInput>
  }

  export type MedicineAndInjectionUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicineAndInjectionWhereUniqueInput
    data: XOR<MedicineAndInjectionUpdateWithoutPatientInput, MedicineAndInjectionUncheckedUpdateWithoutPatientInput>
  }

  export type MedicineAndInjectionUpdateManyWithWhereWithoutPatientInput = {
    where: MedicineAndInjectionScalarWhereInput
    data: XOR<MedicineAndInjectionUpdateManyMutationInput, MedicineAndInjectionUncheckedUpdateManyWithoutPatientInput>
  }

  export type TestingAndScanningPUpsertWithWhereUniqueWithoutPatientInput = {
    where: TestingAndScanningPWhereUniqueInput
    update: XOR<TestingAndScanningPUpdateWithoutPatientInput, TestingAndScanningPUncheckedUpdateWithoutPatientInput>
    create: XOR<TestingAndScanningPCreateWithoutPatientInput, TestingAndScanningPUncheckedCreateWithoutPatientInput>
  }

  export type TestingAndScanningPUpdateWithWhereUniqueWithoutPatientInput = {
    where: TestingAndScanningPWhereUniqueInput
    data: XOR<TestingAndScanningPUpdateWithoutPatientInput, TestingAndScanningPUncheckedUpdateWithoutPatientInput>
  }

  export type TestingAndScanningPUpdateManyWithWhereWithoutPatientInput = {
    where: TestingAndScanningPScalarWhereInput
    data: XOR<TestingAndScanningPUpdateManyMutationInput, TestingAndScanningPUncheckedUpdateManyWithoutPatientInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
    create: XOR<PaymentCreateWithoutPatientInput, PaymentUncheckedCreateWithoutPatientInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPatientInput, PaymentUncheckedUpdateWithoutPatientInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPatientInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPatientInput>
  }

  export type HospitalUpsertWithoutPatientsInput = {
    update: XOR<HospitalUpdateWithoutPatientsInput, HospitalUncheckedUpdateWithoutPatientsInput>
    create: XOR<HospitalCreateWithoutPatientsInput, HospitalUncheckedCreateWithoutPatientsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutPatientsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutPatientsInput, HospitalUncheckedUpdateWithoutPatientsInput>
  }

  export type HospitalUpdateWithoutPatientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type UserUpsertWithoutPatientInput = {
    update: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
  }

  export type UserUpdateWithoutPatientInput = {
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HospitalCreateWithoutConsultationInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutConsultationInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutConsultationInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutConsultationInput, HospitalUncheckedCreateWithoutConsultationInput>
  }

  export type PatientCreateWithoutConsultationInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsultationInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsultationInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsultationInput, PatientUncheckedCreateWithoutConsultationInput>
  }

  export type AdminCreateWithoutConsultationInput = {
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Doctor?: TreatmentCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentCreateNestedManyWithoutStaffInput
    Hospital: HospitalCreateNestedOneWithoutAdminsInput
    User: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutConsultationInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Doctor?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentUncheckedCreateNestedManyWithoutStaffInput
  }

  export type AdminCreateOrConnectWithoutConsultationInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutConsultationInput, AdminUncheckedCreateWithoutConsultationInput>
  }

  export type HospitalUpsertWithoutConsultationInput = {
    update: XOR<HospitalUpdateWithoutConsultationInput, HospitalUncheckedUpdateWithoutConsultationInput>
    create: XOR<HospitalCreateWithoutConsultationInput, HospitalUncheckedCreateWithoutConsultationInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutConsultationInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutConsultationInput, HospitalUncheckedUpdateWithoutConsultationInput>
  }

  export type HospitalUpdateWithoutConsultationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type PatientUpsertWithoutConsultationInput = {
    update: XOR<PatientUpdateWithoutConsultationInput, PatientUncheckedUpdateWithoutConsultationInput>
    create: XOR<PatientCreateWithoutConsultationInput, PatientUncheckedCreateWithoutConsultationInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsultationInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsultationInput, PatientUncheckedUpdateWithoutConsultationInput>
  }

  export type PatientUpdateWithoutConsultationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AdminUpsertWithoutConsultationInput = {
    update: XOR<AdminUpdateWithoutConsultationInput, AdminUncheckedUpdateWithoutConsultationInput>
    create: XOR<AdminCreateWithoutConsultationInput, AdminUncheckedCreateWithoutConsultationInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutConsultationInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutConsultationInput, AdminUncheckedUpdateWithoutConsultationInput>
  }

  export type AdminUpdateWithoutConsultationInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Doctor?: TreatmentUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUpdateManyWithoutStaffNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutAdminsNestedInput
    User?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutConsultationInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Doctor?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type HospitalCreateWithoutTreatmentsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutTreatmentsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutTreatmentsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutTreatmentsInput, HospitalUncheckedCreateWithoutTreatmentsInput>
  }

  export type PatientCreateWithoutTreatmentInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTreatmentInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTreatmentInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTreatmentInput, PatientUncheckedCreateWithoutTreatmentInput>
  }

  export type AdminCreateWithoutDoctorInput = {
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentCreateNestedManyWithoutStaffInput
    Hospital: HospitalCreateNestedOneWithoutAdminsInput
    User: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutDoctorInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutDoctorInput
    Staff?: TreatmentUncheckedCreateNestedManyWithoutStaffInput
  }

  export type AdminCreateOrConnectWithoutDoctorInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutDoctorInput, AdminUncheckedCreateWithoutDoctorInput>
  }

  export type AdminCreateWithoutStaffInput = {
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentCreateNestedManyWithoutDoctorInput
    Hospital: HospitalCreateNestedOneWithoutAdminsInput
    User: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutStaffInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutDoctorInput
    Doctor?: TreatmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type AdminCreateOrConnectWithoutStaffInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutStaffInput, AdminUncheckedCreateWithoutStaffInput>
  }

  export type HospitalUpsertWithoutTreatmentsInput = {
    update: XOR<HospitalUpdateWithoutTreatmentsInput, HospitalUncheckedUpdateWithoutTreatmentsInput>
    create: XOR<HospitalCreateWithoutTreatmentsInput, HospitalUncheckedCreateWithoutTreatmentsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutTreatmentsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutTreatmentsInput, HospitalUncheckedUpdateWithoutTreatmentsInput>
  }

  export type HospitalUpdateWithoutTreatmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutTreatmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type PatientUpsertWithoutTreatmentInput = {
    update: XOR<PatientUpdateWithoutTreatmentInput, PatientUncheckedUpdateWithoutTreatmentInput>
    create: XOR<PatientCreateWithoutTreatmentInput, PatientUncheckedCreateWithoutTreatmentInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTreatmentInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTreatmentInput, PatientUncheckedUpdateWithoutTreatmentInput>
  }

  export type PatientUpdateWithoutTreatmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTreatmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AdminUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutDoctorInput, AdminUncheckedUpdateWithoutDoctorInput>
    create: XOR<AdminCreateWithoutDoctorInput, AdminUncheckedCreateWithoutDoctorInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutDoctorInput, AdminUncheckedUpdateWithoutDoctorInput>
  }

  export type AdminUpdateManyWithWhereWithoutDoctorInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutDoctorInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutStaffInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutStaffInput, AdminUncheckedUpdateWithoutStaffInput>
    create: XOR<AdminCreateWithoutStaffInput, AdminUncheckedCreateWithoutStaffInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutStaffInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutStaffInput, AdminUncheckedUpdateWithoutStaffInput>
  }

  export type AdminUpdateManyWithWhereWithoutStaffInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutStaffInput>
  }

  export type MedicineAndInjectionCreateWithoutMedicianInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital: HospitalCreateNestedOneWithoutMedicineAndInjectionsInput
    Patient: PatientCreateNestedOneWithoutMedicineAndInjectionInput
    Injection?: InjectionCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionUncheckedCreateWithoutMedicianInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Injection?: InjectionUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionCreateOrConnectWithoutMedicianInput = {
    where: MedicineAndInjectionWhereUniqueInput
    create: XOR<MedicineAndInjectionCreateWithoutMedicianInput, MedicineAndInjectionUncheckedCreateWithoutMedicianInput>
  }

  export type HospitalCreateWithoutMediciansInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutMediciansInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutMediciansInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutMediciansInput, HospitalUncheckedCreateWithoutMediciansInput>
  }

  export type MedicineAndInjectionUpsertWithWhereUniqueWithoutMedicianInput = {
    where: MedicineAndInjectionWhereUniqueInput
    update: XOR<MedicineAndInjectionUpdateWithoutMedicianInput, MedicineAndInjectionUncheckedUpdateWithoutMedicianInput>
    create: XOR<MedicineAndInjectionCreateWithoutMedicianInput, MedicineAndInjectionUncheckedCreateWithoutMedicianInput>
  }

  export type MedicineAndInjectionUpdateWithWhereUniqueWithoutMedicianInput = {
    where: MedicineAndInjectionWhereUniqueInput
    data: XOR<MedicineAndInjectionUpdateWithoutMedicianInput, MedicineAndInjectionUncheckedUpdateWithoutMedicianInput>
  }

  export type MedicineAndInjectionUpdateManyWithWhereWithoutMedicianInput = {
    where: MedicineAndInjectionScalarWhereInput
    data: XOR<MedicineAndInjectionUpdateManyMutationInput, MedicineAndInjectionUncheckedUpdateManyWithoutMedicianInput>
  }

  export type HospitalUpsertWithoutMediciansInput = {
    update: XOR<HospitalUpdateWithoutMediciansInput, HospitalUncheckedUpdateWithoutMediciansInput>
    create: XOR<HospitalCreateWithoutMediciansInput, HospitalUncheckedCreateWithoutMediciansInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutMediciansInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutMediciansInput, HospitalUncheckedUpdateWithoutMediciansInput>
  }

  export type HospitalUpdateWithoutMediciansInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutMediciansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type MedicineAndInjectionCreateWithoutInjectionInput = {
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Hospital: HospitalCreateNestedOneWithoutMedicineAndInjectionsInput
    Patient: PatientCreateNestedOneWithoutMedicineAndInjectionInput
    Medician?: MedicianCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionUncheckedCreateWithoutInjectionInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Medician?: MedicianUncheckedCreateNestedManyWithoutMedicineAndInjectionInput
  }

  export type MedicineAndInjectionCreateOrConnectWithoutInjectionInput = {
    where: MedicineAndInjectionWhereUniqueInput
    create: XOR<MedicineAndInjectionCreateWithoutInjectionInput, MedicineAndInjectionUncheckedCreateWithoutInjectionInput>
  }

  export type HospitalCreateWithoutInjectionsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutInjectionsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutInjectionsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutInjectionsInput, HospitalUncheckedCreateWithoutInjectionsInput>
  }

  export type MedicineAndInjectionUpsertWithWhereUniqueWithoutInjectionInput = {
    where: MedicineAndInjectionWhereUniqueInput
    update: XOR<MedicineAndInjectionUpdateWithoutInjectionInput, MedicineAndInjectionUncheckedUpdateWithoutInjectionInput>
    create: XOR<MedicineAndInjectionCreateWithoutInjectionInput, MedicineAndInjectionUncheckedCreateWithoutInjectionInput>
  }

  export type MedicineAndInjectionUpdateWithWhereUniqueWithoutInjectionInput = {
    where: MedicineAndInjectionWhereUniqueInput
    data: XOR<MedicineAndInjectionUpdateWithoutInjectionInput, MedicineAndInjectionUncheckedUpdateWithoutInjectionInput>
  }

  export type MedicineAndInjectionUpdateManyWithWhereWithoutInjectionInput = {
    where: MedicineAndInjectionScalarWhereInput
    data: XOR<MedicineAndInjectionUpdateManyMutationInput, MedicineAndInjectionUncheckedUpdateManyWithoutInjectionInput>
  }

  export type HospitalUpsertWithoutInjectionsInput = {
    update: XOR<HospitalUpdateWithoutInjectionsInput, HospitalUncheckedUpdateWithoutInjectionsInput>
    create: XOR<HospitalCreateWithoutInjectionsInput, HospitalUncheckedCreateWithoutInjectionsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutInjectionsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutInjectionsInput, HospitalUncheckedUpdateWithoutInjectionsInput>
  }

  export type HospitalUpdateWithoutInjectionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutInjectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateWithoutTestingAndScanningHsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutTestingAndScanningHsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutTestingAndScanningHsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutTestingAndScanningHsInput, HospitalUncheckedCreateWithoutTestingAndScanningHsInput>
  }

  export type HospitalUpsertWithoutTestingAndScanningHsInput = {
    update: XOR<HospitalUpdateWithoutTestingAndScanningHsInput, HospitalUncheckedUpdateWithoutTestingAndScanningHsInput>
    create: XOR<HospitalCreateWithoutTestingAndScanningHsInput, HospitalUncheckedCreateWithoutTestingAndScanningHsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutTestingAndScanningHsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutTestingAndScanningHsInput, HospitalUncheckedUpdateWithoutTestingAndScanningHsInput>
  }

  export type HospitalUpdateWithoutTestingAndScanningHsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutTestingAndScanningHsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateWithoutMedicineAndInjectionsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutMedicineAndInjectionsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutMedicineAndInjectionsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutMedicineAndInjectionsInput, HospitalUncheckedCreateWithoutMedicineAndInjectionsInput>
  }

  export type PatientCreateWithoutMedicineAndInjectionInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicineAndInjectionInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicineAndInjectionInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicineAndInjectionInput, PatientUncheckedCreateWithoutMedicineAndInjectionInput>
  }

  export type MedicianCreateWithoutMedicineAndInjectionInput = {
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    Hospital: HospitalCreateNestedOneWithoutMediciansInput
  }

  export type MedicianUncheckedCreateWithoutMedicineAndInjectionInput = {
    id?: number
    hospital_Id: number
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
  }

  export type MedicianCreateOrConnectWithoutMedicineAndInjectionInput = {
    where: MedicianWhereUniqueInput
    create: XOR<MedicianCreateWithoutMedicineAndInjectionInput, MedicianUncheckedCreateWithoutMedicineAndInjectionInput>
  }

  export type InjectionCreateWithoutMedicineAndInjectionInput = {
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
    Hospital: HospitalCreateNestedOneWithoutInjectionsInput
  }

  export type InjectionUncheckedCreateWithoutMedicineAndInjectionInput = {
    id?: number
    hospital_Id: number
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
  }

  export type InjectionCreateOrConnectWithoutMedicineAndInjectionInput = {
    where: InjectionWhereUniqueInput
    create: XOR<InjectionCreateWithoutMedicineAndInjectionInput, InjectionUncheckedCreateWithoutMedicineAndInjectionInput>
  }

  export type HospitalUpsertWithoutMedicineAndInjectionsInput = {
    update: XOR<HospitalUpdateWithoutMedicineAndInjectionsInput, HospitalUncheckedUpdateWithoutMedicineAndInjectionsInput>
    create: XOR<HospitalCreateWithoutMedicineAndInjectionsInput, HospitalUncheckedCreateWithoutMedicineAndInjectionsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutMedicineAndInjectionsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutMedicineAndInjectionsInput, HospitalUncheckedUpdateWithoutMedicineAndInjectionsInput>
  }

  export type HospitalUpdateWithoutMedicineAndInjectionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutMedicineAndInjectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type PatientUpsertWithoutMedicineAndInjectionInput = {
    update: XOR<PatientUpdateWithoutMedicineAndInjectionInput, PatientUncheckedUpdateWithoutMedicineAndInjectionInput>
    create: XOR<PatientCreateWithoutMedicineAndInjectionInput, PatientUncheckedCreateWithoutMedicineAndInjectionInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicineAndInjectionInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicineAndInjectionInput, PatientUncheckedUpdateWithoutMedicineAndInjectionInput>
  }

  export type PatientUpdateWithoutMedicineAndInjectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicineAndInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicianUpsertWithWhereUniqueWithoutMedicineAndInjectionInput = {
    where: MedicianWhereUniqueInput
    update: XOR<MedicianUpdateWithoutMedicineAndInjectionInput, MedicianUncheckedUpdateWithoutMedicineAndInjectionInput>
    create: XOR<MedicianCreateWithoutMedicineAndInjectionInput, MedicianUncheckedCreateWithoutMedicineAndInjectionInput>
  }

  export type MedicianUpdateWithWhereUniqueWithoutMedicineAndInjectionInput = {
    where: MedicianWhereUniqueInput
    data: XOR<MedicianUpdateWithoutMedicineAndInjectionInput, MedicianUncheckedUpdateWithoutMedicineAndInjectionInput>
  }

  export type MedicianUpdateManyWithWhereWithoutMedicineAndInjectionInput = {
    where: MedicianScalarWhereInput
    data: XOR<MedicianUpdateManyMutationInput, MedicianUncheckedUpdateManyWithoutMedicineAndInjectionInput>
  }

  export type InjectionUpsertWithWhereUniqueWithoutMedicineAndInjectionInput = {
    where: InjectionWhereUniqueInput
    update: XOR<InjectionUpdateWithoutMedicineAndInjectionInput, InjectionUncheckedUpdateWithoutMedicineAndInjectionInput>
    create: XOR<InjectionCreateWithoutMedicineAndInjectionInput, InjectionUncheckedCreateWithoutMedicineAndInjectionInput>
  }

  export type InjectionUpdateWithWhereUniqueWithoutMedicineAndInjectionInput = {
    where: InjectionWhereUniqueInput
    data: XOR<InjectionUpdateWithoutMedicineAndInjectionInput, InjectionUncheckedUpdateWithoutMedicineAndInjectionInput>
  }

  export type InjectionUpdateManyWithWhereWithoutMedicineAndInjectionInput = {
    where: InjectionScalarWhereInput
    data: XOR<InjectionUpdateManyMutationInput, InjectionUncheckedUpdateManyWithoutMedicineAndInjectionInput>
  }

  export type HospitalCreateWithoutTestingAndScanningsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutTestingAndScanningsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutTestingAndScanningsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutTestingAndScanningsInput, HospitalUncheckedCreateWithoutTestingAndScanningsInput>
  }

  export type PatientCreateWithoutTestingAndScanningInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    Payments?: PaymentCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTestingAndScanningInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTestingAndScanningInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTestingAndScanningInput, PatientUncheckedCreateWithoutTestingAndScanningInput>
  }

  export type HospitalUpsertWithoutTestingAndScanningsInput = {
    update: XOR<HospitalUpdateWithoutTestingAndScanningsInput, HospitalUncheckedUpdateWithoutTestingAndScanningsInput>
    create: XOR<HospitalCreateWithoutTestingAndScanningsInput, HospitalUncheckedCreateWithoutTestingAndScanningsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutTestingAndScanningsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutTestingAndScanningsInput, HospitalUncheckedUpdateWithoutTestingAndScanningsInput>
  }

  export type HospitalUpdateWithoutTestingAndScanningsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutTestingAndScanningsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type PatientUpsertWithoutTestingAndScanningInput = {
    update: XOR<PatientUpdateWithoutTestingAndScanningInput, PatientUncheckedUpdateWithoutTestingAndScanningInput>
    create: XOR<PatientCreateWithoutTestingAndScanningInput, PatientUncheckedCreateWithoutTestingAndScanningInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTestingAndScanningInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTestingAndScanningInput, PatientUncheckedUpdateWithoutTestingAndScanningInput>
  }

  export type PatientUpdateWithoutTestingAndScanningInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTestingAndScanningInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type HospitalCreateWithoutPaymentsInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutPaymentsInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    RoomsAvailables?: RoomsAvailableUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutPaymentsInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutPaymentsInput, HospitalUncheckedCreateWithoutPaymentsInput>
  }

  export type PatientCreateWithoutPaymentsInput = {
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPCreateNestedManyWithoutPatientInput
    Hospital: HospitalCreateNestedOneWithoutPatientsInput
    User: UserCreateNestedOneWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPaymentsInput = {
    id?: number
    hospital_Id: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    Treatment?: TreatmentUncheckedCreateNestedManyWithoutPatientInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedCreateNestedManyWithoutPatientInput
    TestingAndScanning?: TestingAndScanningPUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPaymentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
  }

  export type HospitalUpsertWithoutPaymentsInput = {
    update: XOR<HospitalUpdateWithoutPaymentsInput, HospitalUncheckedUpdateWithoutPaymentsInput>
    create: XOR<HospitalCreateWithoutPaymentsInput, HospitalUncheckedCreateWithoutPaymentsInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutPaymentsInput, HospitalUncheckedUpdateWithoutPaymentsInput>
  }

  export type HospitalUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    RoomsAvailables?: RoomsAvailableUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type PatientUpsertWithoutPaymentsInput = {
    update: XOR<PatientUpdateWithoutPaymentsInput, PatientUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PatientCreateWithoutPaymentsInput, PatientUncheckedCreateWithoutPaymentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPaymentsInput, PatientUncheckedUpdateWithoutPaymentsInput>
  }

  export type PatientUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type HospitalCreateWithoutRoomsAvailablesInput = {
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserCreateNestedManyWithoutHospitalInput
    Admins?: AdminCreateNestedManyWithoutHospitalInput
    Patients?: PatientCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianCreateNestedManyWithoutHospitalInput
    Injections?: InjectionCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHCreateNestedManyWithoutHospitalInput
    Payments?: PaymentCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutRoomsAvailablesInput = {
    id?: number
    name: string
    address: string
    photo: string
    HospitalStatus?: $Enums.HospitalStatus
    phone: string
    mail: string
    Users?: UserUncheckedCreateNestedManyWithoutHospitalInput
    Admins?: AdminUncheckedCreateNestedManyWithoutHospitalInput
    Patients?: PatientUncheckedCreateNestedManyWithoutHospitalInput
    Consultation?: ConsultationUncheckedCreateNestedManyWithoutHospitalInput
    Treatments?: TreatmentUncheckedCreateNestedManyWithoutHospitalInput
    Medicians?: MedicianUncheckedCreateNestedManyWithoutHospitalInput
    Injections?: InjectionUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScannings?: TestingAndScanningPUncheckedCreateNestedManyWithoutHospitalInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedCreateNestedManyWithoutHospitalInput
    Payments?: PaymentUncheckedCreateNestedManyWithoutHospitalInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutRoomsAvailablesInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutRoomsAvailablesInput, HospitalUncheckedCreateWithoutRoomsAvailablesInput>
  }

  export type HospitalUpsertWithoutRoomsAvailablesInput = {
    update: XOR<HospitalUpdateWithoutRoomsAvailablesInput, HospitalUncheckedUpdateWithoutRoomsAvailablesInput>
    create: XOR<HospitalCreateWithoutRoomsAvailablesInput, HospitalUncheckedCreateWithoutRoomsAvailablesInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutRoomsAvailablesInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutRoomsAvailablesInput, HospitalUncheckedUpdateWithoutRoomsAvailablesInput>
  }

  export type HospitalUpdateWithoutRoomsAvailablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutRoomsAvailablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    HospitalStatus?: EnumHospitalStatusFieldUpdateOperationsInput | $Enums.HospitalStatus
    phone?: StringFieldUpdateOperationsInput | string
    mail?: StringFieldUpdateOperationsInput | string
    Users?: UserUncheckedUpdateManyWithoutHospitalNestedInput
    Admins?: AdminUncheckedUpdateManyWithoutHospitalNestedInput
    Patients?: PatientUncheckedUpdateManyWithoutHospitalNestedInput
    Consultation?: ConsultationUncheckedUpdateManyWithoutHospitalNestedInput
    Treatments?: TreatmentUncheckedUpdateManyWithoutHospitalNestedInput
    Medicians?: MedicianUncheckedUpdateManyWithoutHospitalNestedInput
    Injections?: InjectionUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScannings?: TestingAndScanningPUncheckedUpdateManyWithoutHospitalNestedInput
    TestingAndScanningHs?: TestingAndScanningHUncheckedUpdateManyWithoutHospitalNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutHospitalNestedInput
    MedicineAndInjections?: MedicineAndInjectionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type UserCreateManyHospitalInput = {
    id?: number
    user_Id: number
    password: string
    role: string
  }

  export type AdminCreateManyHospitalInput = {
    id?: number
    user_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyHospitalInput = {
    id?: number
    user_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultationCreateManyHospitalInput = {
    id?: number
    patient_Id: number
    doctor_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type TreatmentCreateManyHospitalInput = {
    id?: number
    staff_Id: JsonNullValueInput | InputJsonValue
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type MedicianCreateManyHospitalInput = {
    id?: number
    medicianName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
  }

  export type InjectionCreateManyHospitalInput = {
    id?: number
    injectionName: string
    stock: number
    amount: number
    staffId: JsonNullValueInput | InputJsonValue
  }

  export type TestingAndScanningPCreateManyHospitalInput = {
    id?: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
  }

  export type TestingAndScanningHCreateManyHospitalInput = {
    id?: number
    type: string
    status: string
    roomNo: string
    staffId: number
    amount: number
  }

  export type RoomsAvailableCreateManyHospitalInput = {
    id?: number
    staffId: number
    roomNo: string
    capacity: number
    notes: string
    type: string
    amount: number
  }

  export type PaymentCreateManyHospitalInput = {
    id?: number
    patient_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineAndInjectionCreateManyHospitalInput = {
    id?: number
    patient_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutHospitalInput = {
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Patient?: PatientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    AdminStrator?: AdminStratorUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Patient?: PatientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutHospitalInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUpdateManyWithoutStaffNestedInput
    User?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutHospitalInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    User?: UserUpdateOneRequiredWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationUpdateWithoutHospitalInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Patient?: PatientUpdateOneRequiredWithoutConsultationNestedInput
    Doctor?: AdminUpdateOneRequiredWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreatmentUpdateWithoutHospitalInput = {
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Patient?: PatientUpdateOneRequiredWithoutTreatmentNestedInput
    Doctor?: AdminUpdateManyWithoutDoctorNestedInput
    Staff?: AdminUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Doctor?: AdminUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: AdminUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicianUpdateWithoutHospitalInput = {
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutMedicianNestedInput
  }

  export type MedicianUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutMedicianNestedInput
  }

  export type MedicianUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type InjectionUpdateWithoutHospitalInput = {
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutInjectionNestedInput
  }

  export type InjectionUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutInjectionNestedInput
  }

  export type InjectionUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type TestingAndScanningPUpdateWithoutHospitalInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
    Patient?: PatientUpdateOneRequiredWithoutTestingAndScanningNestedInput
  }

  export type TestingAndScanningPUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type TestingAndScanningPUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type TestingAndScanningHUpdateWithoutHospitalInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TestingAndScanningHUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type TestingAndScanningHUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    roomNo?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RoomsAvailableUpdateWithoutHospitalInput = {
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RoomsAvailableUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type RoomsAvailableUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    roomNo?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentUpdateWithoutHospitalInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Patient?: PatientUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineAndInjectionUpdateWithoutHospitalInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Patient?: PatientUpdateOneRequiredWithoutMedicineAndInjectionNestedInput
    Medician?: MedicianUpdateManyWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Medician?: MedicianUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminStratorCreateManyUserInput = {
    id?: number
    name: string
    status: string
    destination: string
    phone: string
    email: string
    photo: string
    address: string
    gender: string
  }

  export type AdminCreateManyUserInput = {
    id?: number
    hospital_Id: number
    destination: string
    phone: string
    email: string
    address: string
    photo: string
    name: string
    status: string
    gender: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyUserInput = {
    id?: number
    hospital_Id: number
    name: string
    phone: JsonNullValueInput | InputJsonValue
    email: JsonNullValueInput | InputJsonValue
    photo: string
    status: string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob: Date | string
    gender: string
    bldGrp: string
    currentProblem: string
    medicalHistory: string
    height: number
    weight: number
    bp: string
    sugar: string
    custom: JsonNullValueInput | InputJsonValue
    tempCreatedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminStratorUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
  }

  export type AdminStratorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
  }

  export type AdminStratorUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUpdateWithoutUserInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUpdateManyWithoutStaffNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutAdminsNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUpdateManyWithoutPatientNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    Treatment?: TreatmentUncheckedUpdateManyWithoutPatientNestedInput
    MedicineAndInjection?: MedicineAndInjectionUncheckedUpdateManyWithoutPatientNestedInput
    TestingAndScanning?: TestingAndScanningPUncheckedUpdateManyWithoutPatientNestedInput
    Payments?: PaymentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: JsonNullValueInput | InputJsonValue
    email?: JsonNullValueInput | InputJsonValue
    photo?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    bldGrp?: StringFieldUpdateOperationsInput | string
    currentProblem?: StringFieldUpdateOperationsInput | string
    medicalHistory?: StringFieldUpdateOperationsInput | string
    height?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    bp?: StringFieldUpdateOperationsInput | string
    sugar?: StringFieldUpdateOperationsInput | string
    custom?: JsonNullValueInput | InputJsonValue
    tempCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationCreateManyDoctorInput = {
    id?: number
    hospital_Id: number
    patient_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type ConsultationUpdateWithoutDoctorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutConsultationNestedInput
    Patient?: PatientUpdateOneRequiredWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreatmentUpdateWithoutDoctorInput = {
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutTreatmentsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutTreatmentNestedInput
    Staff?: AdminUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Staff?: AdminUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreatmentUpdateWithoutStaffInput = {
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutTreatmentsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutTreatmentNestedInput
    Doctor?: AdminUpdateManyWithoutDoctorNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Doctor?: AdminUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationCreateManyPatientInput = {
    id?: number
    hospital_Id: number
    doctor_Id: number
    date: Date | string
    purpose: string
    temperature: number
    symptoms: string
    notes: JsonNullValueInput | InputJsonValue
    diagnosis: string
    treatment: boolean
    medicineInjection: boolean
    scanningTesting: boolean
    status: string
    access: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type TreatmentCreateManyPatientInput = {
    id?: number
    hospital_Id: number
    staff_Id: JsonNullValueInput | InputJsonValue
    doctor_Id: JsonNullValueInput | InputJsonValue
    treatmentName: JsonNullValueInput | InputJsonValue
    startDate: Date | string
    endDate: Date | string
    progress: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentStatus: boolean
  }

  export type MedicineAndInjectionCreateManyPatientInput = {
    id?: number
    hospital_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    medicine_Id: JsonNullValueInput | InputJsonValue
    frequencyMedicine: JsonNullValueInput | InputJsonValue
    injection_Id: JsonNullValueInput | InputJsonValue
    frequencyInjection: JsonNullValueInput | InputJsonValue
    status: string
    notes: JsonNullValueInput | InputJsonValue
    paymentStatus: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestingAndScanningPCreateManyPatientInput = {
    id?: number
    hospital_Id: number
    doctor_Id: JsonNullValueInput | InputJsonValue
    staff_Id: JsonNullValueInput | InputJsonValue
    title: string
    scheduleDate: Date | string
    type: string
    status: string
    paymentStatus: boolean
    result: string
  }

  export type PaymentCreateManyPatientInput = {
    id?: number
    hospital_Id: number
    reason: string
    status: $Enums.PaymentStatus
    amount: number
    transactionId: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultationUpdateWithoutPatientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutConsultationNestedInput
    Doctor?: AdminUpdateOneRequiredWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purpose?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    symptoms?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    diagnosis?: StringFieldUpdateOperationsInput | string
    treatment?: BoolFieldUpdateOperationsInput | boolean
    medicineInjection?: BoolFieldUpdateOperationsInput | boolean
    scanningTesting?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    access?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreatmentUpdateWithoutPatientInput = {
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Hospital?: HospitalUpdateOneRequiredWithoutTreatmentsNestedInput
    Doctor?: AdminUpdateManyWithoutDoctorNestedInput
    Staff?: AdminUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    Doctor?: AdminUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: AdminUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type TreatmentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    staff_Id?: JsonNullValueInput | InputJsonValue
    doctor_Id?: JsonNullValueInput | InputJsonValue
    treatmentName?: JsonNullValueInput | InputJsonValue
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicineAndInjectionUpdateWithoutPatientInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneRequiredWithoutMedicineAndInjectionsNestedInput
    Medician?: MedicianUpdateManyWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Medician?: MedicianUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestingAndScanningPUpdateWithoutPatientInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
    Hospital?: HospitalUpdateOneRequiredWithoutTestingAndScanningsNestedInput
  }

  export type TestingAndScanningPUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type TestingAndScanningPUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    result?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutPatientInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: FloatFieldUpdateOperationsInput | number
    transactionId?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUpdateWithoutDoctorInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUpdateManyWithoutStaffNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutAdminsNestedInput
    User?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    Staff?: TreatmentUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUpdateWithoutStaffInput = {
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUpdateManyWithoutDoctorNestedInput
    Hospital?: HospitalUpdateOneRequiredWithoutAdminsNestedInput
    User?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Consultation?: ConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    Doctor?: TreatmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    user_Id?: IntFieldUpdateOperationsInput | number
    destination?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineAndInjectionUpdateWithoutMedicianInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneRequiredWithoutMedicineAndInjectionsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutMedicineAndInjectionNestedInput
    Injection?: InjectionUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateWithoutMedicianInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Injection?: InjectionUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutMedicianInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineAndInjectionUpdateWithoutInjectionInput = {
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hospital?: HospitalUpdateOneRequiredWithoutMedicineAndInjectionsNestedInput
    Patient?: PatientUpdateOneRequiredWithoutMedicineAndInjectionNestedInput
    Medician?: MedicianUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateWithoutInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Medician?: MedicianUncheckedUpdateManyWithoutMedicineAndInjectionNestedInput
  }

  export type MedicineAndInjectionUncheckedUpdateManyWithoutInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    patient_Id?: IntFieldUpdateOperationsInput | number
    doctor_Id?: JsonNullValueInput | InputJsonValue
    staff_Id?: JsonNullValueInput | InputJsonValue
    medicine_Id?: JsonNullValueInput | InputJsonValue
    frequencyMedicine?: JsonNullValueInput | InputJsonValue
    injection_Id?: JsonNullValueInput | InputJsonValue
    frequencyInjection?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    notes?: JsonNullValueInput | InputJsonValue
    paymentStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicianUpdateWithoutMedicineAndInjectionInput = {
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    Hospital?: HospitalUpdateOneRequiredWithoutMediciansNestedInput
  }

  export type MedicianUncheckedUpdateWithoutMedicineAndInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type MedicianUncheckedUpdateManyWithoutMedicineAndInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    medicianName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type InjectionUpdateWithoutMedicineAndInjectionInput = {
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
    Hospital?: HospitalUpdateOneRequiredWithoutInjectionsNestedInput
  }

  export type InjectionUncheckedUpdateWithoutMedicineAndInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }

  export type InjectionUncheckedUpdateManyWithoutMedicineAndInjectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hospital_Id?: IntFieldUpdateOperationsInput | number
    injectionName?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    staffId?: JsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}